# Generated by Haxe 4.1.4
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
from io import StringIO as python_lib_io_StringIO
import sys as python_lib_Sys
import re as python_lib_Re
import builtins as python_lib_Builtins
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import socket as python_lib_Socket
import ssl as python_lib_Ssl
import subprocess as python_lib_Subprocess
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
try:
    import tty as python_lib_Tty
except:
    pass
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timedelta as python_lib_datetime_Timedelta
from datetime import timezone as python_lib_datetime_Timezone
from io import BufferedReader as python_lib_io_BufferedReader
from io import BufferedWriter as python_lib_io_BufferedWriter
from io import TextIOWrapper as python_lib_io_TextIOWrapper
from socket import socket as python_lib_socket_Socket
from ssl import SSLContext as python_lib_ssl_SSLContext
from subprocess import Popen as python_lib_subprocess_Popen
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["getTimezoneOffset"]
    _hx_statics = ["now", "fromTime", "makeLocal", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def getTimezoneOffset(self):
        x = (self.date.utcoffset() / python_lib_datetime_Timedelta(0,60))
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        return -tmp

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date.fromTime((((Std.parseInt((k[0] if 0 < len(k) else None)) * 3600000.) + ((Std.parseInt((k[1] if 1 < len(k) else None)) * 60000.))) + ((Std.parseInt((k[2] if 2 < len(k) else None)) * 1000.))))
        elif (_g == 10):
            k = s.split("-")
            return Date(Std.parseInt((k[0] if 0 < len(k) else None)),(Std.parseInt((k[1] if 1 < len(k) else None)) - 1),Std.parseInt((k[2] if 2 < len(k) else None)),0,0,0)
        elif (_g == 19):
            k = s.split(" ")
            _this = (k[0] if 0 < len(k) else None)
            y = _this.split("-")
            _this = (k[1] if 1 < len(k) else None)
            t = _this.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise haxe_Exception.thrown(("Invalid date format : " + ("null" if s is None else s)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
Date._hx_class = Date


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["matchSub", "split", "replace", "map"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def matchSub(self,s,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x = HxString.substr(s,lastEnd,None)
            ret.append(x)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]

    def replace(self,s,by):
        _this = by.split("$$")
        by = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this])
            _this = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg


class IntIterator:
    _hx_class_name = "IntIterator"
    __slots__ = ("min", "max")
    _hx_fields = ["min", "max"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_min,_hx_max):
        self.min = _hx_min
        self.max = _hx_max

    def hasNext(self):
        return (self.min < self.max)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.min
                _hx_local_0.min = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_local_2()
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.min = None
        _hx_o.max = None
IntIterator._hx_class = IntIterator


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["array", "list", "map", "mapi", "flatten", "flatMap", "has", "exists", "foreach", "iter", "filter", "fold", "count", "empty", "indexOf", "find", "concat"]

    @staticmethod
    def array(it):
        a = list()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            a.append(i1)
        return a

    @staticmethod
    def list(it):
        l = haxe_ds_List()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            l.add(i1)
        return l

    @staticmethod
    def map(it,f):
        l = haxe_ds_List()
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            l.add(f(x1))
        return l

    @staticmethod
    def mapi(it,f):
        l = haxe_ds_List()
        i = 0
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            tmp = i
            i = (i + 1)
            l.add(f(tmp,x1))
        return l

    @staticmethod
    def flatten(it):
        l = haxe_ds_List()
        e = HxOverrides.iterator(it)
        while e.hasNext():
            e1 = e.next()
            x = HxOverrides.iterator(e1)
            while x.hasNext():
                x1 = x.next()
                l.add(x1)
        return l

    @staticmethod
    def flatMap(it,f):
        return Lambda.flatten(Lambda.map(it,f))

    @staticmethod
    def has(it,elt):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if HxOverrides.eq(x1,elt):
                return True
        return False

    @staticmethod
    def exists(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if f(x1):
                return True
        return False

    @staticmethod
    def foreach(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if (not f(x1)):
                return False
        return True

    @staticmethod
    def iter(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            f(x1)

    @staticmethod
    def filter(it,f):
        l = haxe_ds_List()
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if f(x1):
                l.add(x1)
        return l

    @staticmethod
    def fold(it,f,first):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            first = f(x1,first)
        return first

    @staticmethod
    def count(it,pred = None):
        n = 0
        if (pred is None):
            _ = HxOverrides.iterator(it)
            while _.hasNext():
                _1 = _.next()
                n = (n + 1)
        else:
            x = HxOverrides.iterator(it)
            while x.hasNext():
                x1 = x.next()
                if pred(x1):
                    n = (n + 1)
        return n

    @staticmethod
    def empty(it):
        return (not HxOverrides.iterator(it).hasNext())

    @staticmethod
    def indexOf(it,v):
        i = 0
        v2 = HxOverrides.iterator(it)
        while v2.hasNext():
            v21 = v2.next()
            if HxOverrides.eq(v,v21):
                return i
            i = (i + 1)
        return -1

    @staticmethod
    def find(it,f):
        v = HxOverrides.iterator(it)
        while v.hasNext():
            v1 = v.next()
            if f(v1):
                return v1
        return None

    @staticmethod
    def concat(a,b):
        l = haxe_ds_List()
        x = HxOverrides.iterator(a)
        while x.hasNext():
            x1 = x.next()
            l.add(x1)
        x = HxOverrides.iterator(b)
        while x.hasNext():
            x1 = x.next()
            l.add(x1)
        return l
Lambda._hx_class = Lambda


class Main:
    _hx_class_name = "Main"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        interp = hiss_CCInterp()
        interp.load("C:/Python37/Scripts/tem-notify.hiss")
Main._hx_class = Main


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "getProperty", "setProperty", "callMethod", "isFunction", "compare", "compareMethods", "isObject", "copy"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def getProperty(o,field):
        if (o is None):
            return None
        if (field in python_Boot.keywords):
            field = ("_hx_" + field)
        elif ((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95))):
            field = ("_hx_" + field)
        if isinstance(o,_hx_AnonObject):
            return Reflect.field(o,field)
        tmp = Reflect.field(o,("get_" + ("null" if field is None else field)))
        if ((tmp is not None) and callable(tmp)):
            return tmp()
        else:
            return Reflect.field(o,field)

    @staticmethod
    def setProperty(o,field,value):
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if isinstance(o,_hx_AnonObject):
            setattr(o,field1,value)
        elif hasattr(o,("set_" + ("null" if field1 is None else field1))):
            getattr(o,("set_" + ("null" if field1 is None else field1)))(value)
        else:
            setattr(o,field1,value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def compareMethods(f1,f2):
        if HxOverrides.eq(f1,f2):
            return True
        if (isinstance(f1,python_internal_MethodClosure) and isinstance(f2,python_internal_MethodClosure)):
            m1 = f1
            m2 = f2
            if HxOverrides.eq(m1.obj,m2.obj):
                return (m1.func == m2.func)
            else:
                return False
        if ((not Reflect.isFunction(f1)) or (not Reflect.isFunction(f2))):
            return False
        return False

    @staticmethod
    def isObject(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 4):
            return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def copy(o):
        if (o is None):
            return None
        o2 = _hx_AnonObject({})
        _g = 0
        _g1 = python_Boot.fields(o)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(o,f)
            setattr(o2,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        return o2
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat", "random"]

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN

    @staticmethod
    def random(x):
        if (x <= 0):
            return 0
        else:
            return int((python_lib_Random.random() * x))
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith", "endsWith", "isSpace", "ltrim", "rtrim", "trim", "lpad", "rpad", "replace", "hex"]

    @staticmethod
    def startsWith(s,start):
        return s.startswith(start)

    @staticmethod
    def endsWith(s,end):
        return s.endswith(end)

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s1 = Std.string(s)
        buf.b.write(s1)
        return buf.b.getvalue()

    @staticmethod
    def rpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        s1 = Std.string(s)
        buf.b.write(s1)
        while (buf.get_length() < l):
            s = Std.string(c)
            buf.b.write(s)
        return buf.b.getvalue()

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "isDirectory", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "keys"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys", "copy"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def copy(self):
        copied = haxe_ds_StringMap()
        key = self.keys()
        while key.hasNext():
            key1 = key.next()
            value = self.h.get(key1,None)
            copied.h[key1] = value
        return copied

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "exit", "args", "getEnv", "sleep", "systemName", "getChar", "stdin"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except BaseException as _g1:
                    None
                    e = haxe_Exception.caught(_g1).unwrap()
                    restore()
                    raise haxe_Exception.thrown(e)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except BaseException as _g1:
                    None
                    e = haxe_Exception.caught(_g1).unwrap()
                    restore()
                    raise haxe_Exception.thrown(e)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getwch(),0)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        else:
            x = _g
            raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        if echo:
            python_Lib.printString(Std.string("".join(map(chr,[ch]))))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getEnum", "getSuperClass", "getClassName", "getEnumName", "createEmptyInstance", "typeof", "enumEq"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getEnum(o):
        if (o is None):
            return None
        return o.__class__

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except BaseException as _g:
                None
                return None

    @staticmethod
    def getEnumName(e):
        return e._hx_class_name

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except BaseException as _g:
            None
            return False
        return True
Type._hx_class = Type

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
haxe_StackItem._hx_class = haxe_StackItem


class haxe__CallStack_CallStack_Impl_:
    _hx_class_name = "haxe._CallStack.CallStack_Impl_"
    __slots__ = ()
    _hx_statics = ["callStack", "exceptionStack", "toString", "subtract", "equalItems", "itemToString"]

    @staticmethod
    def callStack():
        infos = python_lib_Traceback.extract_stack()
        if (len(infos) != 0):
            infos.pop()
        infos.reverse()
        return haxe_NativeStackTrace.toHaxe(infos)

    @staticmethod
    def exceptionStack():
        eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack())
        return haxe__CallStack_CallStack_Impl_.subtract(eStack,haxe__CallStack_CallStack_Impl_.callStack())

    @staticmethod
    def toString(stack):
        b = StringBuf()
        _g = 0
        _g1 = stack
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.b.write("\nCalled from ")
            haxe__CallStack_CallStack_Impl_.itemToString(b,s)
        return b.b.getvalue()

    @staticmethod
    def subtract(this1,stack):
        startIndex = -1
        i = -1
        while True:
            i = (i + 1)
            tmp = i
            if (not ((tmp < len(this1)))):
                break
            _g = 0
            _g1 = len(stack)
            while (_g < _g1):
                j = _g
                _g = (_g + 1)
                if haxe__CallStack_CallStack_Impl_.equalItems((this1[i] if i >= 0 and i < len(this1) else None),python_internal_ArrayImpl._get(stack, j)):
                    if (startIndex < 0):
                        startIndex = i
                    i = (i + 1)
                    if (i >= len(this1)):
                        break
                else:
                    startIndex = -1
            if (startIndex >= 0):
                break
        if (startIndex >= 0):
            return this1[0:startIndex]
        else:
            return this1

    @staticmethod
    def equalItems(item1,item2):
        if (item1 is None):
            if (item2 is None):
                return True
            else:
                return False
        else:
            tmp = item1.index
            if (tmp == 0):
                if (item2 is None):
                    return False
                elif (item2.index == 0):
                    return True
                else:
                    return False
            elif (tmp == 1):
                if (item2 is None):
                    return False
                elif (item2.index == 1):
                    m1 = item1.params[0]
                    m2 = item2.params[0]
                    return (m1 == m2)
                else:
                    return False
            elif (tmp == 2):
                if (item2 is None):
                    return False
                elif (item2.index == 2):
                    item11 = item1.params[0]
                    file1 = item1.params[1]
                    line1 = item1.params[2]
                    col1 = item1.params[3]
                    col2 = item2.params[3]
                    line2 = item2.params[2]
                    file2 = item2.params[1]
                    item21 = item2.params[0]
                    if (((file1 == file2) and ((line1 == line2))) and ((col1 == col2))):
                        return haxe__CallStack_CallStack_Impl_.equalItems(item11,item21)
                    else:
                        return False
                else:
                    return False
            elif (tmp == 3):
                if (item2 is None):
                    return False
                elif (item2.index == 3):
                    class1 = item1.params[0]
                    method1 = item1.params[1]
                    method2 = item2.params[1]
                    class2 = item2.params[0]
                    if (class1 == class2):
                        return (method1 == method2)
                    else:
                        return False
                else:
                    return False
            elif (tmp == 4):
                if (item2 is None):
                    return False
                elif (item2.index == 4):
                    v1 = item1.params[0]
                    v2 = item2.params[0]
                    return (v1 == v2)
                else:
                    return False
            else:
                pass

    @staticmethod
    def itemToString(b,s):
        tmp = s.index
        if (tmp == 0):
            b.b.write("a C function")
        elif (tmp == 1):
            m = s.params[0]
            b.b.write("module ")
            s1 = Std.string(m)
            b.b.write(s1)
        elif (tmp == 2):
            col = s.params[3]
            line = s.params[2]
            file = s.params[1]
            s1 = s.params[0]
            if (s1 is not None):
                haxe__CallStack_CallStack_Impl_.itemToString(b,s1)
                b.b.write(" (")
            s2 = Std.string(file)
            b.b.write(s2)
            b.b.write(" line ")
            s2 = Std.string(line)
            b.b.write(s2)
            if (col is not None):
                b.b.write(" column ")
                s2 = Std.string(col)
                b.b.write(s2)
            if (s1 is not None):
                b.b.write(")")
        elif (tmp == 3):
            meth = s.params[1]
            cname = s.params[0]
            s1 = Std.string(("<unknown>" if ((cname is None)) else cname))
            b.b.write(s1)
            b.b.write(".")
            s1 = Std.string(meth)
            b.b.write(s1)
        elif (tmp == 4):
            n = s.params[0]
            b.b.write("local function #")
            s = Std.string(n)
            b.b.write(s)
        else:
            pass
haxe__CallStack_CallStack_Impl_._hx_class = haxe__CallStack_CallStack_Impl_


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while True:
            nextTick = haxe_EntryPoint.processEvents()
            if (nextTick < 0):
                break
            tmp = (nextTick > 0)
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None
haxe_Exception._hx_class = haxe_Exception


class haxe__Int32_Int32_Impl_:
    _hx_class_name = "haxe._Int32.Int32_Impl_"
    __slots__ = ()
    _hx_statics = ["mul", "ucompare"]

    @staticmethod
    def mul(a,b):
        return ((((a * ((b & 65535))) + ((((((a * (HxOverrides.rshift(b, 16))) << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))

    @staticmethod
    def ucompare(a,b):
        if (a < 0):
            if (b < 0):
                return (((((~b + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - (((~a + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            else:
                return 1
        if (b < 0):
            return -1
        else:
            return (((a - b) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
haxe__Int32_Int32_Impl_._hx_class = haxe__Int32_Int32_Impl_


class haxe__Int64_Int64_Impl_:
    _hx_class_name = "haxe._Int64.Int64_Impl_"
    __slots__ = ()
    _hx_statics = ["divMod"]

    @staticmethod
    def divMod(dividend,divisor):
        if (divisor.high == 0):
            _g = divisor.low
            if (_g == 0):
                raise haxe_Exception.thrown("divide by zero")
            elif (_g == 1):
                this1 = haxe__Int64____Int64(dividend.high,dividend.low)
                this2 = haxe__Int64____Int64(0,0)
                return _hx_AnonObject({'quotient': this1, 'modulus': this2})
            else:
                pass
        divSign = ((dividend.high < 0) != ((divisor.high < 0)))
        modulus = None
        if (dividend.high < 0):
            high = ((~dividend.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~dividend.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            modulus = this1
        else:
            this1 = haxe__Int64____Int64(dividend.high,dividend.low)
            modulus = this1
        if (divisor.high < 0):
            high = ((~divisor.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~divisor.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            divisor = this1
        this1 = haxe__Int64____Int64(0,0)
        quotient = this1
        this1 = haxe__Int64____Int64(0,1)
        mask = this1
        while (not ((divisor.high < 0))):
            v = haxe__Int32_Int32_Impl_.ucompare(divisor.high,modulus.high)
            cmp = (v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(divisor.low,modulus.low))
            b = 1
            b = (b & 63)
            if (b == 0):
                this1 = haxe__Int64____Int64(divisor.high,divisor.low)
                divisor = this1
            elif (b < 32):
                this2 = haxe__Int64____Int64(((((((((divisor.high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(divisor.low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((divisor.low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                divisor = this2
            else:
                this3 = haxe__Int64____Int64(((((divisor.low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
                divisor = this3
            b1 = 1
            b1 = (b1 & 63)
            if (b1 == 0):
                this4 = haxe__Int64____Int64(mask.high,mask.low)
                mask = this4
            elif (b1 < 32):
                this5 = haxe__Int64____Int64(((((((((mask.high << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(mask.low, ((32 - b1))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((mask.low << b1)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                mask = this5
            else:
                this6 = haxe__Int64____Int64(((((mask.low << ((b1 - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
                mask = this6
            if (cmp >= 0):
                break
        while True:
            b_high = 0
            b_low = 0
            if (not (((mask.high != b_high) or ((mask.low != b_low))))):
                break
            v = haxe__Int32_Int32_Impl_.ucompare(modulus.high,divisor.high)
            if (((v if ((v != 0)) else haxe__Int32_Int32_Impl_.ucompare(modulus.low,divisor.low))) >= 0):
                this1 = haxe__Int64____Int64(((((quotient.high | mask.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((quotient.low | mask.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                quotient = this1
                high = (((modulus.high - divisor.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((modulus.low - divisor.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (haxe__Int32_Int32_Impl_.ucompare(modulus.low,divisor.low) < 0):
                    ret = high
                    high = (high - 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                this2 = haxe__Int64____Int64(high,low)
                modulus = this2
            b = 1
            b = (b & 63)
            if (b == 0):
                this3 = haxe__Int64____Int64(mask.high,mask.low)
                mask = this3
            elif (b < 32):
                this4 = haxe__Int64____Int64(HxOverrides.rshift(mask.high, b),((((((((mask.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(mask.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                mask = this4
            else:
                this5 = haxe__Int64____Int64(0,HxOverrides.rshift(mask.high, ((b - 32))))
                mask = this5
            b1 = 1
            b1 = (b1 & 63)
            if (b1 == 0):
                this6 = haxe__Int64____Int64(divisor.high,divisor.low)
                divisor = this6
            elif (b1 < 32):
                this7 = haxe__Int64____Int64(HxOverrides.rshift(divisor.high, b1),((((((((divisor.high << ((32 - b1)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(divisor.low, b1))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                divisor = this7
            else:
                this8 = haxe__Int64____Int64(0,HxOverrides.rshift(divisor.high, ((b1 - 32))))
                divisor = this8
        if divSign:
            high = ((~quotient.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~quotient.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            quotient = this1
        if (dividend.high < 0):
            high = ((~modulus.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~modulus.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            modulus = this1
        return _hx_AnonObject({'quotient': quotient, 'modulus': modulus})
haxe__Int64_Int64_Impl_._hx_class = haxe__Int64_Int64_Impl_


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.high = None
        _hx_o.low = None
haxe__Int64____Int64._hx_class = haxe__Int64____Int64


class haxe_Int64Helper:
    _hx_class_name = "haxe.Int64Helper"
    __slots__ = ()
    _hx_statics = ["fromFloat"]

    @staticmethod
    def fromFloat(f):
        if (python_lib_Math.isnan(f) or (not ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))))):
            raise haxe_Exception.thrown("Number is NaN or Infinite")
        noFractions = (f - (HxOverrides.modf(f, 1)))
        if (noFractions > 9007199254740991):
            raise haxe_Exception.thrown("Conversion overflow")
        if (noFractions < -9007199254740991):
            raise haxe_Exception.thrown("Conversion underflow")
        this1 = haxe__Int64____Int64(0,0)
        result = this1
        neg = (noFractions < 0)
        rest = (-noFractions if neg else noFractions)
        i = 0
        while (rest >= 1):
            curr = HxOverrides.modf(rest, 2)
            rest = (rest / 2)
            if (curr >= 1):
                a_high = 0
                a_low = 1
                b = i
                b = (b & 63)
                b1 = None
                if (b == 0):
                    this1 = haxe__Int64____Int64(a_high,a_low)
                    b1 = this1
                elif (b < 32):
                    this2 = haxe__Int64____Int64(((((((((a_high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(a_low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a_low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
                    b1 = this2
                else:
                    this3 = haxe__Int64____Int64(((((a_low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
                    b1 = this3
                high = (((result.high + b1.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                low = (((result.low + b1.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                if (haxe__Int32_Int32_Impl_.ucompare(low,result.low) < 0):
                    ret = high
                    high = (high + 1)
                    high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                this4 = haxe__Int64____Int64(high,low)
                result = this4
            i = (i + 1)
        if neg:
            high = ((~result.high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            low = (((~result.low + 1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            if (low == 0):
                ret = high
                high = (high + 1)
                high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
            this1 = haxe__Int64____Int64(high,low)
            result = this1
        return result
haxe_Int64Helper._hx_class = haxe_Int64Helper


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def delay(self,t):
        self.nextRun = (Math.NEGATIVE_INFINITY if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "add", "sortEvents", "tick"]
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise haxe_Exception.thrown("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        return e

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack", "toHaxe"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []

    @staticmethod
    def toHaxe(native,skip = None):
        if (skip is None):
            skip = 0
        stack = []
        _g = 0
        _g1 = len(native)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (skip > i):
                continue
            elem = (native[i] if i >= 0 and i < len(native) else None)
            x = haxe_StackItem.FilePos(haxe_StackItem.Method(None,elem[2]),elem[0],elem[1])
            stack.append(x)
        return stack
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay", "measure"]

    def __init__(self,time_ms):
        self.event = None
        _gthis = self
        dt = (time_ms / 1000)
        def _hx_local_2():
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        self.event.delay(dt)

    def stop(self):
        if (self.event is not None):
            self.event.stop()
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def measure(f,pos = None):
        t0 = python_lib_Timeit.default_timer()
        r = f()
        haxe_Log.trace((Std.string((python_lib_Timeit.default_timer() - t0)) + "s"),pos)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.event = None
haxe_Timer._hx_class = haxe_Timer


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
haxe_ValueException._hx_class = haxe_ValueException


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["get", "update"]
    _hx_statics = ["make"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def get(self):
        return ((self.a2 << 16) | self.a1)

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            c = b.b[p]
            a1 = HxOverrides.mod(((a1 + c)), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    @staticmethod
    def make(b):
        a = haxe_crypto_Adler32()
        a.update(b,0,b.length)
        return a.get()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None
haxe_crypto_Adler32._hx_class = haxe_crypto_Adler32


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "sub", "getString", "toString", "toHex"]
    _hx_statics = ["alloc", "ofString", "ofData", "ofHex"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g = 0
        _g1 = self.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.b[i]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofHex(s):
        _hx_len = len(s)
        if (((_hx_len & 1)) != 0):
            raise haxe_Exception.thrown("Not a hex string (odd number of digits)")
        ret = haxe_io_Bytes.alloc((_hx_len >> 1))
        _g = 0
        _g1 = ret.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            index = (i * 2)
            high = (-1 if ((index >= len(s))) else ord(s[index]))
            index1 = ((i * 2) + 1)
            low = (-1 if ((index1 >= len(s))) else ord(s[index1]))
            high = (((high & 15)) + ((((((high & 64)) >> 6)) * 9)))
            low = (((low & 15)) + ((((((low & 64)) >> 6)) * 9)))
            ret.b[i] = (((((high << 4) | low)) & 255) & 255)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = None):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))
haxe_crypto_Base64._hx_class = haxe_crypto_Base64


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g = 0
        _g1 = self.base.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i], i)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise haxe_Exception.thrown("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
        _hx_o.tbl = None
haxe_crypto_BaseCode._hx_class = haxe_crypto_BaseCode


class haxe_crypto_Crc32:
    _hx_class_name = "haxe.crypto.Crc32"
    __slots__ = ()
    _hx_statics = ["make"]

    @staticmethod
    def make(data):
        c_crc = -1
        b = data.b
        _g = 0
        _g1 = data.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = (((c_crc ^ b[i])) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
        return (c_crc ^ -1)
haxe_crypto_Crc32._hx_class = haxe_crypto_Crc32


class haxe_crypto_Md5:
    _hx_class_name = "haxe.crypto.Md5"
    __slots__ = ()
    _hx_methods = ["bitOR", "bitXOR", "bitAND", "addme", "rol", "cmn", "ff", "gg", "hh", "ii", "doEncode"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def bitOR(self,a,b):
        lsb = ((a & 1) | ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) | (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitXOR(self,a,b):
        lsb = ((a & 1) ^ ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) ^ (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitAND(self,a,b):
        lsb = ((a & 1) & ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) & (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def addme(self,x,y):
        lsw = (((x & 65535)) + ((y & 65535)))
        msw = ((((x >> 16)) + ((y >> 16))) + ((lsw >> 16)))
        return ((msw << 16) | ((lsw & 65535)))

    def rol(self,num,cnt):
        return ((num << cnt) | (HxOverrides.rshift(num, ((32 - cnt)))))

    def cmn(self,q,a,b,x,s,t):
        return self.addme(self.rol(self.addme(self.addme(a,q),self.addme(x,t)),s),b)

    def ff(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,c),self.bitAND(~b,d)),a,b,x,s,t)

    def gg(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,d),self.bitAND(c,~d)),a,b,x,s,t)

    def hh(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(self.bitXOR(b,c),d),a,b,x,s,t)

    def ii(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(c,self.bitOR(b,~d)),a,b,x,s,t)

    def doEncode(self,x):
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        step = None
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            step = 0
            a = self.ff(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),7,-680876936)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 1)),12,-389564586)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),17,606105819)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 3)),22,-1044525330)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),7,-176418897)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 5)),12,1200080426)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),17,-1473231341)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 7)),22,-45705983)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),7,1770035416)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 9)),12,-1958414417)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),17,-42063)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 11)),22,-1990404162)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),7,1804603682)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 13)),12,-40341101)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),17,-1502002290)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 15)),22,1236535329)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),5,-165796510)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 6)),9,-1069501632)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),14,643717713)
            b = self.gg(b,c,d,a,(x[i] if i >= 0 and i < len(x) else None),20,-373897302)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),5,-701558691)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 10)),9,38016083)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),14,-660478335)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 4)),20,-405537848)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),5,568446438)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 14)),9,-1019803690)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),14,-187363961)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 8)),20,1163531501)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),5,-1444681467)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 2)),9,-51403784)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),14,1735328473)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 12)),20,-1926607734)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),4,-378558)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 8)),11,-2022574463)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),16,1839030562)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 14)),23,-35309556)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),4,-1530992060)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 4)),11,1272893353)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),16,-155497632)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 10)),23,-1094730640)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),4,681279174)
            d = self.hh(d,a,b,c,(x[i] if i >= 0 and i < len(x) else None),11,-358537222)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),16,-722521979)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 6)),23,76029189)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),4,-640364487)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 12)),11,-421815835)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),16,530742520)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 2)),23,-995338651)
            a = self.ii(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),6,-198630844)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 7)),10,1126891415)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),15,-1416354905)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 5)),21,-57434055)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),6,1700485571)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 3)),10,-1894986606)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),15,-1051523)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 1)),21,-2054922799)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),6,1873313359)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 15)),10,-30611744)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),15,-1560198380)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 13)),21,1309151649)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),6,-145523070)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 11)),10,-1120210379)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),15,718787259)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 9)),21,-343485551)
            a = self.addme(a,olda)
            b = self.addme(b,oldb)
            c = self.addme(c,oldc)
            d = self.addme(d,oldd)
            i = (i + 16)
        return [a, b, c, d]

    @staticmethod
    def make(b):
        h = haxe_crypto_Md5().doEncode(haxe_crypto_Md5.bytes2blks(b))
        out = haxe_io_Bytes.alloc(16)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        blksSize = (nblk * 16)
        _g = 0
        _g1 = blksSize
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        i = 0
        while (i < b.length):
            _hx_local_0 = blks
            _hx_local_1 = (i >> 2)
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 | ((b.b[i] << (((((((b.length << 3)) + i) & 3)) << 3))))))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            i = (i + 1)
        _hx_local_4 = blks
        _hx_local_5 = (i >> 2)
        _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 | ((128 << ((HxOverrides.mod((((b.length * 8) + i)), 4) * 8))))))
        (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        l = (b.length * 8)
        k = ((nblk * 16) - 2)
        python_internal_ArrayImpl._set(blks, k, (l & 255))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 8) & 255)) << 8))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 16) & 255)) << 16))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 24) & 255)) << 24))))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Md5._hx_class = haxe_crypto_Md5


class haxe_crypto_Sha1:
    _hx_class_name = "haxe.crypto.Sha1"
    __slots__ = ()
    _hx_methods = ["doEncode", "ft", "kt"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def doEncode(self,x):
        w = list()
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        e = -1009589776
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            j = 0
            while (j < 80):
                if (j < 16):
                    python_internal_ArrayImpl._set(w, j, python_internal_ArrayImpl._get(x, (i + j)))
                else:
                    num = (((python_internal_ArrayImpl._get(w, (j - 3)) ^ python_internal_ArrayImpl._get(w, (j - 8))) ^ python_internal_ArrayImpl._get(w, (j - 14))) ^ python_internal_ArrayImpl._get(w, (j - 16)))
                    python_internal_ArrayImpl._set(w, j, ((num << 1) | (HxOverrides.rshift(num, 31))))
                t = (((((((a << 5) | (HxOverrides.rshift(a, 27)))) + self.ft(j,b,c,d)) + e) + (w[j] if j >= 0 and j < len(w) else None)) + self.kt(j))
                e = d
                d = c
                c = ((b << 30) | (HxOverrides.rshift(b, 2)))
                b = a
                a = t
                j = (j + 1)
            a = (a + olda)
            b = (b + oldb)
            c = (c + oldc)
            d = (d + oldd)
            e = (e + olde)
            i = (i + 16)
        return [a, b, c, d, e]

    def ft(self,t,b,c,d):
        if (t < 20):
            return ((b & c) | ((~b & d)))
        if (t < 40):
            return ((b ^ c) ^ d)
        if (t < 60):
            return (((b & c) | ((b & d))) | ((c & d)))
        return ((b ^ c) ^ d)

    def kt(self,t):
        if (t < 20):
            return 1518500249
        if (t < 40):
            return 1859775393
        if (t < 60):
            return -1894007588
        return -899497514

    @staticmethod
    def make(b):
        h = haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b))
        out = haxe_io_Bytes.alloc(20)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[4] if 4 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[4] if 4 < len(h) else None) & 255) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        _g = 0
        _g1 = (nblk * 16)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        _g = 0
        _g1 = b.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (i >> 2)
            python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((b.b[i] << ((24 - ((((i & 3)) << 3))))))))
        i = b.length
        p = (i >> 2)
        python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((128 << ((24 - ((((i & 3)) << 3))))))))
        python_internal_ArrayImpl._set(blks, ((nblk * 16) - 1), (b.length * 8))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Sha1._hx_class = haxe_crypto_Sha1


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "remove", "iterator"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if HxOverrides.eq(l.item,v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    def iterator(self):
        return haxe_ds__List_ListIterator(self.h)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
haxe_ds_List._hx_class = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode


class haxe_ds__List_ListIterator:
    _hx_class_name = "haxe.ds._List.ListIterator"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        self.head = head

    def hasNext(self):
        return (self.head is not None)

    def next(self):
        val = self.head.item
        self.head = self.head.next
        return val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.head = None
haxe_ds__List_ListIterator._hx_class = haxe_ds__List_ListIterator


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"
    _hx_constructs = ["Some", "None"]

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, (v,))
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, ())
haxe_ds_Option._hx_class = haxe_ds_Option


class haxe_http_HttpBase:
    _hx_class_name = "haxe.http.HttpBase"
    _hx_fields = ["url", "responseBytes", "responseAsString", "postData", "postBytes", "headers", "params", "emptyOnData"]
    _hx_methods = ["setHeader", "setParameter", "setPostData", "onData", "onBytes", "onError", "onStatus", "hasOnData", "success", "get_responseData"]

    def __init__(self,url):
        self.emptyOnData = None
        self.postBytes = None
        self.postData = None
        self.responseAsString = None
        self.responseBytes = None
        self.url = url
        self.headers = []
        self.params = []
        self.emptyOnData = self.onData

    def setHeader(self,name,value):
        _g = 0
        _g1 = len(self.headers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.headers[i] if i >= 0 and i < len(self.headers) else None).name == name):
                python_internal_ArrayImpl._set(self.headers, i, _hx_AnonObject({'name': name, 'value': value}))
                return self
        _this = self.headers
        _this.append(_hx_AnonObject({'name': name, 'value': value}))
        return self

    def setParameter(self,name,value):
        _g = 0
        _g1 = len(self.params)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.params[i] if i >= 0 and i < len(self.params) else None).name == name):
                python_internal_ArrayImpl._set(self.params, i, _hx_AnonObject({'name': name, 'value': value}))
                return self
        _this = self.params
        _this.append(_hx_AnonObject({'name': name, 'value': value}))
        return self

    def setPostData(self,data):
        self.postData = data
        self.postBytes = None
        return self

    def onData(self,data):
        pass

    def onBytes(self,data):
        pass

    def onError(self,msg):
        pass

    def onStatus(self,status):
        pass

    def hasOnData(self):
        return (not Reflect.compareMethods(self.onData,self.emptyOnData))

    def success(self,data):
        self.responseBytes = data
        self.responseAsString = None
        if self.hasOnData():
            self.onData(self.get_responseData())
        self.onBytes(self.responseBytes)

    def get_responseData(self):
        if ((self.responseAsString is None) and ((self.responseBytes is not None))):
            self.responseAsString = self.responseBytes.getString(0,self.responseBytes.length,haxe_io_Encoding.UTF8)
        return self.responseAsString

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.url = None
        _hx_o.responseBytes = None
        _hx_o.responseAsString = None
        _hx_o.postData = None
        _hx_o.postBytes = None
        _hx_o.headers = None
        _hx_o.params = None
        _hx_o.emptyOnData = None
haxe_http_HttpBase._hx_class = haxe_http_HttpBase


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = bytearray()

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "close", "set_bigEndian", "writeFullBytes", "prepare", "writeString"]

    def writeByte(self,c):
        raise haxe_Exception.thrown("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def prepare(self,nbytes):
        pass

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Output._hx_class = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        _this.b.extend(buf.b[pos:(pos + _hx_len)])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_io_Eof._hx_class = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readAll", "readLine"]

    def readByte(self):
        raise haxe_Exception.thrown("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readAll(self,bufsize = None):
        if (bufsize is None):
            bufsize = 16384
        buf = haxe_io_Bytes.alloc(bufsize)
        total = haxe_io_BytesBuffer()
        try:
            while True:
                _hx_len = self.readBytes(buf,0,bufsize)
                if (_hx_len == 0):
                    raise haxe_Exception.thrown(haxe_io_Error.Blocked)
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
                total.b.extend(buf.b[0:_hx_len])
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return total.getBytes()

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,haxe_io_Eof):
                e = _g1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise haxe_Exception.thrown(e)
            else:
                raise _g
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Input._hx_class = haxe_io_Input


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ()
    _hx_statics = ["join", "normalize", "addTrailingSlash"]

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g = 0
        _g1 = len(tmp)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _g2 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g3 = _g2
            if (_g3 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g2
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g3 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g2
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path
haxe_io_Path._hx_class = haxe_io_Path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None
haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None
haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator


class haxe_iterators_MapKeyValueIterator:
    _hx_class_name = "haxe.iterators.MapKeyValueIterator"
    __slots__ = ("map", "keys")
    _hx_fields = ["map", "keys"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_map):
        self.map = _hx_map
        self.keys = _hx_map.keys()

    def hasNext(self):
        return self.keys.hasNext()

    def next(self):
        key = self.keys.next()
        return _hx_AnonObject({'value': self.map.get(key), 'key': key})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.keys = None
haxe_iterators_MapKeyValueIterator._hx_class = haxe_iterators_MapKeyValueIterator


class haxe_rtti_Meta:
    _hx_class_name = "haxe.rtti.Meta"
    __slots__ = ()
    _hx_statics = ["getMeta", "getFields"]

    @staticmethod
    def getMeta(t):
        return Reflect.field(t,"__meta__")

    @staticmethod
    def getFields(t):
        meta = haxe_rtti_Meta.getMeta(t)
        if ((meta is None) or ((Reflect.field(meta,"fields") is None))):
            return _hx_AnonObject({})
        else:
            return Reflect.field(meta,"fields")
haxe_rtti_Meta._hx_class = haxe_rtti_Meta

class hiss_SetType(Enum):
    __slots__ = ()
    _hx_class_name = "hiss.SetType"
    _hx_constructs = ["Global", "Local", "Destructive"]
hiss_SetType.Global = hiss_SetType("Global", 0, ())
hiss_SetType.Local = hiss_SetType("Local", 1, ())
hiss_SetType.Destructive = hiss_SetType("Destructive", 2, ())
hiss_SetType._hx_class = hiss_SetType


class hiss_CCInterp:
    _hx_class_name = "hiss.CCInterp"
    _hx_fields = ["globals", "reader", "tempTrace", "readingProgram", "maxStackDepth", "errorHandler", "debugClassImports", "currentBeginFunction", "currentEvalAllFunction", "scriptArgs"]
    _hx_methods = ["setErrorHandler", "errorCC", "error", "disableTrace", "enableTrace", "importVar", "importClass", "importFunction", "importCCFunction", "importSpecialForm", "emptyDict", "emptyEnv", "useFunctions", "repl", "load", "_load", "envWithReturn", "envWithBreakContinue", "trBegin", "begin", "specialForm", "macroCall", "funcall", "evalAll", "trEvalAll", "set", "setCallable", "defAlias", "defDestructiveAlias", "getVar", "iterable", "performIteration", "iterate", "iterateCC", "loop", "evalUnquotes", "read", "readAll", "_eval", "eval", "evalCC", "truthy", "interpolateString", "internalEval", "nativeFunctionMaxArgs", "toNativeFunction"]
    _hx_statics = ["noOp", "noCC", "emptyList", "main", "run"]

    def __init__(self,printFunction = None):
        self.reader = None
        self.globals = None
        self.scriptArgs = []
        self.currentEvalAllFunction = None
        self.currentBeginFunction = None
        self.debugClassImports = False
        self.errorHandler = None
        self.maxStackDepth = 0
        self.readingProgram = False
        self.tempTrace = None
        _gthis = self
        hiss_HissTestCase.reallyTrace = haxe_Log.trace
        self.globals = self.emptyDict()
        self.reader = hiss_HissReader(self)
        code = 0
        def _hx_local_0():
            Sys.exit(code)
        self.importFunction(Sys,_hx_local_0,_hx_AnonObject({'name': "quit!", 'argNames': []}))
        _g = self.set
        _hx_type = hiss_SetType.Global
        def _hx_local_1(args,env,cc):
            _g(_hx_type,args,env,cc)
        self.importSpecialForm(_hx_local_1,_hx_AnonObject({'name': "defvar"}))
        _g1 = self.set
        type1 = hiss_SetType.Local
        def _hx_local_2(args,env,cc):
            _g1(type1,args,env,cc)
        self.importSpecialForm(_hx_local_2,_hx_AnonObject({'name': "setlocal!"}))
        _g2 = self.set
        type2 = hiss_SetType.Destructive
        def _hx_local_3(args,env,cc):
            _g2(type2,args,env,cc)
        self.importSpecialForm(_hx_local_3,_hx_AnonObject({'name': "set!"}))
        _g3 = self.setCallable
        isMacro = False
        def _hx_local_4(args,env,cc):
            _g3(isMacro,args,env,cc)
        self.importSpecialForm(_hx_local_4,_hx_AnonObject({'name': "defun"}))
        _g4 = self.setCallable
        isMacro1 = True
        def _hx_local_5(args,env,cc):
            _g4(isMacro1,args,env,cc)
        self.importSpecialForm(_hx_local_5,_hx_AnonObject({'name': "defmacro"}))
        self.importSpecialForm(self.defAlias,_hx_AnonObject({'name': "defalias"}))
        self.importSpecialForm(self._eval,_hx_AnonObject({'name': "eval"}))
        _g5 = self.funcall
        callInline = False
        def _hx_local_6(args,env,cc):
            _g5(callInline,args,env,cc)
        self.importSpecialForm(_hx_local_6,_hx_AnonObject({'name': "funcall"}))
        _g6 = self.funcall
        callInline1 = True
        def _hx_local_7(args,env,cc):
            _g6(callInline1,args,env,cc)
        self.importSpecialForm(_hx_local_7,_hx_AnonObject({'name': "funcall-inline"}))
        self.useFunctions(self.trBegin,self.trEvalAll,self.iterate)
        _g7 = self.useFunctions
        beginFunction = self.trBegin
        evalAllFunction = self.trEvalAll
        iterateFunction = self.iterate
        def _hx_local_8():
            return _g7(beginFunction,evalAllFunction,iterateFunction)
        self.importFunction(self,_hx_local_8,_hx_AnonObject({'name': "disable-cc!"}))
        _g8 = self.useFunctions
        beginFunction1 = self.begin
        evalAllFunction1 = self.evalAll
        iterateFunction1 = self.iterateCC
        def _hx_local_9():
            return _g8(beginFunction1,evalAllFunction1,iterateFunction1)
        self.importFunction(self,_hx_local_9,_hx_AnonObject({'name': "enable-cc!"}))
        self.importCCFunction(self.errorCC,_hx_AnonObject({'name': "error!", 'argNames': ["message"]}))
        self.importFunction(self,self.repl,_hx_AnonObject({'name': "repl"}))
        self.importFunction(self,self.read,_hx_AnonObject({'name': "read", 'argNames': ["string"]}),hiss_HValue.Nil)
        self.importFunction(self,self.readAll,_hx_AnonObject({'name': "read-all", 'argNames': ["string"]}),hiss_HValue.Nil)
        self.importClass(hiss_HStream,_hx_AnonObject({'name': "HStream"}))
        self.importFunction(self.reader,self.reader.setMacroString,_hx_AnonObject({'name': "set-macro-string!", 'argNames': ["string", "read-function"]}),hiss_HValue.List([hiss_HValue.Int(1)]))
        self.importFunction(self.reader,self.reader.setDefaultReadFunction,_hx_AnonObject({'name': "set-default-read-function!", 'argNames': ["read-function"]}),hiss_HValue.T)
        self.importFunction(self.reader,self.reader.readNumber,_hx_AnonObject({'name': "read-number!", 'argNames': ["start", "stream"]}),hiss_HValue.Nil)
        self.importFunction(self.reader,self.reader.readString,_hx_AnonObject({'name': "read-string!", 'argNames': ["start", "stream"]}),hiss_HValue.Nil)
        self.importFunction(self.reader,self.reader.readSymbol,_hx_AnonObject({'name': "read-symbol!", 'argNames': ["start", "stream"]}),hiss_HValue.Nil)
        self.importFunction(self.reader,self.reader.nextToken,_hx_AnonObject({'name': "next-token!", 'argNames': ["stream"]}),hiss_HValue.Nil)
        self.importFunction(self.reader,self.reader.readDelimitedList,_hx_AnonObject({'name': "read-delimited-list!", 'argNames': ["terminator", "delimiters", "eof-terminates", "blank-elements", "start", "stream"]}),hiss_HValue.List([hiss_HValue.Int(3)]))
        self.importFunction(self.reader,self.reader.copyReadtable,_hx_AnonObject({'name': "copy-readtable"}))
        self.importFunction(self.reader,self.reader.useReadtable,_hx_AnonObject({'name': "use-readtable!"}))
        self.importFunction(self.reader,self.reader.read,_hx_AnonObject({'name': "read-next!", 'argNames': ["start", "stream"]}))
        self.defDestructiveAlias("read-number!","!")
        self.defDestructiveAlias("read-string!","!")
        self.defDestructiveAlias("read-symbol!","!")
        self.defDestructiveAlias("read-delimited-list!","!")
        self.defDestructiveAlias("read-next!","!")
        self.importClass(hiss_Stdlib,_hx_AnonObject({'name': "Stdlib", 'omitStaticPrefixes': True}))
        self.importFunction(hiss_HaxeTools,hiss_HaxeTools.shellCommand,_hx_AnonObject({'name': "shell-command!"}))
        self.defDestructiveAlias("shell-command!","!")
        if (printFunction is not None):
            self.importFunction(self,printFunction,_hx_AnonObject({'name': "print!", 'argNames': ["value"]}),hiss_HValue.Nil)
        self.importClass(hiss_VariadicFunctions,_hx_AnonObject({'name': "VariadicFunctions", 'omitStaticPrefixes': True}))
        def _hx_local_10(name):
            return ("dict-" + HxOverrides.stringOrNull(hx_strings_Strings.toLowerHyphen(name)))
        self.importClass(hiss_HDict,_hx_AnonObject({'name': "Dict", 'omitMemberPrefixes': True, 'omitStaticPrefixes': True, 'convertNames': _hx_local_10}))
        self.importClass(hiss_wrappers_HFile,_hx_AnonObject({'name': "File"}))
        def _hx_local_11():
            return hiss_HValue.List(_gthis.scriptArgs)
        self.importFunction(self,_hx_local_11,_hx_AnonObject({'name': "args"}))
        self.importClass(hiss_wrappers_HStringTools,_hx_AnonObject({'name': "StringTools", 'omitStaticPrefixes': True}))
        self.importClass(hiss_wrappers_HHttp,_hx_AnonObject({'name': "Http"}))
        self.importClass(hiss_wrappers_HHttp,_hx_AnonObject({'name': "HTTP"}))
        self.importClass(hiss_wrappers_HDate,_hx_AnonObject({'name': "Date"}))
        self.importClass(hiss_wrappers_HType,_hx_AnonObject({'name': "Type"}))
        self.importCCFunction(self._load,_hx_AnonObject({'name': "load!", 'argNames': ["file"]}))
        interp = self
        def _hx_local_12(args,env,cc):
            hiss_HissTestCase.testAtRuntime(interp,args,env,cc)
        self.importSpecialForm(_hx_local_12,_hx_AnonObject({'name': "test!"}))
        interp1 = self
        def _hx_local_13(args,env,cc):
            hiss_HissTestCase.hissPrints(interp1,args,env,cc)
        self.importCCFunction(_hx_local_13,_hx_AnonObject({'name': "prints"}))
        self.importFunction(hiss_StaticFiles,hiss_StaticFiles.getContent,_hx_AnonObject({'name': "get-content", 'argNames': ["file"]}))
        self.importClass(hiss_SpecialForms,_hx_AnonObject({'name': "SpecialForms", 'omitStaticPrefixes': True}))
        self.importSpecialForm(self.loop,_hx_AnonObject({'name': "loop"}))
        def _hx_local_14():
            return hiss_HDict(_gthis)
        self.importFunction(self,_hx_local_14,_hx_AnonObject({'name': "empty-readtable"}))
        self.importFunction(Std,Std.random,_hx_AnonObject({'name': "random"}))
        self.importFunction(Std,Std.parseInt,_hx_AnonObject({'name': "int"}))
        self.importFunction(Std,Std.parseFloat,_hx_AnonObject({'name': "float"}))
        self.importFunction(Sys,Sys.sleep,_hx_AnonObject({'name': "sleep!", 'argNames': ["seconds"]}))
        self.importFunction(Sys,Sys.getEnv,_hx_AnonObject({'name': "get-env", 'argNames': ["var"]}))
        hiss_StaticFiles._registerFileContent("Stdlib.hiss","/*\r\n    Hiss standard library functions implemented in Hiss\r\n*/\r\n\r\n(defalias add +)\r\n(defalias subtract -)\r\n(defalias divide /)\r\n(defalias multiply *)\r\n(defalias mod %)\r\n(defalias lesser <)\r\n(defalias lesser-equal <=)\r\n(defalias greater >)\r\n(defalias greater-equal >=)\r\n(defalias equal =)\r\n\r\n(defalias dict-make-dict dict)\r\n(defvar dict-make-dict nil)\r\n(defalias dict-put! dict-set!)\r\n(defalias dict-put! dict-set @deprecated)\r\n(defalias dict-exists dict-contains)\r\n\r\n(defalias call-cc call/cc)\r\n\r\n// This just allows the try/catch implementation to be DRY but still readable \r\n(defalias lambda catch)\r\n\r\n(defun first (l) (nth l 0))\r\n\r\n(defmacro register-method! (method name &optional call-on-reference keep-args-wrapped return-instance)\r\n    \"Register a method call as an unqualified global function. This function will work on any object that defines that function\"\r\n    `(defun ,name (instance &rest args)\r\n        (setlocal! result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))\r\n        (if ,return-instance instance result)))\r\n(defalias register-method! register-method @deprecated)\r\n\r\n(register-method! \"push\" push! t t t)\r\n(defalias push! push @deprecated)\r\n\r\n(register-method! \"shift\" shift! t)\r\n(defalias shift! shift @deprecated)\r\n\r\n(register-method! \"pop\" pop! t)\r\n(defalias pop! pop @deprecated)\r\n\r\n(defun take! (l num)\r\n    \"Destructively take the first num elements from l as a new list\"\r\n    (call-haxe l \"splice\" (list 0 num) t))\r\n(defalias take! take @deprecated)\r\n\r\n(defun drop! (l num)\r\n    \"Destructively remove the first num elements from l\"\r\n    (call-haxe l \"splice\" (list 0 num) t)\r\n    l)\r\n(defalias drop! drop @deprecated)\r\n\r\n(defun slice (l start &optional end)\r\n    (call-haxe l \"slice\" (list (index start l) (if end (index end l) (length l)))))\r\n(defun peek (l num)\r\n    (slice l 0 num))\r\n(defun last (l)\r\n    (nth l (- (length l) 1)))\r\n\r\n(defalias setlocal! setlocal @deprecated)\r\n(defalias set! set @deprecated)\r\n(defalias set-nth! set-nth @deprecated) \r\n\r\n(defun nil? (v) (eq nil v))\r\n\r\n// String functions:\r\n(register-method! \"split\" split)\r\n(register-method! \"substr\" substring)\r\n(defun char-at (str idx) (substring str idx 1))\r\n// Allow negative index for substring and char-at\r\n(defvar _substring substring)\r\n(defun substring (str idx &optional len)\r\n    (if (>= idx (length str))\r\n        \"\"\r\n        (_substring str (index idx str) (or len (length str)))))\r\n(defalias substring substr)\r\n\r\n(defun list (&rest args) args)\r\n(defun empty? (list-or-string) (or (nil? list-or-string) (= 0 (length list-or-string))))\r\n\r\n(defun zip (&rest lists)\r\n    \"Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists\"\r\n    (setlocal! final-length (first (sort (for l lists (length l)))))\r\n    (for i (range final-length)\r\n        (for l lists (nth l i))))\r\n\r\n(defmacro cond (&rest forms)\r\n    `(if (not ',forms)\r\n            (error! \"cond ran out of options. add a default case\")\r\n        (and ',forms (if (eval (first (first ',forms)))\r\n            (eval (cons 'begin (rest (first ',forms))))\r\n        (eval (cons 'cond (rest ',forms)))))))\r\n\r\n(defmacro when (cond &rest body)\r\n    `(if ,cond (begin ,@body)))\r\n\r\n(defmacro unless (cond &rest body)\r\n    `(when (not ,cond) ,@body))\r\n\r\n(defmacro while (cond &rest body)\r\n    `(call/cc (lambda (break)\r\n        (loop ()\r\n            (when ,cond\r\n                (call/cc (lambda (continue)\r\n                    ,@body))\r\n                (if ,cond (recur)))))))\r\n\r\n(defun groups (l size &optional take-remainder)\r\n    (setlocal! c (list-copy l))\r\n    (setlocal! g (list))\r\n    (while c\r\n        (cond\r\n            ((< (length c) size)\r\n                (when take-remainder\r\n                    (push! g (list-copy c)))\r\n                (clear! c))\r\n            (t\r\n                (push! g (take! c size)))))\r\n\tg)\r\n\r\n(defmacro let (bindings &rest body)\r\n    (setlocal! setlocal-exps \r\n        (cond\r\n            ; New-fangled, single-list let bindings like (name1 val1 name2 val2)\r\n            ((symbol? (first bindings))\r\n                (for pair (groups bindings 2) `(setlocal! ,(first pair) ,(nth pair 1))))\r\n\r\n            ; Old-school, many-list let bindings like ((name1 val1) (name2 val2))\r\n            ((list? (first bindings))\r\n                (for pair bindings `(setlocal! ,@pair)))))\r\n    `(begin\r\n        ,@setlocal-exps\r\n        ,@body))\r\n\r\n(defun apply (f args)\r\n    (eval `(,f ',@args)))\r\n\r\n(defmacro bind (f &rest bind-args)\r\n    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))\r\n        `(lambda (&rest call-args)\r\n            (setlocal! args (for arg ',bind-args (if (eq '_ arg) (shift! call-args) arg)))\r\n            (apply ,f (append args call-args)))))\r\n\r\n(defmacro rbind (f &rest bind-args)\r\n    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))\r\n        `(lambda (&rest call-args)\r\n            (setlocal! args (for arg ',bind-args (if (eq '_ arg) (pop! call-args) arg)))\r\n            (apply ,f (append call-args args)))))\r\n\r\n(defvar second (rbind nth 1))\r\n(defvar third (rbind nth 2))\r\n(defvar fourth (rbind nth 3))\r\n(defvar fifth (rbind nth 4))\r\n(defvar sixth (rbind nth 5))\r\n(defvar seventh (rbind nth 6))\r\n(defvar eighth (rbind nth 7))\r\n(defvar ninth (rbind nth 8))\r\n(defvar tenth (rbind nth 9))\r\n\r\n(defun collect (iterable)\r\n    (for elem iterable elem))\r\n\r\n(defun enumerate (l)\r\n    (zip (collect (range (length l))) l))\r\n\r\n(defun filter (l &optional pred)\r\n    (let (pred (or pred (lambda (x) x))\r\n            result (list))\r\n        (do-for elem l (when (pred elem) (push! result elem)))\r\n        result))\r\n\r\n(defun current-continuation ()\r\n    (call/cc (lambda (cc) \r\n        (cc cc))))\r\n\r\n(defmacro _case (value &rest case-list)\r\n    (if case-list\r\n        (let (case-first (first case-list)\r\n                case-rest (rest case-list))\r\n            (if case-first\r\n                `(if (or (eq ',(first case-first) 'default) (eq ,(first case-first) ,value))\r\n                    (begin ,@(rest case-first))\r\n                    (case ,value ,@case-rest))\r\n                nil))\r\n        nil))\r\n(defmacro case (form &rest case-list)\r\n    `(let (value ,form) (_case value ,@case-list)))\r\n\r\n(defun input-string! (&optional prompt)\r\n    (when prompt (message! prompt))\r\n    (read-line!))\r\n(defalias input-string! input-string @deprecated)\r\n\r\n(defun input-int! (&optional prompt)\r\n    (int (input-string prompt)))\r\n(defalias input-int! input-int @deprecated)\r\n\r\n(defun input-float! (&optional prompt)\r\n    (float (input-string prompt)))\r\n(defalias input-float! input-float @deprecated)\r\n\r\n(defun input-symbol! (&optional prompt)\r\n    (let (name \r\n                (input-string prompt))\r\n        // don't return a gensym if the input is blank\r\n        (if (empty? name) nil (symbol name))))\r\n(defalias input-symbol! input-symbol @deprecated)\r\n\r\n// Very dangerous function:\r\n(defun input-expression! (&optional prompt)\r\n    (eval (read (input-string prompt))))\r\n(defalias input-expression! input-expression @deprecated)\r\n\r\n(defun input-choice! (choices &optional prompt)\r\n    (when prompt (message! prompt))\r\n    (do-for (idx choice) (enumerate choices)\r\n        (message! \"${idx}. $(to-print choice)\"))\r\n    (nth choices (input-int \"> \")))\r\n(defalias input-choice! input-choice @deprecated)\r\n\r\n(defmacro set-default! (var value)\r\n    `(if (or (not (bound? ,var)) (nil? ,var)) (set! ,var ,value)))\r\n\r\n// (next) and (has-next) should work on Iterables AND Iterators, for convenience\r\n(defun iterator (iterable-or-iterator)\r\n    (if (get-property iterable-or-iterator \"iterator\")\r\n        (call-haxe iterable-or-iterator \"iterator\") iterator-or-iterable))\r\n\r\n(defun next! (iterable-or-iterator)\r\n    (call-haxe (iterator iterable-or-iterator) \"next\"))\r\n(defalias next! next @deprecated)\r\n\r\n(defun has-next (iterable-or-iterator)\r\n    (call-haxe (iterator iterable-or-iterator) \"hasNext\"))\r\n\r\n(if (bound? Thread)\r\n    (defmacro defgen (name args &rest body)\r\n        `(defun ,name ,args\r\n            (let (__lock__ (new Lock)\r\n                    __deque__ (new Deque)\r\n                    __thread__ nil\r\n                    __next__ nil // When has-next is called, the next value must be stored\r\n                    __done__ nil\r\n                    __done-signal__ (symbol)\r\n                    yield (lambda (value)\r\n                                (Deque:add! __deque__ value)\r\n                                (Lock:wait! __lock__))\r\n                    next (lambda ()\r\n                            (if __done__ nil\r\n                                (begin\r\n                                    (if __next__\r\n                                        (return (let (ret __next__)\r\n                                            (set! __next__ nil)\r\n                                            ret)))\r\n                                    (if (not __thread__)\r\n                                        (set! __thread__ (Thread:create!\r\n                                                                (lambda ()\r\n                                                                    ,@body\r\n                                                                    (Deque:add! __deque__ __done-signal__)))))\r\n                                    (Lock:release! __lock__)\r\n                                    (let (value (Deque:pop! __deque__ t))\r\n                                        (case value\r\n                                            (__done-signal__ (set! __done__ t) nil)\r\n                                            (default value))))))\r\n                    has-next (lambda ()\r\n                                (if __done__ nil\r\n                                    (if __next__ t\r\n                                        (let (could-be-next (next))\r\n                                            (case could-be-next\r\n                                                (nil (not __done__))\r\n                                                (default (set! __next__ could-be-next) t)))))))\r\n                (iterable next has-next)))))\r\n\r\n(defun memoize (f)\r\n    \"Return a version of the given function that caches return values for different argument lists\"\r\n    (let (prior-args (dict))\r\n        (lambda (&rest args)\r\n            (or (dict-get prior-args args)\r\n                (let (result (apply f args))\r\n                    (dict-set! prior-args args result)\r\n                    result)))))\r\n\r\n; TODO if it's neither a list nor string, throw an error\r\n; In cases where a function name could reasonably be expected to work the same on EITHER a string or a list, Hiss should support both:\r\n(defun replace (string-or-list old new)\r\n    (cond\r\n        ((list? string-or-list)\r\n            (for elem string-or-list (if (eq old elem) new elem)))\r\n        ((string? string-or-list)\r\n            (call-haxe StringTools \"replace\" (list string-or-list old new)))\r\n        (t (error! \"replace can't be called on $string-or-list\"))))\r\n\r\n(defun index-of (string-or-list part &optional start-index)\r\n    (set-default! start-index 0)\r\n    (set! start-index (index start-index string-or-list))\r\n    (cond\r\n        ((list? string-or-list)\r\n            (setlocal! found-idx -1)\r\n            (do-for (idx elem) (enumerate string-or-list)\r\n                (when (and (<= start-index idx) (eq part elem))\r\n                    (set! found-idx idx)\r\n                    (break)))\r\n            found-idx)\r\n        ((string? string-or-list)\r\n            (call-haxe string-or-list \"indexOf\" (list part start-index)))\r\n        (t (error! \"index-of can't be called on $string-or-list\"))))\r\n\r\n(defun last-index-of (string-or-list part &optional start-index)\r\n    (set-default! start-index -1)\r\n    (set! start-index (index start-index string-or-list))\r\n    (cond\r\n        ((list? string-or-list)\r\n            (do-for (idx elem) (reverse (enumerate string-or-list))\r\n                (if (and (>= start-index idx) (eq part elem))\r\n                    (return idx)))\r\n            -1)\r\n        ((string? string-or-list)\r\n            (call-haxe string-or-list \"lastIndexOf\" (list part start-index)))\r\n        (t (error! \"last-index-of can't be called on $string-or-list\"))))\r\n\r\n\r\n(defun contains (string-or-list part)\r\n    (<= 0 (index-of string-or-list part)))\r\n\r\n; It also might make sense to have recursive versions of some of these:\r\n\r\n(defun tree-replace (tree old new)\r\n    (cond\r\n        ((list? tree)\r\n            (for subtree tree (tree-replace subtree old new)))\r\n        (t (if (eq tree old) new tree))))\r\n\r\n(defun tree-contains (tree elem)\r\n    (cond\r\n        ((list? tree)\r\n            (setlocal! found nil)\r\n            (do-for subtree tree\r\n                (when (tree-contains subtree elem)\r\n                    (set! found t)\r\n                    (break)))\r\n            found)\r\n        (t (eq tree elem))))\r\n\r\n(defvar *types* (dict))\r\n\r\n(defmacro deftype (name &rest predicates)\r\n    (let (predicate-values\r\n                (for predicate predicates (eval predicate))\r\n            combined-predicate\r\n                (lambda (val)\r\n                    (set! ret t)\r\n                    (do-for predicate predicate-values\r\n                        (when (not (predicate val))\r\n                            (set! ret nil)\r\n                            (break)))\r\n                    ret)\r\n            predicate-name (symbol \"$(symbol-name name)?\"))\r\n        `(begin\r\n            (dict-set! *types* ',name ,combined-predicate)\r\n            (set-default! ,predicate-name ,combined-predicate)  ; If a predicate with the given name is already defined, it will be kept as the global predicate\r\n            t)))\r\n\r\n(defmacro the (type var)\r\n    \"Throw an error if the given variable is not the given type, else return the variable\"\r\n    `(let (value ,var)\r\n        (if (funcall (dict-get *types* ',type) value)\r\n                value\r\n            (error! (+ \"$value is not expected type \" ',type)))))\r\n\r\n(defun bool? (v)\r\n    (case v\r\n        (t t)\r\n        (nil t)\r\n        (default nil)))\r\n\r\n(deftype bool bool?)\r\n(deftype int int?)\r\n(deftype float float?)\r\n(deftype number number?)\r\n(deftype symbol symbol?)\r\n(deftype string string?)\r\n(deftype list list?)\r\n(deftype pair list? (lambda (l) (= 2 (length l))))\r\n(deftype dict dict?)\r\n(deftype function function?)\r\n(deftype macro macro?)\r\n(deftype callable callable?)\r\n(deftype object object?)\r\n(deftype any (lambda (v) t))\r\n\r\n(defmacro defstruct (name &rest fields)\r\n    (let (make-function-name\r\n                (symbol \"make-$name\")\r\n            type-predicate-name\r\n                (symbol \"${name}?\")\r\n            field-names-and-types\r\n                (for field fields\r\n                    (cond\r\n                        ((pair? field) field)\r\n                        ((symbol? field) (list field 'any))\r\n                        (t (error! \"struct fields must either be a symbol (for any type) or a pair (for a specific type)\"))))\r\n            field-indices\r\n                (collect (range 1 (+ 1 (length fields))))\r\n            field-info\r\n                (zip field-indices field-names-and-types)\r\n            field-getters\r\n                (for (index (field-name _)) field-info\r\n                    `(defun ,(symbol \"${name}-${field-name}\") (instance) (nth instance ,index)))\r\n            all-fields-typecheck\r\n                (for (index (field-name field-type)) field-info\r\n                    `(the ,field-type (nth instance ,index)))\r\n            field-setters\r\n                (for (index (field-name field-type)) field-info\r\n                    `(defun ,(symbol \"${name}-set-${field-name}!\") (instance value) (set-nth! instance ,index (the ,field-type value)))))\r\n\r\n    `(begin\r\n        (defun ,make-function-name (&rest make-args) (the ,name (cons ',name make-args)))\r\n        (defun ,type-predicate-name (instance)\r\n            (and (eq ',name (first instance))\r\n                (not (error? (begin ,@all-fields-typecheck)))))\r\n\r\n        ,@field-getters\r\n        ,@field-setters\r\n        (deftype ,name ,type-predicate-name))))\r\n\r\n// TODO these redefinitions won't take on the docstrings -- a function/macro for wrapping functions and keeping meta\r\n// would be better\r\n// redefine take-until to return a list instead of an object\r\n(defvar _take-until! HStream:take-until!)\r\n// TODO it's weird that in order to make true the default for an imported function, we need to invert the calling convention like so:\r\n(defun HStream:take-until! (stream terminators &optional no-eof-terminates no-escaped-terminators no-drop-terminator)\r\n    (let (output-object (_take-until! stream terminators (not no-eof-terminates) (not no-escaped-terminators) (not no-drop-terminator)))\r\n        (list (get-property output-object \"output\") (get-property output-object \"terminator\"))))\r\n(defalias HStream:take-until! HStream:take-until @deprecated)\r\n// redefine peek and take to return empty string if the stream is empty\r\n(defvar _peek HStream:peek)\r\n(defun HStream:peek (stream count) (try (_peek stream count) \"\"))\r\n(defvar _take! HStream:take!)\r\n(defun HStream:take! (stream count) (try (_take! stream count) \"\"))\r\n(defalias HStream:take! HStream:take @deprecated)\r\n\r\n(defmacro def-reader-macro (str arg-names &rest body)\r\n    `(set-macro-string! ,str (lambda (,(first arg-names) ,(second arg-names)) ,@body)))\r\n\r\n(def-reader-macro \"[\" (start stream) (cons 'list (read-delimited-list! \"]\" '() nil null start stream)))\r\n\r\n(def-reader-macro \"!\" (start stream) (list 'not (read-next! \"\" stream)))\r\n\r\n(defmacro if-let ((name expression) then &optional else)\r\n    `(let (,name ,expression)\r\n        (if ,name ,then ,else)))\r\n\r\n(defmacro when-let ((name expression) &rest body)\r\n    `(if-let (,name ,expression)\r\n        (begin ,@body)))\r\n\r\n(defalias sleep! sleep @deprecated)\r\n(defalias error! error @deprecated)\r\n(when (bound? quit!) (defalias quit! quit))\r\n\r\n(defalias use-readtable! use-readtable @deprecated)\r\n(defalias set-macro-string! set-macro-string @deprecated)\r\n(defalias set-default-read-function! set-default-read-function @deprecated)\r\n(defalias next-token! next-token @deprecated)\r\n\r\n(defalias print! print @deprecated)\r\n(defalias message! message @deprecated)\r\n(defalias load! load @deprecated)\r\n\r\n(defalias enable-cc! enable-continuations @deprecated)\r\n(defalias enable-cc! disable-tail-recursion @deprecated)\r\n(defalias disable-cc! disable-continuations @deprecated)\r\n(defalias disable-cc! enable-tail-recursion @deprecated)\r\n\r\n(defalias dict-set! dict-set @deprecated)\r\n(defalias dict-erase! dict-erase @deprecated)\r\n(defalias delay! delay @deprecated)\r\n(defalias set-default! default! @deprecated)\r\n(defalias set-default! default @deprecated)\r\n\r\n(defalias clear! clear @deprecated)\r\n(defalias test! test @deprecated)")
        self.load("Stdlib.hiss")

    def setErrorHandler(self,handler):
        self.errorHandler = handler

    def errorCC(self,args,env,cc):
        message = hiss_HissTools.value(hiss_HissTools.first(args),self)
        if (self.errorHandler is not None):
            self.errorHandler(message)
        else:
            raise haxe_Exception.thrown(message)

    def error(self,message):
        if (self.errorHandler is not None):
            self.errorHandler(message)
        else:
            raise haxe_Exception.thrown(message)

    def disableTrace(self):
        if (self.tempTrace is None):
            haxe_Log.trace("Disabling trace",_hx_AnonObject({'fileName': "hiss/CCInterp.hx", 'lineNumber': 97, 'className': "hiss.CCInterp", 'methodName': "disableTrace"}))
            self.tempTrace = haxe_Log.trace
            def _hx_local_0(_hx_str,posInfo = None):
                pass
            haxe_Log.trace = _hx_local_0

    def enableTrace(self):
        if (self.tempTrace is not None):
            haxe_Log.trace("Enabling trace",_hx_AnonObject({'fileName': "hiss/CCInterp.hx", 'lineNumber': 105, 'className': "hiss.CCInterp", 'methodName': "enableTrace"}))
            haxe_Log.trace = self.tempTrace

    def importVar(self,value,name):
        hiss_HissTools.put(self.globals,name,hiss_HissTools.toHValue(value))

    def importClass(self,clazz,meta):
        _gthis = self
        if self.debugClassImports:
            haxe_Log.trace(("Import " + HxOverrides.stringOrNull(meta.name)),_hx_AnonObject({'fileName': "hiss/CCInterp.hx", 'lineNumber': 139, 'className': "hiss.CCInterp", 'methodName': "importClass"}))
        hiss_HissTools.put(self.globals,meta.name,hiss_HValue.Object("Class",clazz))
        hiss_ClassMetaTools.addDefaultFields(meta)
        def _hx_local_0(field):
            return (not (((field.startswith("_") or field.endswith("_doc")) or field.endswith("_args"))))
        shouldImport = _hx_local_0
        def _hx_local_3(field,isStatic,isPredicate,destructive,meta):
            translatedName = field
            startIndex = None
            if (((field.find("_") if ((startIndex is None)) else HxString.indexOfImpl(field,"_",startIndex))) != -1):
                startIndex = None
                translatedName = HxString.substr(translatedName,0,(translatedName.find("_") if ((startIndex is None)) else HxString.indexOfImpl(translatedName,"_",startIndex)))
            if isPredicate:
                translatedName = HxString.substr(translatedName,2,None)
            translatedName = meta.convertNames(translatedName)
            if isPredicate:
                translatedName = (("null" if translatedName is None else translatedName) + HxOverrides.stringOrNull(meta.predicateSuffix))
            if destructive:
                translatedName = (("null" if translatedName is None else translatedName) + HxOverrides.stringOrNull(meta.sideEffectSuffix))
            if ((not isStatic) and (not meta.omitMemberPrefixes)):
                translatedName = ((HxOverrides.stringOrNull(meta.name) + ":") + ("null" if translatedName is None else translatedName))
            if (isStatic and (not meta.omitStaticPrefixes)):
                translatedName = ((HxOverrides.stringOrNull(meta.name) + ":") + ("null" if translatedName is None else translatedName))
            return translatedName
        translateName = _hx_local_3
        fieldsToImport = haxe_ds_StringMap()
        _g = 0
        _g1 = list(filter(shouldImport,python_Boot.getInstanceFields(clazz)))
        while (_g < len(_g1)):
            instanceField = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            fieldsToImport.h[instanceField] = False
        _g = 0
        _g1 = list(filter(shouldImport,python_Boot.getClassFields(clazz)))
        while (_g < len(_g1)):
            classField = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            fieldsToImport.h[classField] = True
        dummyInstance = Type.createEmptyInstance(clazz)
        _g = haxe_iterators_MapKeyValueIterator(fieldsToImport)
        while _g.hasNext():
            _g1 = _g.next()
            field = [_g1.key]
            isStatic = [_g1.value]
            fieldValue = [Reflect.getProperty((clazz if ((isStatic[0] if 0 < len(isStatic) else None)) else dummyInstance),(field[0] if 0 < len(field) else None))]
            if (Type.typeof((fieldValue[0] if 0 < len(fieldValue) else None)).index == 5):
                nameWithoutSignature = (field[0] if 0 < len(field) else None)
                metaSignature = ""
                startIndex = None
                if ((((field[0] if 0 < len(field) else None).find("_") if ((startIndex is None)) else HxString.indexOfImpl((field[0] if 0 < len(field) else None),"_",startIndex))) != -1):
                    parts = (field[0] if 0 < len(field) else None).split("_")
                    nameWithoutSignature = (parts[0] if 0 < len(parts) else None)
                    metaSignature = (parts[1] if 1 < len(parts) else None)
                startIndex1 = None
                bindInterpreter = [(((metaSignature.find("i") if ((startIndex1 is None)) else HxString.indexOfImpl(metaSignature,"i",startIndex1))) != -1)]
                startIndex2 = None
                wrapArgs = [(hiss_HValue.T if ((((metaSignature.find("h") if ((startIndex2 is None)) else HxString.indexOfImpl(metaSignature,"h",startIndex2))) != -1)) else hiss_HValue.Nil)]
                startIndex3 = None
                destructive = (((metaSignature.find("d") if ((startIndex3 is None)) else HxString.indexOfImpl(metaSignature,"d",startIndex3))) != -1)
                _this = hx_strings_Strings.toLowerHyphen((field[0] if 0 < len(field) else None))
                isPredicate = (python_internal_ArrayImpl._get(_this.split("-"), 0) == "is")
                startIndex4 = None
                specialForm = (((metaSignature.find("s") if ((startIndex4 is None)) else HxString.indexOfImpl(metaSignature,"s",startIndex4))) != -1)
                ccFunction = None
                if (not specialForm):
                    startIndex5 = None
                    ccFunction = (((metaSignature.find("cc") if ((startIndex5 is None)) else HxString.indexOfImpl(metaSignature,"cc",startIndex5))) != -1)
                else:
                    ccFunction = False
                startIndex6 = None
                isAsync = (((metaSignature.find("a") if ((startIndex6 is None)) else HxString.indexOfImpl(metaSignature,"a",startIndex6))) != -1)
                if ((not ccFunction) and isAsync):
                    raise haxe_Exception.thrown((((("" + HxOverrides.stringOrNull((field[0] if 0 < len(field) else None))) + " in ") + HxOverrides.stringOrNull(meta.name)) + " must be a ccfunction to be declared async"))
                if (((specialForm or ccFunction)) and (not (isStatic[0] if 0 < len(isStatic) else None))):
                    raise haxe_Exception.thrown((((("" + HxOverrides.stringOrNull((field[0] if 0 < len(field) else None))) + " in ") + HxOverrides.stringOrNull(meta.name)) + " must be static to be a special form or ccfunction"))
                translatedName = translateName((field[0] if 0 < len(field) else None),(isStatic[0] if 0 < len(isStatic) else None),isPredicate,destructive,meta)
                if self.debugClassImports:
                    haxe_Log.trace(translatedName,_hx_AnonObject({'fileName': "hiss/CCInterp.hx", 'lineNumber': 216, 'className': "hiss.CCInterp", 'methodName': "importClass"}))
                functionMeta = _hx_AnonObject({'name': translatedName})
                if python_Boot.hasField(clazz,(("" + ("null" if nameWithoutSignature is None else nameWithoutSignature)) + "_doc")):
                    Reflect.setField(functionMeta,"docstring",Reflect.getProperty(clazz,(("" + ("null" if nameWithoutSignature is None else nameWithoutSignature)) + "_doc")))
                if python_Boot.hasField(clazz,(("" + ("null" if nameWithoutSignature is None else nameWithoutSignature)) + "_args")):
                    Reflect.setField(functionMeta,"argNames",Reflect.getProperty(clazz,(("" + ("null" if nameWithoutSignature is None else nameWithoutSignature)) + "_args")))
                if ccFunction:
                    def _hx_local_7(fieldValue):
                        def _hx_local_6(args,env,cc):
                            (fieldValue[0] if 0 < len(fieldValue) else None)(_gthis,args,env,cc)
                        return _hx_local_6
                    self.importCCFunction(_hx_local_7(fieldValue),functionMeta)
                elif specialForm:
                    def _hx_local_9(fieldValue):
                        def _hx_local_8(args,env,cc):
                            (fieldValue[0] if 0 < len(fieldValue) else None)(_gthis,args,env,cc)
                        return _hx_local_8
                    self.importSpecialForm(_hx_local_9(fieldValue),functionMeta)
                else:
                    def _hx_local_11(wrapArgs,bindInterpreter,isStatic,field):
                        def _hx_local_10(args,env,cc):
                            callObject = clazz
                            if (not (isStatic[0] if 0 < len(isStatic) else None)):
                                callObject = hiss_HissTools.value(hiss_HissTools.first(args),_gthis)
                                args = hiss_Stdlib.rest_h(args)
                            argArray = hiss_HissTools.unwrapList(args,_gthis,(wrapArgs[0] if 0 < len(wrapArgs) else None))
                            if (bindInterpreter[0] if 0 < len(bindInterpreter) else None):
                                argArray.insert(0, _gthis)
                            funcPointer = Reflect.getProperty(callObject,(field[0] if 0 < len(field) else None))
                            returnValue = hiss_HaxeTools.callMethod(callObject,funcPointer,argArray,_gthis.error)
                            cc(hiss_HissTools.toHValue(returnValue))
                        return _hx_local_10
                    hiss_HissTools.put(self.globals,translatedName,hiss_HValue.Function(_hx_local_11(wrapArgs,bindInterpreter,isStatic,field),functionMeta))
                if destructive:
                    self.defDestructiveAlias(translatedName,Reflect.field(meta,"sideEffectSuffix"))
            else:
                getterTranslatedName = Reflect.field(meta,"convertNames")((field[0] if 0 < len(field) else None))
                getterTranslatedName = (HxOverrides.stringOrNull(Reflect.field(meta,"getterPrefix")) + ("null" if getterTranslatedName is None else getterTranslatedName))
                if (not Reflect.field(meta,"omitMemberPrefixes")):
                    getterTranslatedName = ((HxOverrides.stringOrNull(meta.name) + ":") + ("null" if getterTranslatedName is None else getterTranslatedName))
                if self.debugClassImports:
                    haxe_Log.trace(getterTranslatedName,_hx_AnonObject({'fileName': "hiss/CCInterp.hx", 'lineNumber': 271, 'className': "hiss.CCInterp", 'methodName': "importClass"}))
                def _hx_local_13(isStatic,field):
                    def _hx_local_12(args,env,cc):
                        callObject = clazz
                        if (not (isStatic[0] if 0 < len(isStatic) else None)):
                            callObject = hiss_HissTools.value(hiss_HissTools.first(args),_gthis)
                        value = Reflect.getProperty(callObject,(field[0] if 0 < len(field) else None))
                        cc(hiss_HissTools.toHValue(value))
                    return _hx_local_12
                hiss_HissTools.put(self.globals,getterTranslatedName,hiss_HValue.Function(_hx_local_13(isStatic,field),_hx_AnonObject({'name': getterTranslatedName})))
                setterTranslatedName = Reflect.field(meta,"convertNames")((field[0] if 0 < len(field) else None))
                setterTranslatedName = ((HxOverrides.stringOrNull(Reflect.field(meta,"setterPrefix")) + ("null" if setterTranslatedName is None else setterTranslatedName)) + HxOverrides.stringOrNull(Reflect.field(meta,"sideEffectSuffix")))
                if (not Reflect.field(meta,"omitMemberPrefixes")):
                    setterTranslatedName = ((HxOverrides.stringOrNull(meta.name) + ":") + ("null" if setterTranslatedName is None else setterTranslatedName))
                if self.debugClassImports:
                    haxe_Log.trace(setterTranslatedName,_hx_AnonObject({'fileName': "hiss/CCInterp.hx", 'lineNumber': 288, 'className': "hiss.CCInterp", 'methodName': "importClass"}))
                def _hx_local_15(isStatic,field):
                    def _hx_local_14(args,env,cc):
                        callObject = clazz
                        if (not (isStatic[0] if 0 < len(isStatic) else None)):
                            callObject = hiss_HissTools.value(hiss_HissTools.first(args),_gthis)
                            args = hiss_Stdlib.rest_h(args)
                        value = hiss_HissTools.value(hiss_HissTools.first(args),_gthis)
                        Reflect.setProperty(callObject,(field[0] if 0 < len(field) else None),value)
                        cc(hiss_HissTools.second(args))
                    return _hx_local_14
                hiss_HissTools.put(self.globals,setterTranslatedName,hiss_HValue.Function(_hx_local_15(isStatic,field),_hx_AnonObject({'name': setterTranslatedName})))
                self.defDestructiveAlias(setterTranslatedName,Reflect.field(meta,"sideEffectSuffix"))

    def importFunction(self,instance,func,meta,keepArgsWrapped = None):
        if (keepArgsWrapped is None):
            keepArgsWrapped = hiss_HValue.Nil
        _gthis = self
        def _hx_local_0(args,env,cc):
            cc(hiss_HissTools.toHValue(hiss_HaxeTools.callMethod(instance,func,hiss_HissTools.unwrapList(args,_gthis,keepArgsWrapped),_gthis.error)))
        tmp = hiss_HValue.Function(_hx_local_0,meta)
        hiss_HissTools.put(self.globals,meta.name,tmp)

    def importCCFunction(self,func,meta):
        hiss_HissTools.put(self.globals,meta.name,hiss_HValue.Function(func,meta))

    def importSpecialForm(self,func,meta):
        hiss_HissTools.put(self.globals,meta.name,hiss_HValue.SpecialForm(func,meta))

    def emptyDict(self):
        return hiss_HValue.Dict(hiss_HDict(self))

    def emptyEnv(self):
        return hiss_HValue.List([self.emptyDict()])

    def useFunctions(self,beginFunction,evalAllFunction,iterateFunction):
        self.currentBeginFunction = beginFunction
        self.currentEvalAllFunction = evalAllFunction
        hiss_HissTools.put(self.globals,"begin",hiss_HValue.SpecialForm(beginFunction,_hx_AnonObject({'name': "begin"})))
        _g = iterateFunction
        collect = True
        bodyForm = True
        def _hx_local_0(args,env,cc):
            _g(collect,bodyForm,args,env,cc)
        self.importSpecialForm(_hx_local_0,_hx_AnonObject({'name': "for"}))
        _g1 = iterateFunction
        collect1 = False
        bodyForm1 = True
        def _hx_local_1(args,env,cc):
            _g1(collect1,bodyForm1,args,env,cc)
        self.importSpecialForm(_hx_local_1,_hx_AnonObject({'name': "do-for"}))
        _g2 = iterateFunction
        collect2 = True
        bodyForm2 = False
        def _hx_local_2(args,env,cc):
            _g2(collect2,bodyForm2,args,env,cc)
        self.importSpecialForm(_hx_local_2,_hx_AnonObject({'name': "map"}))
        _g3 = iterateFunction
        collect3 = False
        bodyForm3 = False
        def _hx_local_3(args,env,cc):
            _g3(collect3,bodyForm3,args,env,cc)
        self.importSpecialForm(_hx_local_3,_hx_AnonObject({'name': "do-map"}))
        return hiss_HValue.Nil

    def repl(self,useConsoleReader = None):
        if (useConsoleReader is None):
            useConsoleReader = True
        hiss_StaticFiles._registerFileContent("ReplLib.hiss","// reader macro for inserting previous expressions\r\n(def-reader-macro \"{\" (start stream)\r\n    (let (placeholder \r\n                    start \r\n            expression\r\n                (case (HStream:peek stream 1)\r\n                    //{} inserts the last expression\r\n                    (\"}\" \r\n                        (set! placeholder (+ placeholder (HStream:take! stream 1)))\r\n                        (nth (history) -2))\r\n                    //{?} asks which previous expression to insert\r\n                    (\"?\"\r\n                        (set! placeholder (+ placeholder (HStream:take! stream 2)))\r\n                        (input-choice (history) \"Recent expressions:\"))\r\n                    //{[n]} inserts the nth expression\r\n                    (default\r\n                        (let (take-pair (HStream:take-until! stream (list \"}\")))\r\n                            (set! placeholder (apply + (cons placeholder take-pair)))\r\n                            (nth (history) (int (first take-pair)))))))\r\n        (rewrite-history\r\n            (+ \r\n                (substring (last (history)) 0 (index-of (last (history)) placeholder))\r\n                expression \r\n                (substring (last (history)) (+ (index-of (last (history)) placeholder) (length placeholder)))))\r\n        (message! \"Input expanded to $(last (history))\")\r\n        (read expression)))")
        self.load("ReplLib.hiss")
        history = []
        def _hx_local_0():
            return history
        self.importFunction(self,_hx_local_0,_hx_AnonObject({'name': "history"}))
        def _hx_local_3(_hx_str):
            def _hx_local_2():
                def _hx_local_1():
                    python_internal_ArrayImpl._set(history, (len(history) - 1), _hx_str)
                    return python_internal_ArrayImpl._get(history, (len(history) - 1))
                return _hx_local_1()
            return _hx_local_2()
        self.importFunction(self,_hx_local_3,_hx_AnonObject({'name': "rewrite-history"}))
        historyFile = haxe_io_Path.join([hiss_Stdlib.homeDir(), ".hisstory"])
        try:
            _this = sys_io_File.getContent(historyFile)
            history = _this.split("\n")
        except BaseException as _g:
            None
            history = []
        cReader = None
        if useConsoleReader:
            cReader = ihx_ConsoleReader(-1,historyFile)
        def _hx_local_4():
            if useConsoleReader:
                cReader.saveHistory()
            raise haxe_Exception.thrown(hiss_HSignal.Quit)
        replQuit = _hx_local_4
        self.importFunction(self,replQuit,_hx_AnonObject({'name': "quit!"}))
        self.importFunction(self,replQuit,_hx_AnonObject({'name': "quit"}))
        locals = self.emptyEnv()
        exp = None
        def _hx_local_5(err):
            hiss_HaxeTools.println((((((("Error type " + Std.string(Type.typeof(err))) + ": ") + ("null" if err is None else err)) + " from `") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(exp))) + "`"))
            hiss_HaxeTools.println(("Callstack depth " + Std.string(len(haxe__CallStack_CallStack_Impl_.callStack()))))
        self.setErrorHandler(_hx_local_5)
        hiss_HaxeTools.println(("Hiss version " + "[unknown branch]-[unknown revision#][unknown if modified] (target: python)"))
        hiss_HaxeTools.println("Type (help) for a list of functions, or (quit) to quit the REPL")
        while True:
            hiss_HaxeTools.print(">>> ")
            next = ""
            if useConsoleReader:
                cReader.cmd.prompt = ">>> "
                next = cReader.readLine()
            else:
                next = Sys.stdin().readLine()
            history.append(next)
            try:
                exp = self.read(next)
            except BaseException as _g:
                None
                err = haxe_Exception.caught(_g).unwrap()
                hiss_HaxeTools.println(("Reader error: " + Std.string(err)))
                continue
            try:
                self.internalEval(exp,locals,hiss_Stdlib.print_hd)
            except BaseException as _g1:
                None
                _g2 = haxe_Exception.caught(_g1).unwrap()
                if Std.isOfType(_g2,hiss_HSignal):
                    return
                elif Std.isOfType(_g2,str):
                    s = _g2
                    hiss_HaxeTools.println((((("Error \"" + ("null" if s is None else s)) + "\" from `") + HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(exp))) + "`"))
                    hiss_HaxeTools.println(("Callstack depth " + Std.string(len(haxe__CallStack_CallStack_Impl_.callStack()))))
                else:
                    err1 = _g2
                    hiss_HaxeTools.println((((((("Error type " + Std.string(Type.typeof(err1))) + ": ") + Std.string(err1)) + " from `") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(exp))) + "`"))
                    hiss_HaxeTools.println(("Callstack depth " + Std.string(len(haxe__CallStack_CallStack_Impl_.callStack()))))

    def load(self,file):
        self._load(hiss_HValue.List([hiss_HValue.String(file)]),self.emptyEnv(),hiss_CCInterp.noCC)

    def _load(self,args,env,cc):
        self.readingProgram = True
        exps = self.reader.readAll(hiss_HValue.String(hiss_StaticFiles.getContent(hiss_HissTools.value(hiss_HissTools.first(args),self))))
        self.readingProgram = False
        self.currentBeginFunction(exps,env,cc)

    def envWithReturn(self,env,called):
        stackFrameWithReturn = self.emptyDict()
        def _hx_local_0(args,env,cc):
            called.b = True
            cc(hiss_HissTools.first(args))
        hiss_HissTools.put(stackFrameWithReturn,"return",hiss_HValue.Function(_hx_local_0,_hx_AnonObject({'name': "return"})))
        return hiss_HissTools.extend(env,stackFrameWithReturn)

    def envWithBreakContinue(self,env,breakCalled,continueCalled):
        stackFrameWithBreakContinue = self.emptyDict()
        def _hx_local_0(_,_1,continueCC):
            continueCalled.b = True
            continueCC(hiss_HValue.Nil)
        hiss_HissTools.put(stackFrameWithBreakContinue,"continue",hiss_HValue.Function(_hx_local_0,_hx_AnonObject({'name': "continue"})))
        def _hx_local_1(_,_1,breakCC):
            breakCalled.b = True
            breakCC(hiss_HValue.Nil)
        hiss_HissTools.put(stackFrameWithBreakContinue,"break",hiss_HValue.Function(_hx_local_1,_hx_AnonObject({'name': "break"})))
        return hiss_HissTools.extend(env,stackFrameWithBreakContinue)

    def trBegin(self,exps,env,cc):
        returnCalled = hiss_RefBool()
        env = self.envWithReturn(env,returnCalled)
        value = self.eval(hiss_HissTools.first(exps),env)
        if (value is None):
            raise haxe_Exception.thrown((("Expression " + Std.string(hiss_HissTools.first(exps))) + " returned null to trBegin. You must have called an async function without calling enable-cc!"))
        if (returnCalled.b or (not self.truthy(hiss_Stdlib.rest_h(exps)))):
            cc(value)
        else:
            self.trBegin(hiss_Stdlib.rest_h(exps),env,cc)

    def begin(self,exps,env,cc):
        _gthis = self
        returnCalled = hiss_RefBool()
        env = self.envWithReturn(env,returnCalled)
        def _hx_local_0(result):
            if (returnCalled.b or (not _gthis.truthy(hiss_Stdlib.rest_h(exps)))):
                cc(result)
            else:
                _gthis.begin(hiss_Stdlib.rest_h(exps),env,cc)
        self.internalEval(hiss_HissTools.first(exps),env,_hx_local_0)

    def specialForm(self,args,env,cc):
        _g = hiss_HissTools.first(args)
        tmp = _g.index
        if (tmp == 11):
            meta = _g.params[1]
            func = _g.params[0]
            if Reflect.field(meta,"deprecated"):
                hiss_Stdlib.message_hd(hiss_HValue.String((("Warning! Macro " + HxOverrides.stringOrNull(meta.name)) + " is deprecated.")))
            func(hiss_Stdlib.rest_h(args),env,cc)
        elif (tmp == 12):
            meta = _g.params[1]
            func = _g.params[0]
            if Reflect.field(meta,"deprecated"):
                hiss_Stdlib.message_hd(hiss_HValue.String((("Warning! Macro " + HxOverrides.stringOrNull(meta.name)) + " is deprecated.")))
            func(hiss_Stdlib.rest_h(args),env,cc)
        else:
            raise haxe_Exception.thrown((("" + Std.string(hiss_HissTools.first(args))) + " is not a macro or special form"))

    def macroCall(self,args,env,cc):
        _gthis = self
        def _hx_local_0(expansion):
            _gthis.internalEval(expansion,env,cc)
        self.specialForm(args,env,_hx_local_0)

    def funcall(self,callInline,args,env,cc):
        _gthis = self
        def _hx_local_0(values):
            _g = hiss_HissTools.first(values)
            if (_g.index == 10):
                meta = _g.params[1]
                func = _g.params[0]
                if Reflect.field(meta,"deprecated"):
                    hiss_Stdlib.message_hd(hiss_HValue.String((("Warning! Function " + HxOverrides.stringOrNull(meta.name)) + " is deprecated.")))
                func(hiss_Stdlib.rest_h(values),(env if callInline else _gthis.emptyEnv()),cc)
            else:
                raise haxe_Exception.thrown(("Cannot funcall " + Std.string(hiss_HissTools.first(values))))
        self.currentEvalAllFunction(args,env,_hx_local_0)

    def evalAll(self,args,env,cc):
        _gthis = self
        if (not self.truthy(args)):
            cc(hiss_HValue.Nil)
        else:
            def _hx_local_1(value):
                def _hx_local_0(value2):
                    cc(hiss_Stdlib.cons_h(value,value2))
                _gthis.evalAll(hiss_Stdlib.rest_h(args),env,_hx_local_0)
            self.internalEval(hiss_HissTools.first(args),env,_hx_local_1)

    def trEvalAll(self,args,env,cc):
        if (not self.truthy(args)):
            cc(hiss_HValue.Nil)
        else:
            result = []
            _g = 0
            _g1 = hiss_HissTools.toList(args)
            while (_g < len(_g1)):
                arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                val = self.eval(arg,env)
                if (val is None):
                    raise haxe_Exception.thrown((("Expression " + Std.string(arg)) + " returned null to trEvalAll. You must have called an async function without calling enable-cc!"))
                result.append(val)
            cc(hiss_HValue.List(result))

    def set(self,_hx_type,args,env,cc):
        _gthis = self
        def _hx_local_1(val):
            scope = None
            tmp = _hx_type.index
            if (tmp == 0):
                scope = _gthis.globals
            elif (tmp == 1):
                scope = hiss_HissTools.first(env)
            elif (tmp == 2):
                _g = 0
                _g1 = hiss_HissTools.toList(env)
                while (_g < len(_g1)):
                    frame = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    frameDict = hiss_HissTools.toDict(frame)
                    if frameDict.exists_h(hiss_HissTools.first(args)):
                        scope = frame
                        break
                if (scope is None):
                    scope = _gthis.globals
            else:
                pass
            hiss_HissTools.put(scope,hiss_Stdlib.symbolName_h(hiss_HissTools.first(args)),val)
            cc(val)
        self.internalEval(hiss_HissTools.second(args),env,_hx_local_1)

    def setCallable(self,isMacro,args,env,cc):
        _gthis = self
        def _hx_local_0(fun):
            _gthis.set(hiss_SetType.Global,hiss_Stdlib.cons_h(hiss_HissTools.first(args),hiss_HValue.List([fun])),env,cc)
        hiss_SpecialForms.lambda_s(self,hiss_Stdlib.rest_h(args),env,_hx_local_0,hiss_Stdlib.symbolName_h(hiss_HissTools.first(args)),isMacro)

    def defAlias(self,args,env,cc):
        _gthis = self
        func = hiss_HissTools.first(args)
        alias = hiss_HissTools.second(args)
        _g = []
        _g1 = 0
        _g2 = hiss_HissTools.toList(args)[2:None]
        while (_g1 < len(_g2)):
            symbol = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = hiss_Stdlib.symbolName_h(symbol)
            _g.append(x)
        metaSymbols = _g
        def _hx_local_1(funcVal):
            hFunc = hiss_HissTools.toCallable(funcVal)
            meta = Reflect.copy(hiss_HissTools.metadata(funcVal))
            meta.name = hiss_Stdlib.symbolName_h(alias)
            if (python_internal_ArrayImpl.indexOf(metaSymbols,"@deprecated",None) != -1):
                Reflect.setField(meta,"deprecated",True)
            newFunc = None
            newFunc1 = funcVal.index
            if (newFunc1 == 10):
                _g = funcVal.params[1]
                _g = funcVal.params[0]
                newFunc = hiss_HValue.Function(hFunc,meta)
            elif (newFunc1 == 11):
                _g = funcVal.params[1]
                _g = funcVal.params[0]
                newFunc = hiss_HValue.Macro(hFunc,meta)
            elif (newFunc1 == 12):
                _g = funcVal.params[1]
                _g = funcVal.params[0]
                newFunc = hiss_HValue.SpecialForm(hFunc,meta)
            else:
                raise haxe_Exception.thrown("")
            hiss_HissTools.put(_gthis.globals,hiss_Stdlib.symbolName_h(alias),newFunc)
            cc(newFunc)
        self.internalEval(func,env,_hx_local_1)

    def defDestructiveAlias(self,destructiveName,suffix):
        self.defAlias(hiss_HValue.List([hiss_HValue.Symbol(destructiveName), hiss_HValue.Symbol(HxString.substr(destructiveName,0,(len(destructiveName) - len(suffix)))), hiss_HValue.Symbol("@deprecated")]),self.emptyEnv(),hiss_CCInterp.noCC)

    def getVar(self,name,env,cc):
        stackFrames = hiss_HissTools.toList(env)
        g = hiss_HissTools.toDict(self.globals)
        v = None
        _g = 0
        while (_g < len(stackFrames)):
            frame = (stackFrames[_g] if _g >= 0 and _g < len(stackFrames) else None)
            _g = (_g + 1)
            frameDict = hiss_HissTools.toDict(frame)
            if frameDict.exists_h(name):
                v = frameDict.get_h(name)
                break
        if (v is not None):
            cc(v)
        elif g.exists_h(name):
            cc(g.get_h(name))
        else:
            self.error((("" + Std.string(name)) + " is undefined"))

    def iterable(self,bodyForm,args,env,cc):
        self.internalEval((hiss_HissTools.second(args) if bodyForm else hiss_HissTools.first(args)),env,cc)

    def performIteration(self,bodyForm,args,env,cc,performFunction):
        _gthis = self
        if bodyForm:
            body = hiss_HValue.List(hiss_HissTools.toList(args)[2:None])
            def _hx_local_0(innerArgs,innerEnv,innerCC):
                bodyEnv = hiss_HissTools.extend(innerEnv,hiss_HissTools.destructuringBind(hiss_HissTools.first(args),_gthis,hiss_HissTools.first(innerArgs)))
                _gthis.internalEval(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),body),bodyEnv,innerCC)
            performFunction(_hx_local_0,env,cc)
        else:
            def _hx_local_1(fun):
                performFunction(hiss_HissTools.toHFunction(fun),_gthis.emptyEnv(),cc)
            self.internalEval(hiss_HissTools.second(args),env,_hx_local_1)

    def iterate(self,collect,bodyForm,args,env,cc):
        _gthis = self
        it = hiss_HValue.Nil
        def _hx_local_0(_iterable):
            nonlocal it
            it = _iterable
        self.iterable(bodyForm,args,env,_hx_local_0)
        iterable = hiss_HissTools.value(it,self,True)
        def _hx_local_4(operation,innerEnv,outerCC):
            results = []
            continueCalled = hiss_RefBool()
            breakCalled = hiss_RefBool()
            innerEnv = _gthis.envWithBreakContinue(innerEnv,breakCalled,continueCalled)
            def _hx_local_3():
                def _hx_local_1(result):
                    if (continueCalled.b or breakCalled.b):
                        continueCalled.b = False
                        return
                    results.append(result)
                return _hx_local_1 if collect else hiss_CCInterp.noCC
            iterationCC = _hx_local_3()
            value = HxOverrides.iterator(iterable)
            while value.hasNext():
                value1 = value.next()
                operation(hiss_HValue.List([value1]),innerEnv,iterationCC)
                if breakCalled.b:
                    break
            outerCC(hiss_HValue.List(results))
        synchronousIteration = _hx_local_4
        self.performIteration(bodyForm,args,env,cc,synchronousIteration)

    def iterateCC(self,collect,bodyForm,args,env,cc):
        _gthis = self
        def _hx_local_2(it):
            nonlocal env
            iterable = hiss_HissTools.value(it,_gthis,True)
            iterator = HxOverrides.iterator(iterable)
            results = []
            continueCalled = hiss_RefBool()
            breakCalled = hiss_RefBool()
            env = _gthis.envWithBreakContinue(env,breakCalled,continueCalled)
            asynchronousIteration = None
            def _hx_local_1(operation,innerEnv,outerCC):
                if (not iterator.hasNext()):
                    outerCC(hiss_HValue.List(results))
                else:
                    def _hx_local_0(value):
                        if breakCalled.b:
                            outerCC(hiss_HValue.List(results))
                        else:
                            if (collect and (not continueCalled.b)):
                                results.append(value)
                            continueCalled.b = False
                            asynchronousIteration(operation,innerEnv,outerCC)
                    operation(hiss_HValue.List([iterator.next()]),innerEnv,_hx_local_0)
            asynchronousIteration = _hx_local_1
            _gthis.performIteration(bodyForm,args,env,cc,asynchronousIteration)
        self.iterable(bodyForm,args,env,_hx_local_2)

    def loop(self,args,env,cc):
        _gthis = self
        bindings = hiss_HissTools.first(args)
        body = hiss_Stdlib.rest_h(args)
        names = hiss_Stdlib.cons_h(hiss_HValue.Symbol("recur"),hiss_HissTools.alternates(bindings,True))
        firstValueExps = hiss_HissTools.alternates(bindings,False)
        def _hx_local_3(firstValues):
            nextValues = hiss_HValue.Nil
            recurCalled = False
            def _hx_local_1(nextValueExps,env,cc):
                nonlocal recurCalled
                def _hx_local_0(nextVals):
                    nonlocal nextValues
                    nextValues = nextVals
                _gthis.currentEvalAllFunction(nextValueExps,env,_hx_local_0)
                recurCalled = True
                cc(hiss_HValue.Nil)
            recur = _hx_local_1
            values = firstValues
            result = hiss_HValue.Nil
            while True:
                if recurCalled:
                    values = nextValues
                    recurCalled = False
                def _hx_local_2(value):
                    nonlocal result
                    result = value
                _gthis.internalEval(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),body),hiss_HissTools.extend(env,hiss_HissTools.destructuringBind(names,_gthis,hiss_Stdlib.cons_h(hiss_HValue.SpecialForm(recur,_hx_AnonObject({'name': "recur"})),values))),_hx_local_2)
                if (not recurCalled):
                    break
            cc(result)
        self.currentEvalAllFunction(firstValueExps,env,_hx_local_3)

    def evalUnquotes(self,expr,env):
        tmp = expr.index
        if (tmp == 8):
            exps = expr.params[0]
            copy = list(exps)
            idx = 0
            while (idx < len(copy)):
                _g = (copy[idx] if idx >= 0 and idx < len(copy) else None)
                tmp = _g.index
                if (tmp == 14):
                    _g1 = _g.params[0]
                    if (_g1.index == 17):
                        exp = _g1.params[0]
                        pos = idx
                        if (pos < 0):
                            pos = (len(copy) + pos)
                        if (pos < 0):
                            pos = 0
                        res = copy[pos:(pos + 1)]
                        del copy[pos:(pos + 1)]
                        def _hx_local_3(innerList):
                            nonlocal idx
                            nonlocal idx
                            _g = 0
                            _g1 = hiss_HissTools.toList(innerList)
                            while (_g < len(_g1)):
                                exp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                                _g = (_g + 1)
                                idx = (idx + 1)
                                pos = (idx - 1)
                                copy.insert(pos, hiss_HValue.Quote(exp))
                            idx = (idx - 1)
                        self.internalEval(exp,env,_hx_local_3)
                    else:
                        exp1 = (copy[idx] if idx >= 0 and idx < len(copy) else None)
                        pos1 = idx
                        if (pos1 < 0):
                            pos1 = (len(copy) + pos1)
                        if (pos1 < 0):
                            pos1 = 0
                        res1 = copy[pos1:(pos1 + 1)]
                        del copy[pos1:(pos1 + 1)]
                        x = self.evalUnquotes(exp1,env)
                        copy.insert(idx, x)
                elif (tmp == 17):
                    exp2 = _g.params[0]
                    pos2 = idx
                    if (pos2 < 0):
                        pos2 = (len(copy) + pos2)
                    if (pos2 < 0):
                        pos2 = 0
                    res2 = copy[pos2:(pos2 + 1)]
                    del copy[pos2:(pos2 + 1)]
                    def _hx_local_7(innerList):
                        nonlocal idx
                        nonlocal idx
                        _g = 0
                        _g1 = hiss_HissTools.toList(innerList)
                        while (_g < len(_g1)):
                            exp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                            _g = (_g + 1)
                            idx = (idx + 1)
                            pos = (idx - 1)
                            copy.insert(pos, exp)
                        idx = (idx - 1)
                    self.internalEval(exp2,env,_hx_local_7)
                else:
                    exp3 = (copy[idx] if idx >= 0 and idx < len(copy) else None)
                    pos3 = idx
                    if (pos3 < 0):
                        pos3 = (len(copy) + pos3)
                    if (pos3 < 0):
                        pos3 = 0
                    res3 = copy[pos3:(pos3 + 1)]
                    del copy[pos3:(pos3 + 1)]
                    x1 = self.evalUnquotes(exp3,env)
                    copy.insert(idx, x1)
                idx = (idx + 1)
            return hiss_HValue.List(copy)
        elif (tmp == 14):
            exp = expr.params[0]
            return hiss_HValue.Quote(self.evalUnquotes(exp,env))
        elif (tmp == 15):
            exp = expr.params[0]
            return self.evalUnquotes(exp,env)
        elif (tmp == 16):
            h = expr.params[0]
            val = hiss_HValue.Nil
            def _hx_local_9(v):
                nonlocal val
                val = v
            self.internalEval(h,env,_hx_local_9)
            return val
        else:
            return expr

    def read(self,_hx_str):
        return self.reader.read("",hiss_HStream.FromString(_hx_str))

    def readAll(self,_hx_str):
        return self.reader.readAll(hiss_HValue.String(_hx_str))

    def _eval(self,args,env,cc):
        _gthis = self
        def _hx_local_0(val):
            _gthis.internalEval(val,env,cc)
        self.internalEval(hiss_HissTools.first(args),env,_hx_local_0)

    def eval(self,arg,env = None):
        value = None
        if (env is None):
            env = self.emptyEnv()
        def _hx_local_0(_value):
            nonlocal value
            value = _value
        self.internalEval(arg,env,_hx_local_0)
        return value

    def evalCC(self,arg,cc,env = None):
        if (env is None):
            env = self.emptyEnv()
        self.internalEval(arg,env,cc)

    def truthy(self,cond):
        tmp = cond.index
        if (tmp == 5):
            return False
        elif (tmp == 8):
            if (len(cond.params[0]) == 0):
                return False
            else:
                return True
        else:
            return True

    def interpolateString(self,raw,env,cc,startingIndex = None):
        if (startingIndex is None):
            startingIndex = 0
        _gthis = self
        nextExpressionIndex = (raw.find("$") if ((startingIndex is None)) else HxString.indexOfImpl(raw,"$",startingIndex))
        if (nextExpressionIndex == -1):
            cc(hiss_HValue.String(raw))
        else:
            index = (nextExpressionIndex - 1)
            if ((("" if (((index < 0) or ((index >= len(raw))))) else raw[index])) == "\\"):
                self.interpolateString((HxOverrides.stringOrNull(HxString.substr(raw,0,(nextExpressionIndex - 1))) + HxOverrides.stringOrNull(HxString.substr(raw,nextExpressionIndex,None))),env,cc,(nextExpressionIndex + 1))
            else:
                expStream = hiss_HStream.FromString(HxString.substr(raw,(nextExpressionIndex + 1),None))
                exp = None
                expLength = -1
                if (expStream.peek(1) == "{"):
                    expStream.drop_d("{")
                    _g = expStream.takeUntil_d(["}"],False,False,True)
                    braceContents = None
                    if (_g.index == 0):
                        o = _g.params[0]
                        braceContents = o
                    else:
                        v = Std.string(expStream.takeUntil_d(["}"],False,False,True))
                        raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
                    braceContents1 = braceContents.output
                    expStream = hiss_HStream.FromString(braceContents1)
                    expLength = (2 + expStream.length())
                    exp = self.reader.read("",expStream)
                else:
                    startingLength = expStream.length()
                    exp = self.reader.read("",expStream)
                    expLength = (startingLength - expStream.length())
                def _hx_local_0(val):
                    _gthis.interpolateString(((HxOverrides.stringOrNull(HxString.substr(raw,0,nextExpressionIndex)) + HxOverrides.stringOrNull(hiss_HissTools.toMessage(val))) + HxOverrides.stringOrNull(HxString.substr(raw,((nextExpressionIndex + 1) + expLength),None))),env,cc,((nextExpressionIndex + 1) + len(hiss_HissTools.toMessage(val))))
                self.internalEval(exp,env,_hx_local_0)

    def internalEval(self,exp,env,cc):
        _gthis = self
        tmp = exp.index
        if (tmp == 0):
            _g = exp.params[0]
            cc(exp)
        elif (tmp == 1):
            _g = exp.params[0]
            cc(exp)
        elif (tmp == 2):
            _g = exp.params[0]
            stackFrames = hiss_HissTools.toList(env)
            g = hiss_HissTools.toDict(self.globals)
            v = None
            _g = 0
            while (_g < len(stackFrames)):
                frame = (stackFrames[_g] if _g >= 0 and _g < len(stackFrames) else None)
                _g = (_g + 1)
                frameDict = hiss_HissTools.toDict(frame)
                if frameDict.exists_h(exp):
                    v = frameDict.get_h(exp)
                    break
            if (v is not None):
                cc(v)
            elif g.exists_h(exp):
                cc(g.get_h(exp))
            else:
                self.error((("" + Std.string(exp)) + " is undefined"))
        elif (tmp == 3):
            raw = exp.params[0]
            self.interpolateString(raw,env,cc)
        elif (tmp == 4):
            _g = exp.params[0]
            cc(exp)
        elif (((tmp == 7) or ((tmp == 6))) or ((tmp == 5))):
            cc(exp)
        elif (tmp == 8):
            _g = exp.params[0]
            a = self.maxStackDepth
            b = len(haxe__CallStack_CallStack_Impl_.callStack())
            self.maxStackDepth = Math.floor((a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b))))
            tmp = (not self.readingProgram)
            def _hx_local_3(_hx_callable):
                tmp = _hx_callable.index
                if (tmp == 10):
                    _g = _hx_callable.params[1]
                    _g = _hx_callable.params[0]
                    env1 = env
                    cc1 = cc
                    _gthis1 = _gthis
                    def _hx_local_1(values):
                        _g = hiss_HissTools.first(values)
                        if (_g.index == 10):
                            meta = _g.params[1]
                            func = _g.params[0]
                            if Reflect.field(meta,"deprecated"):
                                hiss_Stdlib.message_hd(hiss_HValue.String((("Warning! Function " + HxOverrides.stringOrNull(meta.name)) + " is deprecated.")))
                            func(hiss_Stdlib.rest_h(values),_gthis1.emptyEnv(),cc1)
                        else:
                            raise haxe_Exception.thrown(("Cannot funcall " + Std.string(hiss_HissTools.first(values))))
                    _gthis.currentEvalAllFunction(exp,env1,_hx_local_1)
                elif (tmp == 11):
                    _g = _hx_callable.params[1]
                    _g = _hx_callable.params[0]
                    args = hiss_Stdlib.cons_h(_hx_callable,hiss_Stdlib.rest_h(exp))
                    env1 = env
                    cc2 = cc
                    _gthis2 = _gthis
                    def _hx_local_2(expansion):
                        _gthis2.internalEval(expansion,env1,cc2)
                    _gthis.specialForm(args,env1,_hx_local_2)
                elif (tmp == 12):
                    _g = _hx_callable.params[1]
                    _g = _hx_callable.params[0]
                    args = hiss_Stdlib.cons_h(_hx_callable,hiss_Stdlib.rest_h(exp))
                    _g = hiss_HissTools.first(args)
                    tmp = _g.index
                    if (tmp == 11):
                        meta = _g.params[1]
                        func = _g.params[0]
                        if Reflect.field(meta,"deprecated"):
                            hiss_Stdlib.message_hd(hiss_HValue.String((("Warning! Macro " + HxOverrides.stringOrNull(meta.name)) + " is deprecated.")))
                        func(hiss_Stdlib.rest_h(args),env,cc)
                    elif (tmp == 12):
                        meta = _g.params[1]
                        func = _g.params[0]
                        if Reflect.field(meta,"deprecated"):
                            hiss_Stdlib.message_hd(hiss_HValue.String((("Warning! Macro " + HxOverrides.stringOrNull(meta.name)) + " is deprecated.")))
                        func(hiss_Stdlib.rest_h(args),env,cc)
                    else:
                        raise haxe_Exception.thrown((("" + Std.string(hiss_HissTools.first(args))) + " is not a macro or special form"))
                else:
                    _gthis.error(((("Hiss cannot call " + Std.string(_hx_callable)) + " from ") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(hiss_HissTools.first(exp)))))
            self.internalEval(hiss_HissTools.first(exp),env,_hx_local_3)
        elif (tmp == 10):
            _g = exp.params[1]
            _g = exp.params[0]
            cc(exp)
        elif (tmp == 11):
            _g = exp.params[1]
            _g = exp.params[0]
            cc(exp)
        elif (tmp == 12):
            _g = exp.params[1]
            _g = exp.params[0]
            cc(exp)
        elif (tmp == 13):
            _g = exp.params[1]
            _g = exp.params[0]
            cc(exp)
        elif (tmp == 14):
            e = exp.params[0]
            cc(e)
        elif (tmp == 15):
            e = exp.params[0]
            cc1 = cc
            tmp = None
            tmp1 = e.index
            if (tmp1 == 8):
                exps = e.params[0]
                copy = list(exps)
                idx = 0
                while (idx < len(copy)):
                    _g = (copy[idx] if idx >= 0 and idx < len(copy) else None)
                    tmp1 = _g.index
                    if (tmp1 == 14):
                        _g1 = _g.params[0]
                        if (_g1.index == 17):
                            exp1 = _g1.params[0]
                            pos = idx
                            if (pos < 0):
                                pos = (len(copy) + pos)
                            if (pos < 0):
                                pos = 0
                            res = copy[pos:(pos + 1)]
                            del copy[pos:(pos + 1)]
                            def _hx_local_7(innerList):
                                nonlocal idx
                                nonlocal idx
                                _g = 0
                                _g1 = hiss_HissTools.toList(innerList)
                                while (_g < len(_g1)):
                                    exp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                                    _g = (_g + 1)
                                    idx = (idx + 1)
                                    pos = (idx - 1)
                                    copy.insert(pos, hiss_HValue.Quote(exp))
                                idx = (idx - 1)
                            self.internalEval(exp1,env,_hx_local_7)
                        else:
                            exp2 = (copy[idx] if idx >= 0 and idx < len(copy) else None)
                            pos1 = idx
                            if (pos1 < 0):
                                pos1 = (len(copy) + pos1)
                            if (pos1 < 0):
                                pos1 = 0
                            res1 = copy[pos1:(pos1 + 1)]
                            del copy[pos1:(pos1 + 1)]
                            x = self.evalUnquotes(exp2,env)
                            copy.insert(idx, x)
                    elif (tmp1 == 17):
                        exp3 = _g.params[0]
                        pos2 = idx
                        if (pos2 < 0):
                            pos2 = (len(copy) + pos2)
                        if (pos2 < 0):
                            pos2 = 0
                        res2 = copy[pos2:(pos2 + 1)]
                        del copy[pos2:(pos2 + 1)]
                        def _hx_local_11(innerList):
                            nonlocal idx
                            nonlocal idx
                            _g = 0
                            _g1 = hiss_HissTools.toList(innerList)
                            while (_g < len(_g1)):
                                exp = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                                _g = (_g + 1)
                                idx = (idx + 1)
                                pos = (idx - 1)
                                copy.insert(pos, exp)
                            idx = (idx - 1)
                        self.internalEval(exp3,env,_hx_local_11)
                    else:
                        exp4 = (copy[idx] if idx >= 0 and idx < len(copy) else None)
                        pos3 = idx
                        if (pos3 < 0):
                            pos3 = (len(copy) + pos3)
                        if (pos3 < 0):
                            pos3 = 0
                        res3 = copy[pos3:(pos3 + 1)]
                        del copy[pos3:(pos3 + 1)]
                        x1 = self.evalUnquotes(exp4,env)
                        copy.insert(idx, x1)
                    idx = (idx + 1)
                tmp = hiss_HValue.List(copy)
            elif (tmp1 == 14):
                exp1 = e.params[0]
                tmp = hiss_HValue.Quote(self.evalUnquotes(exp1,env))
            elif (tmp1 == 15):
                exp1 = e.params[0]
                tmp = self.evalUnquotes(exp1,env)
            elif (tmp1 == 16):
                h = e.params[0]
                val = hiss_HValue.Nil
                def _hx_local_13(v):
                    nonlocal val
                    val = v
                self.internalEval(h,env,_hx_local_13)
                tmp = val
            else:
                tmp = e
            cc1(tmp)
        elif (tmp == 16):
            e = exp.params[0]
            self.internalEval(e,env,cc)
        else:
            self.error((("Cannot evaluate " + Std.string(exp)) + " yet"))

    def nativeFunctionMaxArgs(self):
        return 5

    def toNativeFunction(self,fun):
        _gthis = self
        if (fun.index == 10):
            _g = fun.params[1]
            _g1 = fun.params[0]
            meta = _g
            if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) == 0))):
                def _hx_local_0():
                    val = None
                    def _hx_local_1(_val):
                        nonlocal val
                        val = _val
                    _gthis.funcall(False,hiss_HValue.List([fun]),_gthis.emptyEnv(),_hx_local_1)
                    return hiss_HissTools.value(val,_gthis,True)
                return _hx_local_0
            else:
                meta = _g
                if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) == 1))):
                    def _hx_local_2(arg1 = None):
                        val = None
                        def _hx_local_3(_val):
                            nonlocal val
                            val = _val
                        _gthis.funcall(False,hiss_HValue.List([fun, hiss_HValue.Quote(hiss_HissTools.toHValue(arg1))]),_gthis.emptyEnv(),_hx_local_3)
                        return hiss_HissTools.value(val,_gthis,True)
                    return _hx_local_2
                else:
                    meta = _g
                    if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) == 2))):
                        def _hx_local_4(arg1 = None,arg2 = None):
                            val = None
                            def _hx_local_5(_val):
                                nonlocal val
                                val = _val
                            _gthis.funcall(False,hiss_HValue.List([fun, hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg2))]),_gthis.emptyEnv(),_hx_local_5)
                            return hiss_HissTools.value(val,_gthis,True)
                        return _hx_local_4
                    else:
                        meta = _g
                        if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) == 3))):
                            def _hx_local_6(arg1 = None,arg2 = None,arg3 = None):
                                val = None
                                def _hx_local_7(_val):
                                    nonlocal val
                                    val = _val
                                _gthis.funcall(False,hiss_HValue.List([fun, hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg2)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg3))]),_gthis.emptyEnv(),_hx_local_7)
                                return hiss_HissTools.value(val,_gthis,True)
                            return _hx_local_6
                        else:
                            meta = _g
                            if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) == 4))):
                                def _hx_local_8(arg1 = None,arg2 = None,arg3 = None,arg4 = None):
                                    val = None
                                    def _hx_local_9(_val):
                                        nonlocal val
                                        val = _val
                                    _gthis.funcall(False,hiss_HValue.List([fun, hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg2)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg3)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg4))]),_gthis.emptyEnv(),_hx_local_9)
                                    return hiss_HissTools.value(val,_gthis,True)
                                return _hx_local_8
                            else:
                                meta = _g
                                if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) == 5))):
                                    def _hx_local_10(arg1 = None,arg2 = None,arg3 = None,arg4 = None,arg5 = None):
                                        val = None
                                        def _hx_local_11(_val):
                                            nonlocal val
                                            val = _val
                                        _gthis.funcall(False,hiss_HValue.List([fun, hiss_HValue.Quote(hiss_HissTools.toHValue(arg1)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg2)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg3)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg4)), hiss_HValue.Quote(hiss_HissTools.toHValue(arg5))]),_gthis.emptyEnv(),_hx_local_11)
                                        return hiss_HissTools.value(val,_gthis,True)
                                    return _hx_local_10
                                else:
                                    meta = _g
                                    if ((Reflect.field(meta,"argNames") is not None) and ((len(Reflect.field(meta,"argNames")) > 5))):
                                        raise haxe_Exception.thrown("Function has too many args for conversion to native function")
                                    else:
                                        meta = _g
                                        if (Reflect.field(meta,"argNames") is None):
                                            raise haxe_Exception.thrown((("Function " + HxOverrides.stringOrNull(meta.name)) + " has no args specified, cannot be converted"))
                                        else:
                                            raise haxe_Exception.thrown("Cannot convert non-function $fun to native function")
        else:
            raise haxe_Exception.thrown("Cannot convert non-function $fun to native function")

    @staticmethod
    def noOp(args,env,cc):
        pass

    @staticmethod
    def noCC(arg):
        pass

    @staticmethod
    def emptyList():
        return hiss_HValue.List([])

    @staticmethod
    def main():
        interp = hiss_CCInterp()
        hiss_CCInterp.run(interp)

    @staticmethod
    def run(interp,args = None):
        if (args is None):
            args = Sys.args()
        useConsoleReader = True
        script = None
        nextArg = None
        while (len(args) > 0):
            nextArg = (None if ((len(args) == 0)) else args.pop(0))
            if (nextArg is None):
                if nextArg.endswith(".hiss"):
                    script = nextArg
                elif (script is not None):
                    _this = interp.scriptArgs
                    _this.append(hiss_HValue.String(nextArg))
            else:
                nextArg1 = nextArg
                _hx_local_0 = len(nextArg1)
                if (_hx_local_0 == 19):
                    if (nextArg1 == "--no-console-reader"):
                        useConsoleReader = False
                    elif nextArg.endswith(".hiss"):
                        script = nextArg
                    elif (script is not None):
                        _this1 = interp.scriptArgs
                        _this1.append(hiss_HValue.String(nextArg))
                elif (_hx_local_0 == 7):
                    if (nextArg1 == "--no-cr"):
                        useConsoleReader = False
                    elif nextArg.endswith(".hiss"):
                        script = nextArg
                    elif (script is not None):
                        _this1 = interp.scriptArgs
                        _this1.append(hiss_HValue.String(nextArg))
                elif (_hx_local_0 == 6):
                    if (nextArg1 == "--nocr"):
                        useConsoleReader = False
                    elif nextArg.endswith(".hiss"):
                        script = nextArg
                    elif (script is not None):
                        _this1 = interp.scriptArgs
                        _this1.append(hiss_HValue.String(nextArg))
                elif nextArg.endswith(".hiss"):
                    script = nextArg
                elif (script is not None):
                    _this1 = interp.scriptArgs
                    _this1.append(hiss_HValue.String(nextArg))
        if (script is not None):
            interp.load(script)
        else:
            interp.repl(useConsoleReader)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.reader = None
        _hx_o.tempTrace = None
        _hx_o.readingProgram = None
        _hx_o.maxStackDepth = None
        _hx_o.errorHandler = None
        _hx_o.debugClassImports = None
        _hx_o.currentBeginFunction = None
        _hx_o.currentEvalAllFunction = None
        _hx_o.scriptArgs = None
hiss_CCInterp._hx_class = hiss_CCInterp


class hiss_CompileInfo:
    _hx_class_name = "hiss.CompileInfo"
    __slots__ = ()
hiss_CompileInfo._hx_class = hiss_CompileInfo


class hiss_HDict:
    _hx_class_name = "hiss.HDict"
    __slots__ = ("_map", "_interp")
    _hx_fields = ["_map", "_interp"]
    _hx_methods = ["iterator", "keyValueIterator", "copy", "get_h", "put_hd", "exists_h", "erase_hd"]
    _hx_statics = ["makeDict_cc"]

    def __init__(self,interp,_hx_map = None):
        self._map = haxe_ds_StringMap()
        self._interp = interp
        if (_hx_map is not None):
            self._map = _hx_map

    def iterator(self):
        kvIterator = self.keyValueIterator()
        def _hx_local_2():
            def _hx_local_0():
                pair = kvIterator.next()
                return hiss_HValue.List([pair.key, pair.value])
            def _hx_local_1():
                return kvIterator.hasNext()
            return _hx_AnonObject({'next': _hx_local_0, 'hasNext': _hx_local_1})
        return _hx_local_2()

    def keyValueIterator(self):
        return hiss_HDictIterator(haxe_iterators_MapKeyValueIterator(self._map))

    def copy(self):
        return hiss_HDict(self._interp,self._map.copy())

    def get_h(self,key):
        this1 = self._map
        if (not (hiss_HissTools.toPrint(key) in this1.h)):
            return hiss_HValue.Nil
        this1 = self._map
        key1 = hiss_HissTools.toPrint(key)
        hashMatches = this1.h.get(key1,None)
        _g = 0
        while (_g < len(hashMatches)):
            match = (hashMatches[_g] if _g >= 0 and _g < len(hashMatches) else None)
            _g = (_g + 1)
            if self._interp.truthy(hiss_Stdlib.eq_ih(self._interp,match.key,key)):
                return match.value
        return hiss_HValue.Nil

    def put_hd(self,key,value):
        this1 = self._map
        if (not (hiss_HissTools.toPrint(key) in this1.h)):
            this1 = self._map
            k = hiss_HissTools.toPrint(key)
            v = []
            this1.h[k] = v
        this1 = self._map
        key1 = hiss_HissTools.toPrint(key)
        hashMatches = this1.h.get(key1,None)
        _g = 0
        while (_g < len(hashMatches)):
            match = (hashMatches[_g] if _g >= 0 and _g < len(hashMatches) else None)
            _g = (_g + 1)
            if self._interp.truthy(hiss_Stdlib.eq_ih(self._interp,match.key,key)):
                match.value = value
                return
        hashMatches.append(_hx_AnonObject({'key': key, 'value': value}))

    def exists_h(self,key):
        this1 = self._map
        if (not (hiss_HissTools.toPrint(key) in this1.h)):
            return False
        this1 = self._map
        key1 = hiss_HissTools.toPrint(key)
        hashMatches = this1.h.get(key1,None)
        _g = 0
        while (_g < len(hashMatches)):
            match = (hashMatches[_g] if _g >= 0 and _g < len(hashMatches) else None)
            _g = (_g + 1)
            if self._interp.truthy(hiss_Stdlib.eq_ih(self._interp,match.key,key)):
                return True
        return False

    def erase_hd(self,key):
        this1 = self._map
        if (not (hiss_HissTools.toPrint(key) in this1.h)):
            return
        this1 = self._map
        key1 = hiss_HissTools.toPrint(key)
        hashMatches = this1.h.get(key1,None)
        idx = 0
        while (idx < len(hashMatches)):
            match = (hashMatches[idx] if idx >= 0 and idx < len(hashMatches) else None)
            if self._interp.truthy(hiss_Stdlib.eq_ih(self._interp,match.key,key)):
                pos = idx
                if (pos < 0):
                    pos = (len(hashMatches) + pos)
                if (pos < 0):
                    pos = 0
                res = hashMatches[pos:(pos + 1)]
                del hashMatches[pos:(pos + 1)]
                return
            idx = (idx + 1)

    @staticmethod
    def makeDict_cc(interp,args,env,cc):
        _hx_dict = hiss_HDict(interp)
        idx = 0
        while (idx < hiss_Stdlib.length_h(args)):
            key = hiss_Stdlib.nth_h(args,hiss_HValue.Int(idx))
            value = hiss_Stdlib.nth_h(args,hiss_HValue.Int((idx + 1)))
            _hx_dict.put_hd(key,value)
            idx = (idx + 2)
        cc(hiss_HValue.Dict(_hx_dict))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._map = None
        _hx_o._interp = None
hiss_HDict._hx_class = hiss_HDict


class hiss_HDictIterator:
    _hx_class_name = "hiss.HDictIterator"
    __slots__ = ("kvIterator", "hvkIterator")
    _hx_fields = ["kvIterator", "hvkIterator"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.hvkIterator = None
        self.kvIterator = it

    def next(self):
        if ((self.hvkIterator is not None) and self.hvkIterator.hasNext()):
            return self.hvkIterator.next()
        if self.kvIterator.hasNext():
            self.hvkIterator = haxe_iterators_ArrayIterator(self.kvIterator.next().value)
            return self.next()
        return None

    def hasNext(self):
        if ((self.hvkIterator is not None) and self.hvkIterator.hasNext()):
            return True
        return self.kvIterator.hasNext()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.kvIterator = None
        _hx_o.hvkIterator = None
hiss_HDictIterator._hx_class = hiss_HDictIterator

class hiss_HSignal(Enum):
    __slots__ = ()
    _hx_class_name = "hiss.HSignal"
    _hx_constructs = ["Quit"]
hiss_HSignal.Quit = hiss_HSignal("Quit", 0, ())
hiss_HSignal._hx_class = hiss_HSignal


class hiss_HPosition:
    _hx_class_name = "hiss.HPosition"
    __slots__ = ("file", "line", "column")
    _hx_fields = ["file", "line", "column"]
    _hx_methods = ["equals", "copy", "toString"]

    def __init__(self,file,line,column):
        self.file = file
        self.line = line
        self.column = column

    def equals(self,other):
        if ((self.file == other.file) and ((self.line == other.line))):
            return (self.column == other.column)
        else:
            return False

    def copy(self):
        return hiss_HPosition(self.file,self.line,self.column)

    def toString(self):
        return ((((("" + HxOverrides.stringOrNull(self.file)) + ":") + Std.string(self.line)) + ":") + Std.string(self.column))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.file = None
        _hx_o.line = None
        _hx_o.column = None
hiss_HPosition._hx_class = hiss_HPosition


class hiss_HStream:
    _hx_class_name = "hiss.HStream"
    __slots__ = ("_rawString", "_pos")
    _hx_fields = ["_rawString", "_pos"]
    _hx_methods = ["indexOf", "everyIndexOf", "length", "_position", "peekAhead", "peekUntil", "toString", "copy", "drop_d", "takeUntil_d", "peek", "take_d", "countConsecutive_d", "getLine", "peekLine", "takeLine_d", "takeLineAsStream_d", "dropWhileOneOf_d", "dropIfOneOf_d", "dropWhitespace_d", "takeUntilWhitespace_d", "peekUntilWhitespace", "nextIsWhitespace", "nextIsOneOf", "putBack_d", "peekAll", "isEmpty"]
    _hx_statics = ["_dummyCount", "FromString", "FromFile", "_WHITESPACE"]

    def __init__(self,path,rawString,line = None,column = None):
        if (line is None):
            line = 1
        if (column is None):
            column = 1
        if (rawString is None):
            raise haxe_Exception.thrown((("Tried to create buffer of path " + ("null" if path is None else path)) + " with null contents"))
        rawString = StringTools.replace(rawString,"\r","")
        self._rawString = rawString
        self._pos = hiss_HPosition(path,line,column)

    def indexOf(self,s,start = None):
        if (start is None):
            start = 0
        _this = self._rawString
        if (start is None):
            return _this.find(s)
        else:
            return HxString.indexOfImpl(_this,s,start)

    def everyIndexOf(self,s,start = None):
        if (start is None):
            start = 0
        _gthis = self
        _g = []
        _g1 = start
        _g2 = len(self._rawString)
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(i)
        def _hx_local_1():
            def _hx_local_0(i):
                _this = _gthis._rawString
                return ((("" if (((i < 0) or ((i >= len(_this))))) else _this[i])) == s)
            return list(filter(_hx_local_0,_g))
        return _hx_local_1()

    def length(self):
        return len(self._rawString)

    def _position(self):
        return self._pos.copy()

    def peekAhead(self,start,length):
        return HxString.substr(self._rawString,start,length)

    def peekUntil(self,terminators,eofTerminates = None,allowEscapedTerminators = None,_ = None):
        if (eofTerminates is None):
            eofTerminates = False
        if (allowEscapedTerminators is None):
            allowEscapedTerminators = True
        if (_ is None):
            _ = False
        if (len(self._rawString) == 0):
            return haxe_ds_Option._hx_None
        index = len(self._rawString)
        whichTerminator = ""
        _g = 0
        while (_g < len(terminators)):
            terminator = (terminators[_g] if _g >= 0 and _g < len(terminators) else None)
            _g = (_g + 1)
            _this = self._rawString
            startIndex = None
            nextIndex = (_this.find(terminator) if ((startIndex is None)) else HxString.indexOfImpl(_this,terminator,startIndex))
            while True:
                tmp = None
                if (allowEscapedTerminators and ((nextIndex > 0))):
                    _this1 = self._rawString
                    index1 = (nextIndex - 1)
                    tmp = ((("" if (((index1 < 0) or ((index1 >= len(_this1))))) else _this1[index1])) == "\\")
                else:
                    tmp = False
                if (not tmp):
                    break
                _this2 = self._rawString
                startIndex1 = (nextIndex + 1)
                nextIndex = (_this2.find(terminator) if ((startIndex1 is None)) else HxString.indexOfImpl(_this2,terminator,startIndex1))
            if ((nextIndex != -1) and ((nextIndex < index))):
                index = nextIndex
                whichTerminator = terminator
        if (index < len(self._rawString)):
            return haxe_ds_Option.Some(_hx_AnonObject({'output': HxString.substr(self._rawString,0,index), 'terminator': whichTerminator}))
        elif eofTerminates:
            return haxe_ds_Option.Some(_hx_AnonObject({'output': self._rawString, 'terminator': None}))
        else:
            return haxe_ds_Option._hx_None

    def toString(self):
        snip = HxString.substr(self._rawString,0,50)
        return (("`" + ("null" if snip is None else snip)) + "...`")

    def copy(self):
        return hiss_HStream.FromString(self._rawString,self._pos)

    def drop_d(self,s):
        next = self.peek(len(s))
        if (next != s):
            raise haxe_Exception.thrown((((("Expected to drop `" + ("null" if s is None else s)) + "` from buffer but found `") + ("null" if next is None else next)) + "`"))
        lines = len(hiss_HStream.FromString(next).everyIndexOf("\n"))
        if (lines > 0):
            _hx_local_0 = self._pos
            _hx_local_1 = _hx_local_0.line
            _hx_local_0.line = (_hx_local_1 + lines)
            _hx_local_0.line
            startIndex = None
            startIndex1 = None
            if (startIndex is None):
                startIndex1 = next.rfind("\n", 0, len(next))
            else:
                i = next.rfind("\n", 0, (startIndex + 1))
                startLeft = (max(0,((startIndex + 1) - len("\n"))) if ((i == -1)) else (i + 1))
                check = next.find("\n", startLeft, len(next))
                startIndex1 = (check if (((check > i) and ((check <= startIndex)))) else i)
            tmp = HxString.substring(next,startIndex1,None)
            self._pos.column = len(tmp)
        else:
            _hx_local_2 = self._pos
            _hx_local_3 = _hx_local_2.column
            _hx_local_2.column = (_hx_local_3 + len(next))
            _hx_local_2.column
        self._rawString = HxString.substr(self._rawString,len(s),None)

    def takeUntil_d(self,terminators,eofTerminates = None,allowEscapedTerminators = None,dropTerminator = None):
        if (eofTerminates is None):
            eofTerminates = False
        if (allowEscapedTerminators is None):
            allowEscapedTerminators = True
        if (dropTerminator is None):
            dropTerminator = True
        _g = self.peekUntil(terminators,eofTerminates,allowEscapedTerminators)
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
            t = _g1.terminator
            s = _g1.output
            self.drop_d(s)
            if (dropTerminator and ((t is not None))):
                self.drop_d(t)
            return haxe_ds_Option.Some(_hx_AnonObject({'output': s, 'terminator': t}))
        elif (tmp == 1):
            return haxe_ds_Option._hx_None
        else:
            pass

    def peek(self,chars):
        if (len(self._rawString) < chars):
            raise haxe_Exception.thrown("Not enough characters left in buffer.")
        data = HxString.substr(self._rawString,0,chars)
        return data

    def take_d(self,chars):
        data = self.peek(chars)
        self.drop_d(data)
        return data

    def countConsecutive_d(self,s):
        num = 0
        while (HxString.substr(self._rawString,0,len(s)) == s):
            num = (num + 1)
            self.drop_d(s)
        return num

    def getLine(self,trimmed,retriever):
        nextLine = retriever(["\n"],True,True,True)
        tmp = nextLine.index
        if (tmp == 0):
            _g = nextLine.params[0]
            _g1 = _g.terminator
            nextLine = _g.output
            index = (len(nextLine) - 1)
            if ((("" if (((index < 0) or ((index >= len(nextLine))))) else nextLine[index])) == "\n"):
                nextLine = HxString.substr(nextLine,0,-1)
            startIndex = None
            if (((trimmed.find("r") if ((startIndex is None)) else HxString.indexOfImpl(trimmed,"r",startIndex))) != -1):
                nextLine = StringTools.rtrim(nextLine)
            startIndex = None
            if (((trimmed.find("l") if ((startIndex is None)) else HxString.indexOfImpl(trimmed,"l",startIndex))) != -1):
                nextLine = StringTools.ltrim(nextLine)
            return haxe_ds_Option.Some(nextLine)
        elif (tmp == 1):
            return haxe_ds_Option._hx_None
        else:
            pass

    def peekLine(self,trimmed = None):
        if (trimmed is None):
            trimmed = ""
        return self.getLine(trimmed,self.peekUntil)

    def takeLine_d(self,trimmed = None):
        if (trimmed is None):
            trimmed = ""
        return self.getLine(trimmed,self.takeUntil_d)

    def takeLineAsStream_d(self,trimmed = None):
        if (trimmed is None):
            trimmed = ""
        pos = self._position()
        _g = self.takeLine_d(trimmed)
        tmp = None
        if (_g.index == 0):
            s = _g.params[0]
            tmp = s
        else:
            v = Std.string(self.takeLine_d(trimmed))
            raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
        return hiss_HStream.FromString(tmp,pos)

    def dropWhileOneOf_d(self,stringsToDrop,limit = None):
        if (limit is None):
            limit = -1
        lengths = haxe_ds_IntMap()
        stringsToDropMap = haxe_ds_StringMap()
        _g = 0
        while (_g < len(stringsToDrop)):
            _hx_str = (stringsToDrop[_g] if _g >= 0 and _g < len(stringsToDrop) else None)
            _g = (_g + 1)
            lengths.set(len(_hx_str),True)
            stringsToDropMap.h[_hx_str] = True
        _g = []
        l = lengths.keys()
        while l.hasNext():
            l1 = l.next()
            _g.append(l1)
        lengthsDescending = _g
        lengthsDescending.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
        lengthsDescending.reverse()
        while True:
            tmp = None
            if (limit != -1):
                tmp1 = limit
                limit = (limit - 1)
                tmp = (tmp1 > 0)
            else:
                tmp = True
            if (not tmp):
                break
            dropped = False
            _g = 0
            while (_g < len(lengthsDescending)):
                l = (lengthsDescending[_g] if _g >= 0 and _g < len(lengthsDescending) else None)
                _g = (_g + 1)
                if (self.length() >= l):
                    couldBeOneOf = self.peek(l)
                    if (couldBeOneOf in stringsToDropMap.h):
                        self.drop_d(couldBeOneOf)
                        dropped = True
                        break
            if dropped:
                continue
            break

    def dropIfOneOf_d(self,stringsToDrop):
        self.dropWhileOneOf_d(stringsToDrop,1)

    def dropWhitespace_d(self):
        self.dropWhileOneOf_d(hiss_HStream._WHITESPACE)

    def takeUntilWhitespace_d(self):
        return self.takeUntil_d(hiss_HStream._WHITESPACE,True,False)

    def peekUntilWhitespace(self):
        return self.peekUntil(hiss_HStream._WHITESPACE,True,False)

    def nextIsWhitespace(self):
        if (len(self._rawString) != 0):
            return (python_internal_ArrayImpl.indexOf(hiss_HStream._WHITESPACE,self.peek(1),None) != -1)
        else:
            return True

    def nextIsOneOf(self,a):
        _g = 0
        while (_g < len(a)):
            s = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            tmp = None
            if (len(self._rawString) >= len(s)):
                _this = self._rawString
                startIndex = None
                tmp = (((_this.find(s) if ((startIndex is None)) else HxString.indexOfImpl(_this,s,startIndex))) == 0)
            else:
                tmp = False
            if tmp:
                return True
        return False

    def putBack_d(self,s):
        self._rawString = (("null" if s is None else s) + HxOverrides.stringOrNull(self._rawString))
        startIndex = None
        if (((s.find("\n") if ((startIndex is None)) else HxString.indexOfImpl(s,"\n",startIndex))) != -1):
            _hx_local_0 = self._pos
            _hx_local_1 = _hx_local_0.line
            _hx_local_0.line = (_hx_local_1 - len(hiss_HStream.FromString(s).everyIndexOf("\n")))
            _hx_local_0.line
            self._pos.column = 0
        else:
            _hx_local_2 = self._pos
            _hx_local_3 = _hx_local_2.column
            _hx_local_2.column = (_hx_local_3 - len(s))
            _hx_local_2.column

    def peekAll(self):
        return self._rawString

    def isEmpty(self):
        return (len(self._rawString) == 0)

    @staticmethod
    def FromString(s,pos = None):
        if (pos is None):
            def _hx_local_2():
                _hx_local_0 = hiss_HStream
                _hx_local_1 = _hx_local_0._dummyCount
                _hx_local_0._dummyCount = (_hx_local_1 + 1)
                return _hx_local_1
            tmp = ("!NOTAFILE-" + Std.string(_hx_local_2()))
            return hiss_HStream((("null" if tmp is None else tmp) + "!"),s)
        else:
            return hiss_HStream(pos.file,s,pos.line,pos.column)

    @staticmethod
    def FromFile(path):
        return hiss_HStream(path,sys_io_File.getContent(path))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._rawString = None
        _hx_o._pos = None
hiss_HStream._hx_class = hiss_HStream

class hiss_HValue(Enum):
    __slots__ = ()
    _hx_class_name = "hiss.HValue"
    _hx_constructs = ["Int", "Float", "Symbol", "InterpString", "String", "Nil", "Null", "T", "List", "Dict", "Function", "Macro", "SpecialForm", "Object", "Quote", "Quasiquote", "Unquote", "UnquoteList", "Comment"]

    @staticmethod
    def Int(value):
        return hiss_HValue("Int", 0, (value,))

    @staticmethod
    def Float(value):
        return hiss_HValue("Float", 1, (value,))

    @staticmethod
    def Symbol(name):
        return hiss_HValue("Symbol", 2, (name,))

    @staticmethod
    def InterpString(value):
        return hiss_HValue("InterpString", 3, (value,))

    @staticmethod
    def String(value):
        return hiss_HValue("String", 4, (value,))

    @staticmethod
    def List(l):
        return hiss_HValue("List", 8, (l,))

    @staticmethod
    def Dict(n):
        return hiss_HValue("Dict", 9, (n,))

    @staticmethod
    def Function(f,meta):
        return hiss_HValue("Function", 10, (f,meta))

    @staticmethod
    def Macro(f,meta):
        return hiss_HValue("Macro", 11, (f,meta))

    @staticmethod
    def SpecialForm(f,meta):
        return hiss_HValue("SpecialForm", 12, (f,meta))

    @staticmethod
    def Object(t,v):
        return hiss_HValue("Object", 13, (t,v))

    @staticmethod
    def Quote(exp):
        return hiss_HValue("Quote", 14, (exp,))

    @staticmethod
    def Quasiquote(exp):
        return hiss_HValue("Quasiquote", 15, (exp,))

    @staticmethod
    def Unquote(exp):
        return hiss_HValue("Unquote", 16, (exp,))

    @staticmethod
    def UnquoteList(exp):
        return hiss_HValue("UnquoteList", 17, (exp,))
hiss_HValue.Nil = hiss_HValue("Nil", 5, ())
hiss_HValue.Null = hiss_HValue("Null", 6, ())
hiss_HValue.T = hiss_HValue("T", 7, ())
hiss_HValue.Comment = hiss_HValue("Comment", 18, ())
hiss_HValue._hx_class = hiss_HValue


class hiss_ClassMetaTools:
    _hx_class_name = "hiss.ClassMetaTools"
    __slots__ = ()
    _hx_statics = ["addDefaultFields"]

    @staticmethod
    def addDefaultFields(meta):
        if (Reflect.field(meta,"omitMemberPrefixes") is None):
            Reflect.setField(meta,"omitMemberPrefixes",False)
        if (Reflect.field(meta,"omitStaticPrefixes") is None):
            Reflect.setField(meta,"omitStaticPrefixes",False)
        if (Reflect.field(meta,"convertNames") is None):
            Reflect.setField(meta,"convertNames",hx_strings_Strings.toLowerHyphen)
        if (Reflect.field(meta,"getterPrefix") is None):
            Reflect.setField(meta,"getterPrefix","get-")
        if (Reflect.field(meta,"setterPrefix") is None):
            Reflect.setField(meta,"setterPrefix","set-")
        if (Reflect.field(meta,"sideEffectSuffix") is None):
            Reflect.setField(meta,"sideEffectSuffix","!")
        if (Reflect.field(meta,"predicateSuffix") is None):
            Reflect.setField(meta,"predicateSuffix","?")
        if (Reflect.field(meta,"conversionInfix") is None):
            Reflect.setField(meta,"conversionInfix","->")
hiss_ClassMetaTools._hx_class = hiss_ClassMetaTools


class hiss_RefBool:
    _hx_class_name = "hiss.RefBool"
    __slots__ = ("b",)
    _hx_fields = ["b"]

    def __init__(self):
        self.b = False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
hiss_RefBool._hx_class = hiss_RefBool


class hiss_HaxeTools:
    _hx_class_name = "hiss.HaxeTools"
    __slots__ = ()
    _hx_statics = ["callMethod", "print", "println", "shellCommand"]

    @staticmethod
    def callMethod(object,method,args,onError):
        try:
            return Reflect.callMethod(object,method,args)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hiss_HSignal):
                signal = _g1
                raise haxe_Exception.thrown(signal)
            else:
                err = _g1
                onError(err)
                return None

    @staticmethod
    def print(_hx_str):
        python_Lib.printString(Std.string(_hx_str))

    @staticmethod
    def println(_hx_str):
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    @staticmethod
    def shellCommand(cmd):
        process = sys_io_Process(cmd)
        if (process.exitCode() != 0):
            message = process.stderr.readAll().toString()
            raise haxe_Exception.thrown(((("Shell command error from `" + ("null" if cmd is None else cmd)) + "`: ") + ("null" if message is None else message)))
        result = process.stdout.readAll()
        process.close()
        return StringTools.trim(result.toString())
hiss_HaxeTools._hx_class = hiss_HaxeTools


class hiss_HissReader:
    _hx_class_name = "hiss.HissReader"
    __slots__ = ("readTable", "macroLengths", "interp", "terminators")
    _hx_fields = ["readTable", "macroLengths", "interp", "terminators"]
    _hx_methods = ["copyReadtable", "useReadtable", "setMacroString", "setDefaultReadFunction", "hissReadFunction", "internalSetMacroString", "readQuoteExpression", "readNumber", "readSymbolOrSign", "readBlockComment", "readLineComment", "readRawString", "readString", "nextToken", "readSymbol", "readDelimitedList", "callReadFunction", "read", "readAll"]
    _hx_statics = ["toStream"]

    def __init__(self,interp):
        self.terminators = [")", "/*", ";", "//"]
        self.macroLengths = []
        self.interp = interp
        self.readTable = hiss_HDict(interp)
        self.setDefaultReadFunction(self.hissReadFunction(self.readSymbol,"read-symbol"))
        self.internalSetMacroString("\"",self.readString)
        self.internalSetMacroString("#",self.readRawString)
        numberChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0x", "0X"]
        _g = 0
        while (_g < len(numberChars)):
            s = (numberChars[_g] if _g >= 0 and _g < len(numberChars) else None)
            _g = (_g + 1)
            self.internalSetMacroString(s,self.readNumber)
        self.internalSetMacroString("-",self.readSymbolOrSign)
        self.internalSetMacroString("+",self.readSymbolOrSign)
        self.internalSetMacroString(".",self.readSymbolOrSign)
        _g = self.readDelimitedList
        terminator = ")"
        delimiters = []
        eofTerminates = False
        blankElements = None
        def _hx_local_1(start,stream):
            return _g(terminator,delimiters,eofTerminates,blankElements,start,stream)
        self.internalSetMacroString("(",_hx_local_1)
        symbol = "`"
        self.internalSetMacroString(symbol,self.readQuoteExpression)
        symbol = "'"
        self.internalSetMacroString(symbol,self.readQuoteExpression)
        symbol = ","
        self.internalSetMacroString(symbol,self.readQuoteExpression)
        symbol = ",@"
        self.internalSetMacroString(symbol,self.readQuoteExpression)
        self.internalSetMacroString("/*",self.readBlockComment)
        self.internalSetMacroString("//",self.readLineComment)
        self.internalSetMacroString(";",self.readLineComment)

    def copyReadtable(self):
        return self.readTable.copy()

    def useReadtable(self,table):
        self.readTable = table

    def setMacroString(self,s,f):
        self.readTable.put_hd(hiss_HValue.String(s),f)
        if (python_internal_ArrayImpl.indexOf(self.macroLengths,len(s),None) == -1):
            _this = self.macroLengths
            x = len(s)
            _this.append(x)
        def _hx_local_0(a,b):
            return (b - a)
        self.macroLengths.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        return f

    def setDefaultReadFunction(self,f):
        self.readTable.put_hd(hiss_HValue.String(""),f)

    def hissReadFunction(self,f,s):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(args,env,cc):
                start = hiss_HissTools.toHaxeString(hiss_HissTools.first(args))
                _hx_str = hiss_HissReader.toStream(_gthis.interp,hiss_HissTools.second(args))
                cc(f(start,_hx_str))
            return hiss_HValue.Function(_hx_local_0,_hx_AnonObject({'name': s, 'argNames': ["start", "stream"]}))
        return _hx_local_1()

    def internalSetMacroString(self,s,f):
        self.readTable.put_hd(hiss_HValue.String(s),self.hissReadFunction(f,("read-" + ("null" if s is None else s))))
        if (python_internal_ArrayImpl.indexOf(self.macroLengths,len(s),None) == -1):
            _this = self.macroLengths
            x = len(s)
            _this.append(x)
        def _hx_local_0(a,b):
            return (b - a)
        self.macroLengths.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))

    def readQuoteExpression(self,start,stream):
        expression = self.read("",stream)
        start1 = start
        _hx_local_0 = len(start1)
        if (_hx_local_0 == 1):
            if (start1 == "'"):
                return hiss_HValue.Quote(expression)
            elif (start1 == ","):
                return hiss_HValue.Unquote(expression)
            elif (start1 == "`"):
                return hiss_HValue.Quasiquote(expression)
            else:
                raise haxe_Exception.thrown("Not a quote expression")
        elif (_hx_local_0 == 2):
            if (start1 == ",@"):
                return hiss_HValue.UnquoteList(expression)
            else:
                raise haxe_Exception.thrown("Not a quote expression")
        else:
            raise haxe_Exception.thrown("Not a quote expression")

    def readNumber(self,start,stream):
        stream.putBack_d(start)
        token = self.nextToken(stream)
        startIndex = None
        if (((token.find(".") if ((startIndex is None)) else HxString.indexOfImpl(token,".",startIndex))) != -1):
            return hiss_HValue.Float(Std.parseFloat(token))
        else:
            return hiss_HValue.Int(Std.parseInt(token))

    def readSymbolOrSign(self,start,stream):
        if (stream.nextIsWhitespace() or stream.nextIsOneOf(self.terminators)):
            stream.putBack_d(start)
            return self.readSymbol("",stream)
        else:
            return self.readNumber(start,stream)

    def readBlockComment(self,start,stream):
        stream.takeUntil_d(["*/"])
        return hiss_HValue.Comment

    def readLineComment(self,start,stream):
        stream.takeLine_d()
        return hiss_HValue.Comment

    def readRawString(self,start,_hx_str):
        pounds = "#"
        while (_hx_str.peek(1) == "#"):
            pounds = (("null" if pounds is None else pounds) + HxOverrides.stringOrNull(_hx_str.take_d(1)))
        _hx_str.drop_d("\"")
        terminator = ("\"" + ("null" if pounds is None else pounds))
        _g = _hx_str.takeUntil_d([terminator],False,False)
        tmp = _g.index
        if (tmp == 0):
            s = _g.params[0]
            return hiss_HValue.String(s.output)
        elif (tmp == 1):
            raise haxe_Exception.thrown(((("Expected closing " + ("null" if terminator is None else terminator)) + " for read-raw-string of ") + Std.string(_hx_str)))
        else:
            pass

    def readString(self,start,_hx_str):
        literal = ""
        while True:
            outputInfo = None
            _g = _hx_str.takeUntil_d(["\"", "\\$", "$", "\\\\"],False,True,False)
            if (_g.index == 0):
                o = _g.params[0]
                outputInfo = o
            else:
                v = Std.string(_hx_str.takeUntil_d(["\"", "\\$", "$", "\\\\"],False,True,False))
                raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
            _g1 = outputInfo.terminator
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 1):
                if (_g1 == "\""):
                    literal = (("null" if literal is None else literal) + HxOverrides.stringOrNull(outputInfo.output))
                    _hx_str.drop_d(outputInfo.terminator)
                    break
                elif (_g1 == "$"):
                    literal = (("null" if literal is None else literal) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(outputInfo.output) + HxOverrides.stringOrNull(outputInfo.terminator)))))
                    _hx_str.drop_d(outputInfo.terminator)
                    expStream = _hx_str.copy()
                    exp = None
                    expLength = -1
                    startingLength = expStream.length()
                    if (expStream.peek(1) == "{"):
                        expStream.drop_d("{")
                        _g2 = expStream.takeUntil_d(["}"],False,False,True)
                        braceContents = None
                        if (_g2.index == 0):
                            o1 = _g2.params[0]
                            braceContents = o1
                        else:
                            v1 = Std.string(expStream.takeUntil_d(["}"],False,False,True))
                            raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v1 is None else v1)) + "`"))
                        braceContents1 = braceContents.output
                        expStream = hiss_HStream.FromString(braceContents1)
                        expLength = (2 + expStream.length())
                        exp = self.read("",expStream)
                    else:
                        exp = self.read("",expStream)
                        expLength = (startingLength - expStream.length())
                    if (exp.index == 2):
                        name = exp.params[0]
                        index = (len(name) - 1)
                        if ((("" if (((index < 0) or ((index >= len(name))))) else name[index])) == "\""):
                            expLength = (expLength - 1)
                    literal = (("null" if literal is None else literal) + HxOverrides.stringOrNull(_hx_str.take_d(expLength)))
            elif (_hx_local_0 == 2):
                if (_g1 == "\\$"):
                    literal = (("null" if literal is None else literal) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(outputInfo.output) + HxOverrides.stringOrNull(outputInfo.terminator)))))
                    _hx_str.drop_d(outputInfo.terminator)
                elif (_g1 == "\\\\"):
                    literal = (("null" if literal is None else literal) + "\\")
                    _hx_str.drop_d(outputInfo.terminator)
            else:
                pass
        escaped = literal
        escaped = hx_strings_Strings.replaceAll(escaped,"\\t","\t")
        escaped = hx_strings_Strings.replaceAll(escaped,"\\n","\n")
        escaped = hx_strings_Strings.replaceAll(escaped,"\\r","\r")
        escaped = hx_strings_Strings.replaceAll(escaped,"\\\"","\"")
        return hiss_HValue.InterpString(escaped)

    def nextToken(self,_hx_str):
        _hx_str.dropWhitespace_d()
        whitespaceOrTerminator = (hiss_HStream._WHITESPACE + self.terminators)
        token = None
        try:
            _g = _hx_str.takeUntil_d(whitespaceOrTerminator,True,False,False)
            token1 = None
            if (_g.index == 0):
                s = _g.params[0]
                token1 = s
            else:
                v = Std.string(_hx_str.takeUntil_d(whitespaceOrTerminator,True,False,False))
                raise haxe_Exception.thrown((((("extraction to `" + "next token") + "` failed on `") + ("null" if v is None else v)) + "`"))
            token = token1.output
        except BaseException as _g:
            None
            token = ""
        if (token == ""):
            raise haxe_Exception.thrown("nextToken() called without a next token in the stream")
        return token

    def readSymbol(self,start,_hx_str):
        if (_hx_str.peek(1) == ")"):
            raise haxe_Exception.thrown("Unmatched closing paren")
        symbolName = self.nextToken(_hx_str)
        tmp = None
        startIndex = None
        if (((symbolName.find("{") if ((startIndex is None)) else HxString.indexOfImpl(symbolName,"{",startIndex))) == -1):
            startIndex = None
            tmp = (((symbolName.find("}") if ((startIndex is None)) else HxString.indexOfImpl(symbolName,"}",startIndex))) != -1)
        else:
            tmp = True
        if tmp:
            raise haxe_Exception.thrown(("Cannot have braces in symbol " + ("null" if symbolName is None else symbolName)))
        if (symbolName == "nil"):
            return hiss_HValue.Nil
        if (symbolName == "null"):
            return hiss_HValue.Null
        if (symbolName == "t"):
            return hiss_HValue.T
        return hiss_HValue.Symbol(symbolName)

    def readDelimitedList(self,terminator,delimiters,eofTerminates,blankElements = None,start = None,stream = None):
        oldTerminators = list(self.terminators)
        whitespaceForThesePurposes = list(hiss_HStream._WHITESPACE)
        python_internal_ArrayImpl.remove(whitespaceForThesePurposes,terminator)
        if (len(delimiters) == 0):
            delimiters = list(hiss_HStream._WHITESPACE)
        else:
            delimiters = list(delimiters)
            self.terminators = (self.terminators + delimiters)
        _this = self.terminators
        _this.append(terminator)
        values = []
        while ((stream.length() >= len(terminator)) and ((stream.peek(len(terminator)) != terminator))):
            if ((stream.nextIsOneOf(delimiters) or stream.nextIsOneOf([terminator])) or ((eofTerminates and stream.isEmpty()))):
                if (blankElements != hiss_HValue.Null):
                    values.append(blankElements)
            else:
                x = self.read("",stream)
                values.append(x)
            stream.dropIfOneOf_d(delimiters)
            stream.dropWhileOneOf_d(whitespaceForThesePurposes)
        if (not ((eofTerminates and stream.isEmpty()))):
            try:
                stream.drop_d(terminator)
            except BaseException as _g:
                None
                raise haxe_Exception.thrown(((((("terminator " + ("null" if terminator is None else terminator)) + " not found while reading ") + Std.string(delimiters)) + " delimited list from ") + Std.string(stream)))
        self.terminators = oldTerminators
        return hiss_HValue.List(values)

    def callReadFunction(self,func,start,stream):
        pos = stream._position()
        startingStream = stream.toString()
        try:
            result = self.interp.eval(hiss_Stdlib.cons_h(func,hiss_HValue.List([hiss_HValue.String(start), hiss_HValue.Object("HStream",stream)])))
            return result
        except BaseException as _g:
            None
            s = haxe_Exception.caught(_g).unwrap()
            endingStream = stream.toString()
            consumed = HxString.substr(startingStream,0,(len(startingStream) - len(endingStream)))
            if (Reflect.field(s,"indexOf")("Reader error") == 0):
                raise haxe_Exception.thrown(s)
            raise haxe_Exception.thrown(((((("Reader error `" + Std.string(s)) + "` after taking `") + ("null" if consumed is None else consumed)) + "` at ") + HxOverrides.stringOrNull(pos.toString())))

    def read(self,start,stream):
        stream.dropWhitespace_d()
        _g = 0
        _g1 = self.macroLengths
        while (_g < len(_g1)):
            length = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (stream.length() < length):
                continue
            couldBeAMacro = stream.peek(length)
            if self.readTable.exists_h(hiss_HValue.String(couldBeAMacro)):
                stream.drop_d(couldBeAMacro)
                pos = stream._position()
                expression = None
                expression = self.callReadFunction(self.readTable.get_h(hiss_HValue.String(couldBeAMacro)),couldBeAMacro,stream)
                if (expression.index == 18):
                    if stream.isEmpty():
                        return hiss_HValue.Nil
                    else:
                        return self.read("",stream)
                else:
                    return expression
        return self.callReadFunction(self.readTable.get_h(hiss_HValue.String("")),"",stream)

    def readAll(self,_hx_str,dropWhitespace = None,terminators = None,pos = None):
        stream = hiss_HissReader.toStream(self.interp,_hx_str,pos)
        if (dropWhitespace is None):
            dropWhitespace = hiss_HValue.T
        exprs = []
        while (not stream.isEmpty()):
            x = self.read("",stream)
            exprs.append(x)
            if (dropWhitespace != hiss_HValue.Nil):
                stream.dropWhitespace_d()
        return hiss_HValue.List(exprs)

    @staticmethod
    def toStream(interp,stringOrStream,pos = None):
        position = (hiss_HissTools.value(pos,interp) if ((pos is not None)) else None)
        tmp = stringOrStream.index
        if (tmp == 4):
            s = stringOrStream.params[0]
            return hiss_HStream.FromString(s,position)
        elif (tmp == 13):
            if (stringOrStream.params[0] == "HStream"):
                v = stringOrStream.params[1]
                return v
            else:
                raise haxe_Exception.thrown(("Cannot make an hstream out of " + Std.string(stringOrStream)))
        else:
            raise haxe_Exception.thrown(("Cannot make an hstream out of " + Std.string(stringOrStream)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.readTable = None
        _hx_o.macroLengths = None
        _hx_o.interp = None
        _hx_o.terminators = None
hiss_HissReader._hx_class = hiss_HissReader


class utest_ui_common_IReport:
    _hx_class_name = "utest.ui.common.IReport"
    __slots__ = ("displaySuccessResults", "displayHeader")
    _hx_fields = ["displaySuccessResults", "displayHeader"]
    _hx_methods = ["setHandler"]
utest_ui_common_IReport._hx_class = utest_ui_common_IReport


class utest_ui_text_PlainTextReport:
    _hx_class_name = "utest.ui.text.PlainTextReport"
    __slots__ = ("displaySuccessResults", "displayHeader", "handler", "aggregator", "newline", "indent", "startTime", "result")
    _hx_fields = ["displaySuccessResults", "displayHeader", "handler", "aggregator", "newline", "indent", "startTime", "result"]
    _hx_methods = ["setHandler", "start", "getTime", "indents", "dumpStack", "addHeader", "getResults", "complete"]
    _hx_interfaces = [utest_ui_common_IReport]

    def __init__(self,runner,outputHandler = None):
        self.result = None
        self.startTime = None
        self.indent = None
        self.newline = None
        self.handler = None
        self.displayHeader = None
        self.displaySuccessResults = None
        self.aggregator = utest_ui_common_ResultAggregator(runner,True)
        runner.onStart.add(self.start)
        self.aggregator.onComplete.add(self.complete)
        if (None != outputHandler):
            self.setHandler(outputHandler)
        self.displaySuccessResults = utest_ui_common_SuccessResultsDisplayMode.AlwaysShowSuccessResults
        self.displayHeader = utest_ui_common_HeaderDisplayMode.AlwaysShowHeader

    def setHandler(self,handler):
        self.handler = handler

    def start(self,e):
        self.startTime = self.getTime()

    def getTime(self):
        return python_lib_Timeit.default_timer()

    def indents(self,c):
        s = ""
        while True:
            c = (c - 1)
            tmp = c
            if (not ((tmp >= 0))):
                break
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(self.indent))
        return s

    def dumpStack(self,stack):
        if (len(stack) == 0):
            return ""
        _this = haxe__CallStack_CallStack_Impl_.toString(stack)
        parts = _this.split("\n")
        r = []
        _g = 0
        while (_g < len(parts)):
            part = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            startIndex = None
            if (((part.find(" utest.") if ((startIndex is None)) else HxString.indexOfImpl(part," utest.",startIndex))) >= 0):
                continue
            r.append(part)
        return self.newline.join([python_Boot.toString1(x1,'') for x1 in r])

    def addHeader(self,buf,result):
        if (not utest_ui_common_ReportTools.hasHeader(self,result.stats)):
            return
        end = self.getTime()
        x = (((end - self.startTime)) * 1000)
        time = None
        try:
            time = int(x)
        except BaseException as _g:
            None
            time = None
        time1 = (time / 1000)
        s = Std.string((("\nassertations: " + Std.string(result.stats.assertations)) + HxOverrides.stringOrNull(self.newline)))
        buf.b.write(s)
        s = Std.string((("successes: " + Std.string(result.stats.successes)) + HxOverrides.stringOrNull(self.newline)))
        buf.b.write(s)
        s = Std.string((("errors: " + Std.string(result.stats.errors)) + HxOverrides.stringOrNull(self.newline)))
        buf.b.write(s)
        s = Std.string((("failures: " + Std.string(result.stats.failures)) + HxOverrides.stringOrNull(self.newline)))
        buf.b.write(s)
        s = Std.string((("warnings: " + Std.string(result.stats.warnings)) + HxOverrides.stringOrNull(self.newline)))
        buf.b.write(s)
        s = Std.string((("execution time: " + Std.string(time1)) + HxOverrides.stringOrNull(self.newline)))
        buf.b.write(s)
        s = Std.string(self.newline)
        buf.b.write(s)
        s = Std.string(("results: " + HxOverrides.stringOrNull((("ALL TESTS OK (success: true)" if (result.stats.isOk) else "SOME TESTS FAILURES (success: false)")))))
        buf.b.write(s)
        s = Std.string(self.newline)
        buf.b.write(s)

    def getResults(self):
        buf = StringBuf()
        self.addHeader(buf,self.result)
        _g = 0
        _g1 = self.result.packageNames()
        while (_g < len(_g1)):
            pname = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            pack = self.result.getPackage(pname)
            if utest_ui_common_ReportTools.skipResult(self,pack.stats,self.result.stats.isOk):
                continue
            _g2 = 0
            _g3 = pack.classNames()
            while (_g2 < len(_g3)):
                cname = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                cls = pack.getClass(cname)
                if utest_ui_common_ReportTools.skipResult(self,cls.stats,self.result.stats.isOk):
                    continue
                s = Std.string(((HxOverrides.stringOrNull((("" if ((pname == "")) else (("null" if pname is None else pname) + ".")))) + ("null" if cname is None else cname)) + HxOverrides.stringOrNull(self.newline)))
                buf.b.write(s)
                _g4 = 0
                _g5 = cls.methodNames()
                while (_g4 < len(_g5)):
                    mname = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                    _g4 = (_g4 + 1)
                    fix = cls.get(mname)
                    if utest_ui_common_ReportTools.skipResult(self,fix.stats,self.result.stats.isOk):
                        continue
                    s1 = Std.string(((HxOverrides.stringOrNull(self.indents(1)) + ("null" if mname is None else mname)) + ": "))
                    buf.b.write(s1)
                    if fix.stats.isOk:
                        buf.b.write("OK ")
                    elif fix.stats.hasErrors:
                        buf.b.write("ERROR ")
                    elif fix.stats.hasFailures:
                        buf.b.write("FAILURE ")
                    elif fix.stats.hasWarnings:
                        buf.b.write("WARNING ")
                    messages = ""
                    _g6 = fix.iterator()
                    while (_g6.head is not None):
                        val = _g6.head.item
                        _g6.head = _g6.head.next
                        assertation = val
                        tmp = assertation.index
                        if (tmp == 0):
                            _g7 = assertation.params[0]
                            buf.b.write(".")
                        elif (tmp == 1):
                            pos = assertation.params[1]
                            msg = assertation.params[0]
                            buf.b.write("F")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull(((((((HxOverrides.stringOrNull(self.indents(2)) + "line: ") + Std.string(pos.lineNumber)) + ", ") + ("null" if msg is None else msg)) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 2):
                            s2 = assertation.params[1]
                            e = assertation.params[0]
                            buf.b.write("E")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull(((((HxOverrides.stringOrNull(self.indents(2)) + Std.string(e)) + HxOverrides.stringOrNull(self.dumpStack(s2))) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 3):
                            s3 = assertation.params[1]
                            e1 = assertation.params[0]
                            buf.b.write("S")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull(((((HxOverrides.stringOrNull(self.indents(2)) + Std.string(e1)) + HxOverrides.stringOrNull(self.dumpStack(s3))) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 4):
                            s4 = assertation.params[1]
                            e2 = assertation.params[0]
                            buf.b.write("T")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull(((((HxOverrides.stringOrNull(self.indents(2)) + Std.string(e2)) + HxOverrides.stringOrNull(self.dumpStack(s4))) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 5):
                            s5 = assertation.params[1]
                            missedAsyncs = assertation.params[0]
                            buf.b.write("O")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull((((((HxOverrides.stringOrNull(self.indents(2)) + "missed async calls: ") + Std.string(missedAsyncs)) + HxOverrides.stringOrNull(self.dumpStack(s5))) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 6):
                            s6 = assertation.params[1]
                            e3 = assertation.params[0]
                            buf.b.write("A")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull(((((HxOverrides.stringOrNull(self.indents(2)) + Std.string(e3)) + HxOverrides.stringOrNull(self.dumpStack(s6))) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 7):
                            msg1 = assertation.params[0]
                            buf.b.write("W")
                            messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(self.indents(2)) + ("null" if msg1 is None else msg1)) + HxOverrides.stringOrNull(self.newline)))))
                        elif (tmp == 8):
                            reason = assertation.params[0]
                            buf.b.write("I")
                            if ((reason is not None) and ((reason != ""))):
                                messages = (("null" if messages is None else messages) + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(self.indents(2)) + HxOverrides.stringOrNull((("With reason: " + ("null" if reason is None else reason))))) + HxOverrides.stringOrNull(self.newline)))))
                        else:
                            pass
                    s7 = Std.string(self.newline)
                    buf.b.write(s7)
                    s8 = Std.string(messages)
                    buf.b.write(s8)
        return buf.b.getvalue()

    def complete(self,result):
        self.result = result
        if (self.handler is not None):
            self.handler(self)
        Sys.exit((0 if (result.stats.isOk) else 1))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.displaySuccessResults = None
        _hx_o.displayHeader = None
        _hx_o.handler = None
        _hx_o.aggregator = None
        _hx_o.newline = None
        _hx_o.indent = None
        _hx_o.startTime = None
        _hx_o.result = None
utest_ui_text_PlainTextReport._hx_class = utest_ui_text_PlainTextReport


class utest_ui_text_PrintReport(utest_ui_text_PlainTextReport):
    _hx_class_name = "utest.ui.text.PrintReport"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["_handler", "_trace"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = utest_ui_text_PlainTextReport


    def __init__(self,runner):
        super().__init__(runner,self._handler)
        self.newline = "\n"
        self.indent = "  "

    def _handler(self,report):
        self._trace(report.getResults())

    def _trace(self,s):
        s = StringTools.replace(s,"  ",self.indent)
        s = StringTools.replace(s,"\n",self.newline)
        haxe_Log.trace(s,_hx_AnonObject({'fileName': "utest/ui/text/PrintReport.hx", 'lineNumber': 52, 'className': "utest.ui.text.PrintReport", 'methodName': "_trace"}))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
utest_ui_text_PrintReport._hx_class = utest_ui_text_PrintReport


class hiss_NoExitReport(utest_ui_text_PrintReport):
    _hx_class_name = "hiss.NoExitReport"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["complete"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = utest_ui_text_PrintReport


    def __init__(self,runner):
        super().__init__(runner)

    def complete(self,result):
        self.result = result
        if (self.handler is not None):
            self.handler(self)
        if (not result.stats.isOk):
            Sys.exit(1)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hiss_NoExitReport._hx_class = hiss_NoExitReport


class utest_ITest:
    _hx_class_name = "utest.ITest"
    __slots__ = ()
utest_ITest._hx_class = utest_ITest


class utest_Test:
    _hx_class_name = "utest.Test"
    __slots__ = ()
    _hx_methods = ["__initializeUtest__"]
    _hx_interfaces = [utest_ITest]

    def __init__(self):
        pass

    def __initializeUtest__(self):
        init = _hx_AnonObject({'tests': [], 'accessories': _hx_AnonObject({})})
        return init

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
utest_Test._hx_class = utest_Test


class hiss_HissTestCase(utest_Test):
    _hx_class_name = "hiss.HissTestCase"
    __slots__ = ("interp", "file", "ignoreFunctions", "expressions", "requireCoverage")
    _hx_fields = ["interp", "file", "ignoreFunctions", "expressions", "requireCoverage"]
    _hx_methods = ["testStdlib", "__initializeUtest__"]
    _hx_statics = ["functionsTested", "printTestCommands", "testAtRuntime", "reallyTrace", "hissTest", "hissPrints", "hissPrintFail", "tempTrace", "failOnTrace", "enableTrace"]
    _hx_interfaces = []
    _hx_super = utest_Test


    def __init__(self,hissFile,requireCoverage = None):
        if (requireCoverage is None):
            requireCoverage = False
        self.requireCoverage = None
        self.file = None
        self.interp = None
        self.expressions = None
        self.ignoreFunctions = []
        super().__init__()
        self.file = hissFile
        self.requireCoverage = requireCoverage
        hiss_HissTestCase.reallyTrace = haxe_Log.trace
        haxe_Log.trace("Measuring time to construct the Hiss environment:",_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 77, 'className': "hiss.HissTestCase", 'methodName': "new"}))
        def _hx_local_0():
            hiss_HissTestCase.failOnTrace()
            i = hiss_CCInterp(hiss_HissTestCase.hissPrintFail)
            hiss_HissTestCase.enableTrace(i)
            return i
        self.interp = haxe_Timer.measure(_hx_local_0,_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 78, 'className': "hiss.HissTestCase", 'methodName': "new"}))

    def testStdlib(self):
        _gthis = self
        if (self.file is None):
            hiss_HissTestCase.hissTest(self.interp,self.expressions,self.interp.emptyEnv(),hiss_CCInterp.noCC)
        else:
            _g = hiss_HissTools.toDict(self.interp.globals).keyValueIterator()
            while _g.hasNext():
                _g1 = _g.next()
                v = _g1.key
                val = _g1.value
                tmp = val.index
                if (tmp == 10):
                    _g2 = val.params[0]
                    meta = val.params[1]
                    tmp1 = None
                    if (not Reflect.field(meta,"deprecated")):
                        this1 = hiss_HissTestCase.functionsTested
                        tmp1 = (not (hiss_Stdlib.symbolName_h(v) in this1.h))
                    else:
                        tmp1 = False
                    if tmp1:
                        this2 = hiss_HissTestCase.functionsTested
                        k = hiss_Stdlib.symbolName_h(v)
                        this2.h[k] = False
                elif (tmp == 11):
                    _g3 = val.params[0]
                    meta1 = val.params[1]
                    tmp2 = None
                    if (not Reflect.field(meta1,"deprecated")):
                        this3 = hiss_HissTestCase.functionsTested
                        tmp2 = (not (hiss_Stdlib.symbolName_h(v) in this3.h))
                    else:
                        tmp2 = False
                    if tmp2:
                        this4 = hiss_HissTestCase.functionsTested
                        k1 = hiss_Stdlib.symbolName_h(v)
                        this4.h[k1] = False
                elif (tmp == 12):
                    _g4 = val.params[0]
                    meta2 = val.params[1]
                    tmp3 = None
                    if (not Reflect.field(meta2,"deprecated")):
                        this5 = hiss_HissTestCase.functionsTested
                        tmp3 = (not (hiss_Stdlib.symbolName_h(v) in this5.h))
                    else:
                        tmp3 = False
                    if tmp3:
                        this6 = hiss_HissTestCase.functionsTested
                        k2 = hiss_Stdlib.symbolName_h(v)
                        this6.h[k2] = False
                else:
                    pass
            interp = self.interp
            def _hx_local_0(args,env,cc):
                hiss_HissTestCase.hissTest(interp,args,env,cc)
            tmp = hiss_HValue.SpecialForm(_hx_local_0,_hx_AnonObject({'name': "test!"}))
            hiss_HissTools.put(self.interp.globals,"test!",tmp)
            self.interp.defDestructiveAlias("test!","!")
            interp1 = self.interp
            def _hx_local_1(args,env,cc):
                hiss_HissTestCase.hissPrints(interp1,args,env,cc)
            tmp = hiss_HValue.SpecialForm(_hx_local_1,_hx_AnonObject({'name': "prints"}))
            hiss_HissTools.put(self.interp.globals,"prints",tmp)
            _g = 0
            _g1 = self.ignoreFunctions
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                hiss_HissTestCase.functionsTested.h[f] = True
            haxe_Log.trace("Measuring time taken to run the unit tests:",_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 264, 'className': "hiss.HissTestCase", 'methodName': "testStdlib"}))
            def _hx_local_3():
                _gthis.interp.load(_gthis.file)
                haxe_Log.trace("Total time to run tests:",_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 268, 'className': "hiss.HissTestCase", 'methodName': "testStdlib"}))
            haxe_Timer.measure(_hx_local_3,_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 266, 'className': "hiss.HissTestCase", 'methodName': "testStdlib"}))
            _g = []
            _g1 = haxe_iterators_MapKeyValueIterator(hiss_HissTestCase.functionsTested)
            while _g1.hasNext():
                _g2 = _g1.next()
                fun = _g2.key
                tested = _g2.value
                if ((not tested) and (not fun.startswith("_"))):
                    _g.append(fun)
            functionsNotTested = _g
            if (self.requireCoverage and ((len(functionsNotTested) != 0))):
                utest_Assert.fail(("These functions were never tested: " + Std.string(functionsNotTested)),_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 274, 'className': "hiss.HissTestCase", 'methodName': "testStdlib"}))

    def __initializeUtest__(self):
        _gthis = self
        init = super().__initializeUtest__()
        _this = init.tests
        def _hx_local_0():
            _gthis.testStdlib()
            return utest_Async.getResolved()
        _this.append(_hx_AnonObject({'name': "testStdlib", 'execute': _hx_local_0}))
        return init

    @staticmethod
    def testAtRuntime(interp,args,env,cc):
        instance = hiss_HissTestCase(None)
        instance.interp = interp
        instance.expressions = args
        runner = utest_Runner()
        runner.addCase(instance)
        hiss_NoExitReport(runner)
        runner.run()
        cc(hiss_HValue.Nil)

    @staticmethod
    def hissTest(interp,args,env,cc):
        hiss_HissTestCase.failOnTrace(interp)
        functionsCoveredByUnit = None
        _g = hiss_HissTools.first(args)
        functionsCoveredByUnit1 = _g.index
        if (functionsCoveredByUnit1 == 2):
            name = _g.params[0]
            functionsCoveredByUnit = [name]
        elif (functionsCoveredByUnit1 == 3):
            _g1 = _g.params[0]
            functionsCoveredByUnit = []
        elif (functionsCoveredByUnit1 == 4):
            _g1 = _g.params[0]
            functionsCoveredByUnit = []
        elif (functionsCoveredByUnit1 == 8):
            symbols = _g.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(symbols)):
                symbol = (symbols[_g1] if _g1 >= 0 and _g1 < len(symbols) else None)
                _g1 = (_g1 + 1)
                x = hiss_Stdlib.symbolName_h(symbol)
                _g.append(x)
            functionsCoveredByUnit = _g
        else:
            raise haxe_Exception.thrown("Bad syntax for (test) statement")
        if hiss_HissTestCase.printTestCommands:
            _hx_str = Std.string((("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in functionsCoveredByUnit]))) + "]"))
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        assertions = hiss_Stdlib.rest_h(args)
        freshEnv = interp.emptyEnv()
        _g = 0
        _g1 = hiss_HissTools.toList(assertions)
        while (_g < len(_g1)):
            ass = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            failureMessage = [(((("Failure testing " + Std.string(functionsCoveredByUnit)) + ": ") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(ass))) + " evaluated to: ")]
            errorMessage = (((("Error testing " + Std.string(functionsCoveredByUnit)) + ": ") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(ass))) + ": ")
            def _hx_local_3(failureMessage):
                def _hx_local_2(val):
                    utest_Assert.isTrue(interp.truthy(val),(HxOverrides.stringOrNull((failureMessage[0] if 0 < len(failureMessage) else None)) + HxOverrides.stringOrNull(hiss_HissTools.toPrint(val))),_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 125, 'className': "hiss.HissTestCase", 'methodName': "hissTest"}))
                return _hx_local_2
            try:
                interp.evalCC(ass,_hx_local_3(failureMessage),freshEnv)
            except BaseException as _g2:
                None
                err = haxe_Exception.caught(_g2).unwrap()
                utest_Assert.fail((("null" if errorMessage is None else errorMessage) + Std.string(Reflect.field(err,"toString")())),_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 130, 'className': "hiss.HissTestCase", 'methodName': "hissTest"}))
        _g = 0
        while (_g < len(functionsCoveredByUnit)):
            fun = (functionsCoveredByUnit[_g] if _g >= 0 and _g < len(functionsCoveredByUnit) else None)
            _g = (_g + 1)
            hiss_HissTestCase.functionsTested.h[fun] = True
        hiss_HissTestCase.enableTrace(interp)
        cc(hiss_HValue.Nil)

    @staticmethod
    def hissPrints(interp,args,env,cc):
        expectedPrint = hiss_HissTools.toHaxeString(interp.eval(hiss_HissTools.first(args),env))
        expression = hiss_HissTools.second(args)
        actualPrint = ""
        def _hx_local_1(val):
            nonlocal actualPrint
            actualPrint = (("null" if actualPrint is None else actualPrint) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(hiss_HissTools.toPrint(val)) + "\n"))))
            return actualPrint
        interp.importFunction(hiss_HissTestCase,_hx_local_1,_hx_AnonObject({'name': "print"}),hiss_HValue.T)
        def _hx_local_3(val):
            nonlocal actualPrint
            actualPrint = (("null" if actualPrint is None else actualPrint) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(hiss_HissTools.toPrint(val)) + "\n"))))
            return actualPrint
        interp.importFunction(hiss_HissTestCase,_hx_local_3,_hx_AnonObject({'name': "print!"}),hiss_HValue.T)
        def _hx_local_5(val):
            nonlocal actualPrint
            actualPrint = (("null" if actualPrint is None else actualPrint) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(hiss_HissTools.toMessage(val)) + "\n"))))
            return actualPrint
        interp.importFunction(hiss_HissTestCase,_hx_local_5,_hx_AnonObject({'name': "message"}),hiss_HValue.T)
        def _hx_local_7(val):
            nonlocal actualPrint
            actualPrint = (("null" if actualPrint is None else actualPrint) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(hiss_HissTools.toMessage(val)) + "\n"))))
            return actualPrint
        interp.importFunction(hiss_HissTestCase,_hx_local_7,_hx_AnonObject({'name': "message!"}),hiss_HValue.T)
        interp.eval(expression,env)
        interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,_hx_AnonObject({'name': "print"}),hiss_HValue.T)
        interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,_hx_AnonObject({'name': "print!"}),hiss_HValue.T)
        interp.importFunction(hiss_HissTools,hiss_Stdlib.message_hd,_hx_AnonObject({'name': "message"}),hiss_HValue.T)
        interp.importFunction(hiss_HissTools,hiss_Stdlib.message_hd,_hx_AnonObject({'name': "message!"}),hiss_HValue.T)
        tmp = None
        tmp1 = None
        if (expectedPrint != actualPrint):
            index = (len(actualPrint) - 1)
            tmp1 = (((("" if (((index < 0) or ((index >= len(actualPrint))))) else actualPrint[index])) == "\n") and ((expectedPrint == HxString.substr(actualPrint,0,(len(actualPrint) - 1)))))
        else:
            tmp1 = True
        if tmp1:
            tmp = hiss_HValue.T
        else:
            haxe_Log.trace((((("\"" + ("null" if actualPrint is None else actualPrint)) + "\" != \"") + ("null" if expectedPrint is None else expectedPrint)) + "\""),_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 178, 'className': "hiss.HissTestCase", 'methodName': "hissPrints"}))
            tmp = hiss_HValue.Nil
        cc(tmp)

    @staticmethod
    def hissPrintFail(v):
        if (not hiss_HissTestCase.printTestCommands):
            utest_Assert.fail((("Tried to print " + HxOverrides.stringOrNull(hiss_HissTools.toPrint(v))) + " unnecessarily"),_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 188, 'className': "hiss.HissTestCase", 'methodName': "hissPrintFail"}))
        else:
            _hx_str = Std.string(hiss_HissTools.toPrint(v))
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        return v

    @staticmethod
    def failOnTrace(interp = None):
        hiss_HissTestCase.tempTrace = haxe_Log.trace
        def _hx_local_0(_hx_str,posInfo = None):
            try:
                if (not hiss_HissTestCase.printTestCommands):
                    utest_Assert.fail((("Traced " + ("null" if _hx_str is None else _hx_str)) + " to console"),_hx_AnonObject({'fileName': "hiss/HissTestCase.hx", 'lineNumber': 212, 'className': "hiss.HissTestCase", 'methodName': "failOnTrace"}))
                else:
                    hiss_HissTestCase.tempTrace(_hx_str,posInfo)
            except BaseException as _g:
                None
                hiss_HissTestCase.tempTrace(_hx_str,posInfo)
        haxe_Log.trace = _hx_local_0
        if (interp is not None):
            interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,_hx_AnonObject({'name': "print"}),hiss_HValue.T)
            interp.importFunction(hiss_HissTestCase,hiss_HissTestCase.hissPrintFail,_hx_AnonObject({'name': "print!"}),hiss_HValue.T)

    @staticmethod
    def enableTrace(interp):
        haxe_Log.trace = hiss_HissTestCase.tempTrace
        interp.importFunction(hiss_HissTools,hiss_Stdlib.print_hd,_hx_AnonObject({'name': "print"}),hiss_HValue.T)
        interp.importFunction(hiss_HissTools,hiss_Stdlib.print_hd,_hx_AnonObject({'name': "print!"}),hiss_HValue.T)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.interp = None
        _hx_o.file = None
        _hx_o.ignoreFunctions = None
        _hx_o.expressions = None
        _hx_o.requireCoverage = None
hiss_HissTestCase._hx_class = hiss_HissTestCase


class hiss_HissTools:
    _hx_class_name = "hiss.HissTools"
    __slots__ = ()
    _hx_statics = ["get", "exists", "put", "toList", "toObject", "toCallable", "toHaxeString", "toInt", "toFloat", "toHFunction", "toDict", "first", "second", "third", "fourth", "last", "slice", "alternates", "dictExtend", "extend", "destructuringBind", "toHValue", "unwrapList", "toHList", "value", "metadata", "toPrint", "toMessage"]

    @staticmethod
    def get(_hx_dict,key):
        return hiss_HissTools.toDict(_hx_dict).get_h(hiss_HValue.Symbol(key))

    @staticmethod
    def exists(_hx_dict,key):
        return hiss_HissTools.toDict(_hx_dict).exists_h(hiss_HValue.Symbol(key))

    @staticmethod
    def put(_hx_dict,key,v):
        hiss_HissTools.toDict(_hx_dict).put_hd(hiss_HValue.Symbol(key),v)
        return _hx_dict

    @staticmethod
    def toList(_hx_list,hint = None):
        if (hint is None):
            hint = "list"
        if (_hx_list.index == 8):
            l = _hx_list.params[0]
            return l
        else:
            v = Std.string(_hx_list)
            raise haxe_Exception.thrown((((("extraction to `" + "list") + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def toObject(obj,hint = None):
        if (hint is None):
            hint = "object"
        if (obj.index == 13):
            _g = obj.params[0]
            o = obj.params[1]
            return o
        else:
            v = Std.string(obj)
            raise haxe_Exception.thrown((((("extraction to `" + "object") + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def toCallable(f,hint = None):
        if (hint is None):
            hint = "function"
        tmp = f.index
        if (tmp == 10):
            _g = f.params[1]
            hf = f.params[0]
            return hf
        elif (tmp == 11):
            _g = f.params[1]
            hf = f.params[0]
            return hf
        elif (tmp == 12):
            _g = f.params[1]
            hf = f.params[0]
            return hf
        else:
            v = Std.string(f)
            raise haxe_Exception.thrown((((("extraction to `" + ("null" if hint is None else hint)) + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def toHaxeString(hv):
        if (hv.index == 4):
            s = hv.params[0]
            return s
        else:
            v = Std.string(hv)
            raise haxe_Exception.thrown((((("extraction to `" + "string") + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def toInt(v):
        if (v.index == 0):
            i = v.params[0]
            return i
        else:
            v1 = Std.string(v)
            raise haxe_Exception.thrown((((("extraction to `" + "int") + "` failed on `") + ("null" if v1 is None else v1)) + "`"))

    @staticmethod
    def toFloat(v):
        tmp = v.index
        if (tmp == 0):
            i = v.params[0]
            return i
        elif (tmp == 1):
            f = v.params[0]
            return f
        else:
            raise haxe_Exception.thrown(("can't extract float from " + Std.string(v)))

    @staticmethod
    def toHFunction(hv):
        if (hv.index == 10):
            _g = hv.params[1]
            f = hv.params[0]
            return f
        else:
            v = Std.string(hv)
            raise haxe_Exception.thrown((((("extraction to `" + "function") + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def toDict(_hx_dict):
        if (_hx_dict.index == 9):
            h = _hx_dict.params[0]
            return h
        else:
            v = Std.string(_hx_dict)
            raise haxe_Exception.thrown((((("extraction to `" + "dict") + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def first(_hx_list):
        return python_internal_ArrayImpl._get(hiss_HissTools.toList(_hx_list), 0)

    @staticmethod
    def second(_hx_list):
        return python_internal_ArrayImpl._get(hiss_HissTools.toList(_hx_list), 1)

    @staticmethod
    def third(_hx_list):
        return python_internal_ArrayImpl._get(hiss_HissTools.toList(_hx_list), 2)

    @staticmethod
    def fourth(_hx_list):
        return python_internal_ArrayImpl._get(hiss_HissTools.toList(_hx_list), 3)

    @staticmethod
    def last(_hx_list):
        return hiss_Stdlib.nth_h(_hx_list,hiss_HValue.Int((hiss_Stdlib.length_h(_hx_list) - 1)))

    @staticmethod
    def slice(_hx_list,idx):
        return hiss_HValue.List(hiss_HissTools.toList(_hx_list)[idx:None])

    @staticmethod
    def alternates(_hx_list,start):
        result = list()
        l = list(hiss_HissTools.toList(_hx_list))
        while (len(l) > 0):
            next = (None if ((len(l) == 0)) else l.pop(0))
            if start:
                result.append(next)
            start = (not start)
        return hiss_HValue.List(result)

    @staticmethod
    def dictExtend(_hx_dict,extension):
        extended = hiss_HissTools.toDict(_hx_dict).copy()
        pair = hiss_HissTools.toDict(extension).keyValueIterator()
        while pair.hasNext():
            pair1 = pair.next()
            extended.put_hd(pair1.key,pair1.value)
        return hiss_HValue.Dict(extended)

    @staticmethod
    def extend(env,extension):
        return hiss_Stdlib.cons_h(extension,env)

    @staticmethod
    def destructuringBind(names,interp,values):
        bindings = interp.emptyDict()
        tmp = names.index
        if (tmp == 2):
            name = names.params[0]
            hiss_HissTools.put(bindings,name,values)
        elif (tmp == 8):
            l1 = names.params[0]
            l2 = hiss_HissTools.toList(values)
            _g = 0
            _g1 = len(l1)
            while (_g < _g1):
                idx = _g
                _g = (_g + 1)
                _g2 = (l1[idx] if idx >= 0 and idx < len(l1) else None)
                tmp = _g2.index
                if (tmp == 2):
                    _g3 = _g2.params[0]
                    _g4 = _g3
                    _hx_local_0 = len(_g4)
                    if (_hx_local_0 == 9):
                        if (_g4 == "&optional"):
                            endOfOptionalValues = len(l1)
                            _g5 = (idx + 1)
                            _g6 = len(l1)
                            while (_g5 < _g6):
                                idx2 = _g5
                                _g5 = (_g5 + 1)
                                if interp.truthy(hiss_Stdlib.eq_ih(interp,(l1[idx2] if idx2 >= 0 and idx2 < len(l1) else None),hiss_HValue.Symbol("&rest"))):
                                    endOfOptionalValues = idx2
                                    break
                            if (endOfOptionalValues == -1):
                                endOfOptionalValues = len(l1)
                                haxe_Log.trace("not found",_hx_AnonObject({'fileName': "hiss/HissTools.hx", 'lineNumber': 155, 'className': "hiss.HissTools", 'methodName': "destructuringBind"}))
                            numOptionalValues = ((endOfOptionalValues - idx) - 1)
                            remainingValues = l2[idx:endOfOptionalValues]
                            while (len(remainingValues) < numOptionalValues):
                                remainingValues.append(hiss_HValue.Nil)
                            bindings = hiss_HissTools.dictExtend(bindings,hiss_HissTools.destructuringBind(hiss_HValue.List(l1[(idx + 1):None]),interp,hiss_HValue.List(remainingValues)))
                            if (endOfOptionalValues != len(l1)):
                                bindings = hiss_HissTools.dictExtend(bindings,hiss_HissTools.destructuringBind(hiss_HValue.List(l1[endOfOptionalValues:None]),interp,hiss_HValue.List(l2[(endOfOptionalValues - 1):None])))
                            break
                        else:
                            name = _g3
                            hiss_HissTools.put(bindings,name,(l2[idx] if idx >= 0 and idx < len(l2) else None))
                    elif (_hx_local_0 == 5):
                        if (_g4 == "&rest"):
                            remainingValues1 = l2[idx:None]
                            hiss_HissTools.put(bindings,hiss_Stdlib.symbolName_h(python_internal_ArrayImpl._get(l1, (idx + 1))),hiss_HValue.List(remainingValues1))
                            break
                        else:
                            name = _g3
                            hiss_HissTools.put(bindings,name,(l2[idx] if idx >= 0 and idx < len(l2) else None))
                    else:
                        name = _g3
                        hiss_HissTools.put(bindings,name,(l2[idx] if idx >= 0 and idx < len(l2) else None))
                elif (tmp == 8):
                    nestedList = _g2.params[0]
                    bindings = hiss_HissTools.dictExtend(bindings,hiss_HissTools.destructuringBind((l1[idx] if idx >= 0 and idx < len(l1) else None),interp,(l2[idx] if idx >= 0 and idx < len(l2) else None)))
                else:
                    raise haxe_Exception.thrown((("Bad element " + Std.string((l1[idx] if idx >= 0 and idx < len(l1) else None))) + " in name list for bindings"))
        else:
            raise haxe_Exception.thrown(((("Cannot perform destructuring bind on " + HxOverrides.stringOrNull(hiss_HissTools.toPrint(names))) + " and ") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(values))))
        return bindings

    @staticmethod
    def toHValue(v,hint = None):
        if (hint is None):
            hint = "HValue"
        if (v is None):
            return hiss_HValue.Nil
        t = Type.typeof(v)
        tmp = t.index
        if (tmp == 1):
            return hiss_HValue.Int(v)
        elif (tmp == 2):
            return hiss_HValue.Float(v)
        elif (tmp == 3):
            if v:
                return hiss_HValue.T
            else:
                return hiss_HValue.Nil
        elif (tmp == 4):
            return hiss_HValue.Object("!ANONYMOUS!",v)
        elif (tmp == 5):
            return hiss_HValue.Object("NativeFun",v)
        elif (tmp == 6):
            c = t.params[0]
            name = Type.getClassName(c)
            name1 = name
            _hx_local_0 = len(name1)
            if (_hx_local_0 == 10):
                if (name1 == "hiss.HDict"):
                    return hiss_HValue.Dict(v)
                else:
                    return hiss_HValue.Object(name,v)
            elif (_hx_local_0 == 5):
                if (name1 == "Array"):
                    def _hx_local_2():
                        _hx_local_1 = v
                        if (Std.isOfType(_hx_local_1,list) or ((_hx_local_1 is None))):
                            _hx_local_1
                        else:
                            raise "Class cast error"
                        return _hx_local_1
                    va = _hx_local_2()
                    _g = []
                    _g1 = 0
                    while (_g1 < len(va)):
                        e = (va[_g1] if _g1 >= 0 and _g1 < len(va) else None)
                        _g1 = (_g1 + 1)
                        x = hiss_HissTools.toHValue(e)
                        _g.append(x)
                    return hiss_HValue.List(_g)
                else:
                    return hiss_HValue.Object(name,v)
            elif (_hx_local_0 == 6):
                if (name1 == "String"):
                    return hiss_HValue.String(v)
                else:
                    return hiss_HValue.Object(name,v)
            else:
                return hiss_HValue.Object(name,v)
        elif (tmp == 7):
            e = t.params[0]
            name = Type.getEnumName(e)
            name1 = name
            _hx_local_4 = len(name1)
            if (_hx_local_4 == 11):
                if (name1 == "hiss.HValue"):
                    def _hx_local_7():
                        def _hx_local_6():
                            _hx_local_5 = v
                            if (Std.isOfType(_hx_local_5,hiss_HValue) or ((_hx_local_5 is None))):
                                _hx_local_5
                            else:
                                raise "Class cast error"
                            return _hx_local_5
                        return _hx_local_6()
                    return _hx_local_7()
                else:
                    return hiss_HValue.Object(name,e)
            elif (_hx_local_4 == 14):
                if (name1 == "haxe.ds.Option"):
                    def _hx_local_9():
                        _hx_local_8 = v
                        if (Std.isOfType(_hx_local_8,haxe_ds_Option) or ((_hx_local_8 is None))):
                            _hx_local_8
                        else:
                            raise "Class cast error"
                        return _hx_local_8
                    _g = _hx_local_9()
                    tmp = _g.index
                    if (tmp == 0):
                        vInner = _g.params[0]
                        return hiss_HissTools.toHValue(vInner)
                    elif (tmp == 1):
                        return hiss_HValue.Nil
                    else:
                        pass
                else:
                    return hiss_HValue.Object(name,e)
            else:
                return hiss_HValue.Object(name,e)
        else:
            raise haxe_Exception.thrown(((((("value " + Std.string(v)) + " of type ") + Std.string(t)) + " cannot be wrapped as ") + ("null" if hint is None else hint)))

    @staticmethod
    def unwrapList(hl,interp,keepWrapped = None):
        if (keepWrapped is None):
            keepWrapped = hiss_HValue.Nil
        indices = None
        if (keepWrapped == hiss_HValue.Nil):
            indices = []
        elif (keepWrapped == hiss_HValue.T):
            _g = []
            _g1 = 0
            _g2 = len(hiss_HissTools.toList(hl))
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                _g.append(i)
            indices = _g
        else:
            indices = hiss_HissTools.unwrapList(keepWrapped,interp)
        idx = 0
        _g = []
        _g1 = 0
        _g2 = hiss_HissTools.toList(hl)
        while (_g1 < len(_g2)):
            v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = idx
            idx = (idx + 1)
            if (python_internal_ArrayImpl.indexOf(indices,x,None) != -1):
                _g.append(v)
            else:
                x1 = hiss_HissTools.value(v,interp)
                _g.append(x1)
        return _g

    @staticmethod
    def toHList(l):
        _g = []
        _g1 = 0
        while (_g1 < len(l)):
            v = (l[_g1] if _g1 >= 0 and _g1 < len(l) else None)
            _g1 = (_g1 + 1)
            x = hiss_HissTools.toHValue(v)
            _g.append(x)
        return hiss_HValue.List(_g)

    @staticmethod
    def value(hv,interp,reference = None):
        if (reference is None):
            reference = False
        if (interp is None):
            haxe_Log.trace(hv,_hx_AnonObject({'fileName': "hiss/HissTools.hx", 'lineNumber': 264, 'className': "hiss.HissTools", 'methodName': "value"}))
        if (hv is None):
            return hiss_HValue.Nil
        tmp = hv.index
        if (tmp == 0):
            v = hv.params[0]
            return v
        elif (tmp == 1):
            v = hv.params[0]
            return v
        elif (tmp == 4):
            v = hv.params[0]
            return v
        elif ((tmp == 7) or ((tmp == 5))):
            return interp.truthy(hv)
        elif (tmp == 6):
            return None
        elif (tmp == 8):
            l = hv.params[0]
            if reference:
                return l
            else:
                _g = []
                _g1 = 0
                while (_g1 < len(l)):
                    hvv = (l[_g1] if _g1 >= 0 and _g1 < len(l) else None)
                    _g1 = (_g1 + 1)
                    x = hiss_HissTools.value(hvv,interp,True)
                    _g.append(x)
                return _g
        elif (tmp == 9):
            d = hv.params[0]
            return d
        elif (tmp == 10):
            _g = hv.params[1]
            _g = hv.params[0]
            return interp.toNativeFunction(hv)
        elif (tmp == 13):
            _g = hv.params[0]
            v = hv.params[1]
            return v
        else:
            return hv

    @staticmethod
    def metadata(_hx_callable):
        tmp = _hx_callable.index
        if (tmp == 10):
            _g = _hx_callable.params[0]
            meta = _hx_callable.params[1]
            return meta
        elif (tmp == 11):
            _g = _hx_callable.params[0]
            meta = _hx_callable.params[1]
            return meta
        elif (tmp == 12):
            _g = _hx_callable.params[0]
            meta = _hx_callable.params[1]
            return meta
        else:
            v = Std.string(_hx_callable)
            raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))

    @staticmethod
    def toPrint(v):
        return hiss_Stdlib.toPrint_h(v)

    @staticmethod
    def toMessage(v):
        return hiss_Stdlib.toMessage_h(v)
hiss_HissTools._hx_class = hiss_HissTools


class hiss_NativeFunctions:
    _hx_class_name = "hiss.NativeFunctions"
    __slots__ = ()
hiss_NativeFunctions._hx_class = hiss_NativeFunctions


class hiss_SpecialForms:
    _hx_class_name = "hiss.SpecialForms"
    __slots__ = ()
    _hx_statics = ["if_s", "lambda_s", "and_s", "or_s", "_ccNum", "callCC_s", "quote_s", "try_s"]

    @staticmethod
    def if_s(interp,args,env,cc):
        if (hiss_Stdlib.length_h(args) > 3):
            interp.error("(if) called with too many arguments. Try wrapping the cases in (begin)")
        def _hx_local_0(val):
            if interp.truthy(val):
                interp.evalCC(hiss_HissTools.second(args),cc,env)
            elif (hiss_Stdlib.length_h(args) > 2):
                interp.evalCC(hiss_HissTools.third(args),cc,env)
            else:
                cc(hiss_HValue.Nil)
        interp.evalCC(hiss_HissTools.first(args),_hx_local_0,env)

    @staticmethod
    def lambda_s(interp,args,env,cc,name = None,isMacro = None):
        if (name is None):
            name = "[anonymous lambda]"
        if (isMacro is None):
            isMacro = False
        params = hiss_HissTools.first(args)
        _g = []
        _g1 = 0
        _g2 = hiss_HissTools.toList(params)
        while (_g1 < len(_g2)):
            paramSymbol = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = None
            try:
                x = hiss_Stdlib.symbolName_h(paramSymbol)
            except BaseException as _g3:
                None
                x = "[nested list]"
            _g.append(x)
        meta = _hx_AnonObject({'name': name, 'argNames': _g, 'docstring': "", 'deprecated': False, '_hx_async': False})
        body = hiss_HissTools.toList(hiss_Stdlib.rest_h(args))
        idx = 0
        _g = 0
        while (_g < len(body)):
            exp = (body[_g] if _g >= 0 and _g < len(body) else None)
            _g = (_g + 1)
            tmp = exp.index
            if (tmp == 2):
                _g1 = exp.params[0]
                _hx_local_2 = len(_g1)
                if (_hx_local_2 == 11):
                    if (_g1 == "@deprecated"):
                        meta.deprecated = True
                        if (len(body) != 0):
                            body.pop(0)
                    else:
                        break
                elif (_hx_local_2 == 6):
                    if (_g1 == "@async"):
                        meta._hx_async = True
                        if (len(body) != 0):
                            body.pop(0)
                    else:
                        break
                else:
                    break
            elif (tmp == 3):
                d = exp.params[0]
                if ((idx + 1) < len(body)):
                    meta.docstring = d
                    if (len(body) != 0):
                        body.pop(0)
            elif (tmp == 4):
                d1 = exp.params[0]
                if ((idx + 1) < len(body)):
                    meta.docstring = d1
                    if (len(body) != 0):
                        body.pop(0)
            else:
                break
            idx = (idx + 1)
        def _hx_local_4(fArgs,innerEnv,fCC):
            callEnv = hiss_HValue.List((hiss_HissTools.toList(env) + hiss_HissTools.toList(innerEnv)))
            callEnv = hiss_HissTools.extend(callEnv,hiss_HissTools.destructuringBind(params,interp,fArgs))
            interp.evalCC(hiss_Stdlib.cons_h(hiss_HValue.Symbol("begin"),hiss_HValue.List(body)),fCC,callEnv)
        hFun = _hx_local_4
        _hx_callable = (hiss_HValue.Macro(hFun,meta) if isMacro else hiss_HValue.Function(hFun,meta))
        cc(_hx_callable)

    @staticmethod
    def and_s(interp,args,env,cc):
        argVal = hiss_HValue.T
        _g = 0
        _g1 = hiss_HissTools.toList(args)
        while (_g < len(_g1)):
            arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            def _hx_local_1(val):
                nonlocal argVal
                argVal = val
            interp.evalCC(arg,_hx_local_1,env)
            if (not interp.truthy(argVal)):
                cc(hiss_HValue.Nil)
                return
        cc(argVal)

    @staticmethod
    def or_s(interp,args,env,cc):
        _g = 0
        _g1 = hiss_HissTools.toList(args)
        while (_g < len(_g1)):
            arg = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            argVal = [hiss_HValue.Nil]
            def _hx_local_2(argVal):
                def _hx_local_1(val):
                    python_internal_ArrayImpl._set(argVal, 0, val)
                return _hx_local_1
            interp.evalCC(arg,_hx_local_2(argVal),env)
            if interp.truthy((argVal[0] if 0 < len(argVal) else None)):
                cc((argVal[0] if 0 < len(argVal) else None))
                return
        cc(hiss_HValue.Nil)

    @staticmethod
    def callCC_s(interp,args,env,cc):
        def _hx_local_2():
            _hx_local_0 = hiss_SpecialForms
            _hx_local_1 = _hx_local_0._ccNum
            _hx_local_0._ccNum = (_hx_local_1 + 1)
            return _hx_local_1
        ccId = _hx_local_2()
        message = ""
        functionToCall = None
        if (hiss_Stdlib.length_h(args) > 1):
            message = hiss_HissTools.toHaxeString(interp.eval(hiss_HissTools.first(args),env))
            functionToCall = hiss_HissTools.second(args)
        else:
            functionToCall = hiss_HissTools.first(args)
        def _hx_local_3(innerArgs,innerEnv,innerCC):
            arg = (hiss_HValue.Nil if ((not interp.truthy(innerArgs))) else hiss_HissTools.first(innerArgs))
            cc(arg)
        ccHFunction = hiss_HValue.Function(_hx_local_3,_hx_AnonObject({'name': "cc", 'argNames': ["result"]}))
        interp.evalCC(hiss_HValue.List([hiss_HValue.Symbol("funcall-inline"), functionToCall, ccHFunction]),cc,env)

    @staticmethod
    def quote_s(interp,args,env,cc):
        cc(hiss_HissTools.first(args))

    @staticmethod
    def try_s(interp,args,env,cc):
        try:
            interp.evalCC(hiss_HissTools.first(args),cc,env)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,hiss_HSignal):
                sig = _g1
                raise haxe_Exception.thrown(sig)
            else:
                err = _g1
                if (hiss_Stdlib.length_h(args) > 1):
                    def _hx_local_0(catchExp):
                        if (catchExp.index == 10):
                            _g = catchExp.params[1]
                            _g = catchExp.params[0]
                            interp.evalCC(hiss_HValue.List([catchExp, hiss_HissTools.toHValue(err)]),cc,env)
                        else:
                            cc(catchExp)
                    interp.evalCC(hiss_HissTools.second(args),_hx_local_0,env)
                else:
                    cc(hiss_HValue.Nil)
hiss_SpecialForms._hx_class = hiss_SpecialForms


class hiss_StaticFiles:
    _hx_class_name = "hiss.StaticFiles"
    __slots__ = ()
    _hx_statics = ["files", "groups", "_registerFileContent", "_registerFileWithGroup", "getContent", "getDirectoryFiles", "recursiveLoop"]

    @staticmethod
    def _registerFileContent(path,content):
        hiss_StaticFiles.files.h[path] = content

    @staticmethod
    def _registerFileWithGroup(path,group):
        if (not (group in hiss_StaticFiles.groups.h)):
            v = []
            hiss_StaticFiles.groups.h[group] = v
        _this = hiss_StaticFiles.groups.h.get(group,None)
        _this.append(path)

    @staticmethod
    def getContent(path):
        if (path in hiss_StaticFiles.files.h):
            return hiss_StaticFiles.files.h.get(path,None)
        else:
            return sys_io_File.getContent(path)

    @staticmethod
    def getDirectoryFiles(directory):
        return hiss_StaticFiles.groups.h.get(directory,None)

    @staticmethod
    def recursiveLoop(directory,files = None):
        if (files is None):
            files = []
        if sys_FileSystem.exists(directory):
            _g = 0
            _g1 = sys_FileSystem.readDirectory(directory)
            while (_g < len(_g1)):
                file = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if file.startswith("."):
                    continue
                path = haxe_io_Path.join([directory, file])
                if (not sys_FileSystem.isDirectory(path)):
                    files.append(path)
                else:
                    directory1 = haxe_io_Path.addTrailingSlash(path)
                    files = hiss_StaticFiles.recursiveLoop(directory1,files)
        return files
hiss_StaticFiles._hx_class = hiss_StaticFiles


class hiss_Stdlib:
    _hx_class_name = "hiss.Stdlib"
    __slots__ = ()
    _hx_statics = ["sort", "reverse", "not_ih", "nth_h", "setNth_hd", "symbolName_h", "symbol", "iterable", "iteratorToIterable", "clear_hd", "range", "length_h", "isInt_h", "isFloat_h", "isNumber_h", "isSymbol_h", "isString_h", "isList_h", "isDict_h", "isFunction_h", "isMacro_h", "isCallable_h", "isObject_h", "rest_h", "cons_h", "eq_ih", "_recursivePrintDepth", "toMessage_h", "toPrint_doc", "toPrint_h", "print_hd", "message_hd", "version", "homeDir", "docs_h", "help_i", "readLine_d", "sleep_ccda", "getProperty_cc", "callHaxe_cc", "new_cc", "mod", "listCopy", "isBound_s", "delay_sd", "index"]

    @staticmethod
    def sort(_hx_list,fun = None):
        if (fun is None):
            fun = Reflect.compare
        sorted = list(_hx_list)
        sorted.sort(key= python_lib_Functools.cmp_to_key(fun))
        return sorted

    @staticmethod
    def reverse(_hx_list):
        reversed = list(_hx_list)
        reversed.reverse()
        return reversed

    @staticmethod
    def not_ih(interp,v):
        if interp.truthy(v):
            return hiss_HValue.Nil
        else:
            return hiss_HValue.T

    @staticmethod
    def nth_h(_hx_list,idx):
        l = hiss_HissTools.toList(_hx_list)
        return python_internal_ArrayImpl._get(l, hiss_Stdlib.index(hiss_HissTools.toInt(idx),l))

    @staticmethod
    def setNth_hd(_hx_list,idx,val):
        l = hiss_HissTools.toList(_hx_list)
        python_internal_ArrayImpl._set(l, hiss_Stdlib.index(hiss_HissTools.toInt(idx),l), val)
        return l

    @staticmethod
    def symbolName_h(v):
        if (v.index == 2):
            name = v.params[0]
            return name
        else:
            v1 = Std.string(v)
            raise haxe_Exception.thrown((((("extraction to `" + "symbol name") + "` failed on `") + ("null" if v1 is None else v1)) + "`"))

    @staticmethod
    def symbol(name = None):
        if (name is None):
            return hiss_HValue.Symbol(("_" + HxOverrides.stringOrNull(uuid_Uuid.v4())))
        return hiss_HValue.Symbol(name)

    @staticmethod
    def iterable(next,hasNext):
        def _hx_local_3():
            def _hx_local_2():
                def _hx_local_1():
                    def _hx_local_0():
                        return hiss_HissTools.toHValue(next())
                    return _hx_AnonObject({'next': _hx_local_0, 'hasNext': hasNext})
                return _hx_local_1()
            return _hx_AnonObject({'iterator': _hx_local_2})
        return _hx_local_3()

    @staticmethod
    def iteratorToIterable(iterator):
        return hiss_Stdlib.iterable(iterator.next,iterator.hasNext)

    @staticmethod
    def clear_hd(l):
        arr = hiss_HissTools.toList(l)
        _hx_len = len(arr)
        pos = 0
        if (pos < 0):
            pos = (len(arr) + pos)
        if (pos < 0):
            pos = 0
        res = arr[pos:(pos + _hx_len)]
        del arr[pos:(pos + _hx_len)]
        return l

    @staticmethod
    def range(a,b = None):
        start = (0 if ((b is None)) else a)
        end = (a if ((b is None)) else b)
        intIterator = IntIterator(start,end)
        return hiss_Stdlib.iteratorToIterable(intIterator)

    @staticmethod
    def length_h(v):
        tmp = v.index
        if (tmp == 4):
            s = v.params[0]
            return len(s)
        elif (tmp == 8):
            l = v.params[0]
            return len(l)
        else:
            raise haxe_Exception.thrown((("" + Std.string(v)) + " has no length"))

    @staticmethod
    def isInt_h(hv):
        if (hv.index == 0):
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isFloat_h(hv):
        if (hv.index == 1):
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isNumber_h(hv):
        tmp = hv.index
        if (tmp == 0):
            _g = hv.params[0]
            return hiss_HValue.T
        elif (tmp == 1):
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isSymbol_h(hv):
        if (hv.index == 2):
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isString_h(hv):
        if (hv.index == 4):
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isList_h(hv):
        if (hv.index == 8):
            l = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isDict_h(hv):
        if (hv.index == 9):
            d = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isFunction_h(hv):
        if (hv.index == 10):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isMacro_h(hv):
        tmp = hv.index
        if (tmp == 11):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        elif (tmp == 12):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isCallable_h(hv):
        tmp = hv.index
        if (tmp == 10):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        elif (tmp == 11):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        elif (tmp == 12):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def isObject_h(hv):
        if (hv.index == 13):
            _g = hv.params[1]
            _g = hv.params[0]
            return hiss_HValue.T
        else:
            return hiss_HValue.Nil

    @staticmethod
    def rest_h(_hx_list):
        return hiss_HValue.List(hiss_HissTools.toList(_hx_list)[1:None])

    @staticmethod
    def cons_h(hv,hl):
        if ((hl == hiss_HValue.Nil) or ((hiss_Stdlib.length_h(hl) == 0))):
            return hiss_HValue.List([hv])
        l = list(hiss_HissTools.toList(hl))
        l.insert(0, hv)
        return hiss_HValue.List(l)

    @staticmethod
    def eq_ih(interp,a,b):
        if (a.index == 3):
            _g = a.params[0]
            a = interp.eval(a)
        if (b.index == 3):
            _g = b.params[0]
            b = interp.eval(b)
        if (a.index != b.index):
            return hiss_HValue.Nil
        tmp = a.index
        if (tmp == 0):
            _g = a.params[0]
            if Type.enumEq(a,b):
                return hiss_HValue.T
            else:
                return hiss_HValue.Nil
        elif (tmp == 1):
            _g = a.params[0]
            if Type.enumEq(a,b):
                return hiss_HValue.T
            else:
                return hiss_HValue.Nil
        elif (tmp == 2):
            _g = a.params[0]
            if Type.enumEq(a,b):
                return hiss_HValue.T
            else:
                return hiss_HValue.Nil
        elif (tmp == 4):
            _g = a.params[0]
            if Type.enumEq(a,b):
                return hiss_HValue.T
            else:
                return hiss_HValue.Nil
        elif ((tmp == 7) or ((tmp == 5))):
            if Type.enumEq(a,b):
                return hiss_HValue.T
            else:
                return hiss_HValue.Nil
        elif (tmp == 8):
            _g = a.params[0]
            l1 = hiss_HissTools.toList(a)
            l2 = hiss_HissTools.toList(b)
            if (len(l1) != len(l2)):
                return hiss_HValue.Nil
            i = 0
            while (i < len(l1)):
                if (not interp.truthy(hiss_Stdlib.eq_ih(interp,(l1[i] if i >= 0 and i < len(l1) else None),(l2[i] if i >= 0 and i < len(l2) else None)))):
                    return hiss_HValue.Nil
                i = (i + 1)
            return hiss_HValue.T
        elif (tmp == 12):
            _g = a.params[1]
            fun = a.params[0]
            if (b.index == 12):
                _g = b.params[1]
                fun2 = b.params[0]
                if (fun == fun2):
                    return hiss_HValue.T
                else:
                    return hiss_HValue.Nil
            else:
                return hiss_HValue.Nil
        elif (tmp == 14):
            aa = a.params[0]
            bb = None
            bb1 = b.index
            if (bb1 == 14):
                e = b.params[0]
                bb = e
            elif (bb1 == 15):
                e = b.params[0]
                bb = e
            elif (bb1 == 16):
                e = b.params[0]
                bb = e
            elif (bb1 == 17):
                e = b.params[0]
                bb = e
            else:
                v = Std.string(b)
                raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
            return hiss_Stdlib.eq_ih(interp,aa,bb)
        elif (tmp == 15):
            aa = a.params[0]
            bb = None
            bb1 = b.index
            if (bb1 == 14):
                e = b.params[0]
                bb = e
            elif (bb1 == 15):
                e = b.params[0]
                bb = e
            elif (bb1 == 16):
                e = b.params[0]
                bb = e
            elif (bb1 == 17):
                e = b.params[0]
                bb = e
            else:
                v = Std.string(b)
                raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
            return hiss_Stdlib.eq_ih(interp,aa,bb)
        elif (tmp == 16):
            aa = a.params[0]
            bb = None
            bb1 = b.index
            if (bb1 == 14):
                e = b.params[0]
                bb = e
            elif (bb1 == 15):
                e = b.params[0]
                bb = e
            elif (bb1 == 16):
                e = b.params[0]
                bb = e
            elif (bb1 == 17):
                e = b.params[0]
                bb = e
            else:
                v = Std.string(b)
                raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
            return hiss_Stdlib.eq_ih(interp,aa,bb)
        elif (tmp == 17):
            aa = a.params[0]
            bb = None
            bb1 = b.index
            if (bb1 == 14):
                e = b.params[0]
                bb = e
            elif (bb1 == 15):
                e = b.params[0]
                bb = e
            elif (bb1 == 16):
                e = b.params[0]
                bb = e
            elif (bb1 == 17):
                e = b.params[0]
                bb = e
            else:
                v = Std.string(b)
                raise haxe_Exception.thrown((((("extraction to `" + HxOverrides.stringOrNull(None)) + "` failed on `") + ("null" if v is None else v)) + "`"))
            return hiss_Stdlib.eq_ih(interp,aa,bb)
        else:
            raise haxe_Exception.thrown(((("eq is not implemented for " + Std.string(a)) + " and ") + Std.string(b)))

    @staticmethod
    def toMessage_h(v):
        if (v.index == 4):
            s = v.params[0]
            return s
        else:
            return hiss_Stdlib.toPrint_h(v)

    @staticmethod
    def toPrint_h(v,recursiveCall = None):
        if (recursiveCall is None):
            recursiveCall = 0
        tmp = v.index
        if (tmp == 0):
            i = v.params[0]
            return Std.string(i)
        elif (tmp == 1):
            f = v.params[0]
            return Std.string(f)
        elif (tmp == 2):
            name = v.params[0]
            return name
        elif (tmp == 3):
            _hx_str = v.params[0]
            return (("\"" + ("null" if _hx_str is None else _hx_str)) + "\"")
        elif (tmp == 4):
            _hx_str = v.params[0]
            return (("\"" + ("null" if _hx_str is None else _hx_str)) + "\"")
        elif (tmp == 5):
            return "nil"
        elif (tmp == 6):
            return "null"
        elif (tmp == 7):
            return "t"
        elif (tmp == 8):
            l = v.params[0]
            if (recursiveCall > hiss_Stdlib._recursivePrintDepth):
                return "STACK OVERFLOW DANGER"
            else:
                valueStr = ""
                _g = 0
                while (_g < len(l)):
                    v1 = (l[_g] if _g >= 0 and _g < len(l) else None)
                    _g = (_g + 1)
                    valueStr = (("null" if valueStr is None else valueStr) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(v1,(recursiveCall + 1))) + " "))))
                valueStr = HxString.substr(valueStr,0,(len(valueStr) - 1))
                return (("(" + ("null" if valueStr is None else valueStr)) + ")")
        elif (tmp == 9):
            hdict = v.params[0]
            if (recursiveCall > hiss_Stdlib._recursivePrintDepth):
                return "STACK OVERFLOW DANGER"
            else:
                _g = []
                _g1 = hdict.keyValueIterator()
                while _g1.hasNext():
                    _g2 = _g1.next()
                    k = _g2.key
                    v1 = _g2.value
                    x = (((("" + Std.string(k)) + " => ") + HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(v1,(recursiveCall + 1)))) + ", ")
                    _g.append(x)
                return ("" + Std.string(_g))
        elif (tmp == 10):
            _g = v.params[0]
            meta = v.params[1]
            return (((("" + HxOverrides.stringOrNull(meta.name)) + "(") + Std.string(Reflect.field(meta,"argNames"))) + ")")
        elif (tmp == 11):
            _g = v.params[0]
            meta = v.params[1]
            return (((("" + HxOverrides.stringOrNull(meta.name)) + "(") + Std.string(Reflect.field(meta,"argNames"))) + ")")
        elif (tmp == 12):
            _g = v.params[0]
            meta = v.params[1]
            return (((("" + HxOverrides.stringOrNull(meta.name)) + "(") + Std.string(Reflect.field(meta,"argNames"))) + ")")
        elif (tmp == 13):
            o = v.params[1]
            t = v.params[0]
            return (((("[" + ("null" if t is None else t)) + ": ") + Std.string(o)) + "]")
        elif (tmp == 14):
            e = v.params[0]
            return ("'" + HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(e,(recursiveCall + 1))))
        elif (tmp == 15):
            e = v.params[0]
            return ("`" + HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(e,(recursiveCall + 1))))
        elif (tmp == 16):
            e = v.params[0]
            return ("," + HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(e,(recursiveCall + 1))))
        elif (tmp == 17):
            e = v.params[0]
            return (",@" + HxOverrides.stringOrNull(hiss_Stdlib.toPrint_h(e,(recursiveCall + 1))))
        else:
            raise haxe_Exception.thrown((("Not clear why " + Std.string(v)) + " is being converted to string"))

    @staticmethod
    def print_hd(exp):
        hiss_HaxeTools.println(hiss_Stdlib.toPrint_h(exp))
        return exp

    @staticmethod
    def message_hd(exp):
        hiss_HaxeTools.println(hiss_Stdlib.toMessage_h(exp))
        return exp

    @staticmethod
    def version():
        return hiss_HValue.String("[unknown branch]-[unknown revision#][unknown if modified] (target: python)")

    @staticmethod
    def homeDir():
        path = Sys.getEnv(("UserProfile" if ((Sys.systemName() == "Windows")) else "HOME"))
        if (path is not None):
            return haxe_io_Path.normalize(path)
        else:
            return ""

    @staticmethod
    def docs_h(func):
        return Reflect.field(hiss_HissTools.metadata(func),"docstring")

    @staticmethod
    def help_i(interp,showDeprecated = None):
        if (showDeprecated is None):
            showDeprecated = False
        functionMessages = []
        _g = hiss_HissTools.toDict(interp.globals).keyValueIterator()
        while _g.hasNext():
            _g1 = _g.next()
            name = _g1.key
            value = _g1.value
            functionHelp = hiss_Stdlib.symbolName_h(name)
            if functionHelp.startswith("_"):
                continue
            try:
                meta = hiss_HissTools.metadata(value)
                if Reflect.field(meta,"deprecated"):
                    if showDeprecated:
                        functionHelp = (("null" if functionHelp is None else functionHelp) + " @deprecated")
                    else:
                        continue
                if Reflect.field(meta,"async"):
                    functionHelp = (("null" if functionHelp is None else functionHelp) + " @async")
                docs = hiss_Stdlib.docs_h(value)
                if ((docs is not None) and ((len(docs) > 0))):
                    functionHelp = (("null" if functionHelp is None else functionHelp) + HxOverrides.stringOrNull(((": " + ("null" if docs is None else docs)))))
            except BaseException as _g2:
                None
                continue
            functionMessages.append(functionHelp)
        def _hx_local_3(a,b):
            return Reflect.compare(a.lower(),b.lower())
        functionMessages.sort(key= python_lib_Functools.cmp_to_key(_hx_local_3))
        _g = 0
        while (_g < len(functionMessages)):
            functionHelp = (functionMessages[_g] if _g >= 0 and _g < len(functionMessages) else None)
            _g = (_g + 1)
            hiss_Stdlib.message_hd(hiss_HValue.String(functionHelp))

    @staticmethod
    def readLine_d():
        return Sys.stdin().readLine()

    @staticmethod
    def sleep_ccda(interp,args,env,cc):
        _g = cc
        a1 = hiss_HValue.Nil
        def _hx_local_0():
            _g(a1)
        haxe_Timer.delay(_hx_local_0,Math.floor(((hiss_HissTools.toFloat(hiss_HissTools.first(args)) * 1000) + 0.5)))

    @staticmethod
    def getProperty_cc(interp,args,env,cc):
        cc(hiss_HissTools.toHValue(Reflect.getProperty(hiss_HissTools.value(hiss_HissTools.first(args),interp,True),hiss_HissTools.toHaxeString(hiss_HissTools.second(args)))))

    @staticmethod
    def callHaxe_cc(interp,args,env,cc):
        callOnReference = (False if ((hiss_Stdlib.length_h(args) < 4)) else interp.truthy(hiss_Stdlib.nth_h(args,hiss_HValue.Int(3))))
        keepArgsWrapped = (hiss_HValue.Nil if ((hiss_Stdlib.length_h(args) < 5)) else hiss_Stdlib.nth_h(args,hiss_HValue.Int(4)))
        haxeCallArgs = ([] if ((hiss_Stdlib.length_h(args) < 3)) else hiss_HissTools.unwrapList(hiss_HissTools.third(args),interp,keepArgsWrapped))
        caller = hiss_HissTools.value(hiss_HissTools.first(args),interp,callOnReference)
        methodName = hiss_HissTools.toHaxeString(hiss_HissTools.second(args))
        method = Reflect.getProperty(caller,methodName)
        if (method is None):
            interp.error(((("There is no haxe method called " + ("null" if methodName is None else methodName)) + " on ") + HxOverrides.stringOrNull(hiss_HissTools.toPrint(hiss_HissTools.first(args)))))
        else:
            cc(hiss_HissTools.toHValue(hiss_HaxeTools.callMethod(caller,method,haxeCallArgs,interp.error)))

    @staticmethod
    def new_cc(interp,args,env,cc):
        clazz = hiss_HissTools.value(hiss_HissTools.first(args),interp)
        args1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp)
        instance = clazz(*args1)
        cc(hiss_HissTools.toHValue(instance))

    @staticmethod
    def mod(a,b):
        return HxOverrides.mod(a, b)

    @staticmethod
    def listCopy(v):
        return list(v)

    @staticmethod
    def isBound_s(interp,args,env,cc):
        stackFrames = hiss_HissTools.toList(env)
        g = hiss_HissTools.toDict(interp.globals)
        name = hiss_HissTools.first(args)
        _g = 0
        while (_g < len(stackFrames)):
            frame = (stackFrames[_g] if _g >= 0 and _g < len(stackFrames) else None)
            _g = (_g + 1)
            frameDict = hiss_HissTools.toDict(frame)
            if frameDict.exists_h(name):
                cc(hiss_HValue.T)
                return
        cc((hiss_HValue.T if (g.exists_h(name)) else hiss_HValue.Nil))

    @staticmethod
    def delay_sd(interp,args,env,cc):
        def _hx_local_0():
            interp.eval(hiss_HValue.List([hiss_HissTools.first(args)]),env)
        haxe_Timer.delay(_hx_local_0,Math.floor(((hiss_HissTools.toFloat(hiss_HissTools.second(args)) * 1000) + 0.5)))

    @staticmethod
    def index(idx,listOrString):
        realIdx = idx
        if (idx < 0):
            realIdx = (HxOverrides.length(listOrString) + idx)
        if ((realIdx < 0) or ((realIdx >= HxOverrides.length(listOrString)))):
            raise haxe_Exception.thrown(((("Index out of range: " + Std.string(idx)) + " in ") + Std.string(listOrString)))
        return realIdx
hiss_Stdlib._hx_class = hiss_Stdlib

class hiss_Comparison(Enum):
    __slots__ = ()
    _hx_class_name = "hiss.Comparison"
    _hx_constructs = ["Lesser", "LesserEqual", "Greater", "GreaterEqual", "Equal"]
hiss_Comparison.Lesser = hiss_Comparison("Lesser", 0, ())
hiss_Comparison.LesserEqual = hiss_Comparison("LesserEqual", 1, ())
hiss_Comparison.Greater = hiss_Comparison("Greater", 2, ())
hiss_Comparison.GreaterEqual = hiss_Comparison("GreaterEqual", 3, ())
hiss_Comparison.Equal = hiss_Comparison("Equal", 4, ())
hiss_Comparison._hx_class = hiss_Comparison


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "_add_dynamic", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,str) and isinstance(b,str)):
            return (a + b)
        if (isinstance(a,str) or isinstance(b,str)):
            return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
        return (a + b)

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "get_length", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def get_length(s):
        return len(s)

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["get_length", "concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def get_length(x):
        return len(x)

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class hiss_VariadicFunctions:
    _hx_class_name = "hiss.VariadicFunctions"
    __slots__ = ()
    _hx_statics = ["append_cc", "add_cc", "subtract_cc", "divide_cc", "multiply_cc", "_numCompare", "lesser_cc", "lesserEqual_cc", "greater_cc", "greaterEqual_cc", "equal_cc"]

    @staticmethod
    def append_cc(interp,args,env,cc):
        result = hiss_HissTools.toList(hiss_HissTools.first(args))
        _g = 0
        _g1 = hiss_HissTools.toList(hiss_Stdlib.rest_h(args))
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            result = (result + hiss_HissTools.toList(l))
        cc(hiss_HValue.List(result))

    @staticmethod
    def add_cc(interp,args,env,cc):
        sum = None
        _g = hiss_HissTools.first(args)
        sum1 = _g.index
        if (sum1 == 0):
            _g1 = _g.params[0]
            sum = 0
        elif (sum1 == 1):
            _g1 = _g.params[0]
            sum = 0
        elif (sum1 == 4):
            _g1 = _g.params[0]
            sum = ""
        elif (sum1 == 8):
            _g1 = _g.params[0]
            sum = []
        else:
            raise haxe_Exception.thrown(((("Cannot perform addition with operands: " + HxOverrides.stringOrNull(hiss_HissTools.toPrint(args))) + " because first element is  ") + HxOverrides.stringOrNull(hiss_HissTools.first(args).tag)))
        addNext = None
        _g = hiss_HissTools.first(args)
        addNext1 = _g.index
        if (addNext1 == 0):
            _g1 = _g.params[0]
            def _hx_local_1(i):
                nonlocal sum
                sum = python_Boot._add_dynamic(sum,i)
            addNext = _hx_local_1
        elif (addNext1 == 1):
            _g1 = _g.params[0]
            def _hx_local_3(i):
                nonlocal sum
                sum = python_Boot._add_dynamic(sum,i)
            addNext = _hx_local_3
        elif (addNext1 == 4):
            _g1 = _g.params[0]
            def _hx_local_5(i):
                nonlocal sum
                sum = python_Boot._add_dynamic(sum,i)
            addNext = _hx_local_5
        elif (addNext1 == 8):
            _g1 = _g.params[0]
            def _hx_local_6(i):
                nonlocal sum
                sum = Reflect.field(sum,"concat")(i)
            addNext = _hx_local_6
        else:
            addNext = None
        _g = 0
        _g1 = hiss_HissTools.unwrapList(args,interp)
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            addNext(i)
        cc(hiss_HissTools.toHValue(sum))

    @staticmethod
    def subtract_cc(interp,args,env,cc):
        _g = hiss_Stdlib.length_h(args)
        if (_g == 0):
            cc(hiss_HValue.Int(0))
        elif (_g == 1):
            cc(hiss_HissTools.toHValue((0 - hiss_HissTools.value(hiss_HissTools.first(args),interp))))
        else:
            first = hiss_HissTools.value(hiss_HissTools.first(args),interp)
            _g = 0
            _g1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp)
            while (_g < len(_g1)):
                val = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                first = (first - val)
            cc(hiss_HissTools.toHValue(first))

    @staticmethod
    def divide_cc(interp,args,env,cc):
        _g = hiss_Stdlib.length_h(args)
        if (_g == 0):
            raise haxe_Exception.thrown("Can't divide without operands")
        elif (_g == 1):
            cc(hiss_HissTools.toHValue((1 / hiss_HissTools.value(hiss_HissTools.first(args),interp))))
        else:
            first = hiss_HissTools.value(hiss_HissTools.first(args),interp)
            _g = 0
            _g1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp)
            while (_g < len(_g1)):
                val = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                first = (first / val)
            cc(hiss_HissTools.toHValue(first))

    @staticmethod
    def multiply_cc(interp,args,env,cc):
        _g = hiss_HissTools.first(args)
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
            product = 1
            operands = hiss_HissTools.unwrapList(args,interp)
            _g1 = hiss_HissTools.last(args)
            tmp = _g1.index
            if (tmp == 4):
                _g2 = _g1.params[0]
                hiss_VariadicFunctions.multiply_cc(interp,hiss_Stdlib.cons_h(hiss_HissTools.toHValue(python_internal_ArrayImpl._get(operands, (len(operands) - 1))),hiss_HissTools.toHList(operands[0:(len(operands) - 1)])),env,cc)
                return
            elif (tmp == 8):
                _g2 = _g1.params[0]
                hiss_VariadicFunctions.multiply_cc(interp,hiss_Stdlib.cons_h(hiss_HissTools.toHValue(python_internal_ArrayImpl._get(operands, (len(operands) - 1))),hiss_HissTools.toHList(operands[0:(len(operands) - 1)])),env,cc)
                return
            else:
                pass
            _g1 = 0
            while (_g1 < len(operands)):
                val = (operands[_g1] if _g1 >= 0 and _g1 < len(operands) else None)
                _g1 = (_g1 + 1)
                product = (product * val)
            cc(hiss_HissTools.toHValue(product))
        elif (tmp == 1):
            _g1 = _g.params[0]
            product = 1
            operands = hiss_HissTools.unwrapList(args,interp)
            _g1 = hiss_HissTools.last(args)
            tmp = _g1.index
            if (tmp == 4):
                _g2 = _g1.params[0]
                hiss_VariadicFunctions.multiply_cc(interp,hiss_Stdlib.cons_h(hiss_HissTools.toHValue(python_internal_ArrayImpl._get(operands, (len(operands) - 1))),hiss_HissTools.toHList(operands[0:(len(operands) - 1)])),env,cc)
                return
            elif (tmp == 8):
                _g2 = _g1.params[0]
                hiss_VariadicFunctions.multiply_cc(interp,hiss_Stdlib.cons_h(hiss_HissTools.toHValue(python_internal_ArrayImpl._get(operands, (len(operands) - 1))),hiss_HissTools.toHList(operands[0:(len(operands) - 1)])),env,cc)
                return
            else:
                pass
            _g1 = 0
            while (_g1 < len(operands)):
                val = (operands[_g1] if _g1 >= 0 and _g1 < len(operands) else None)
                _g1 = (_g1 + 1)
                product = (product * val)
            cc(hiss_HissTools.toHValue(product))
        elif (tmp == 4):
            _hx_str = _g.params[0]
            product = ""
            toRepeat = hiss_HissTools.toHaxeString(hiss_HissTools.first(args))
            times = hiss_HissTools.toInt(hiss_HissTools.second(args))
            _g1 = 0
            _g2 = times
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                product = (("null" if product is None else product) + ("null" if toRepeat is None else toRepeat))
            if (hiss_Stdlib.length_h(args) == 2):
                cc(hiss_HValue.String(product))
            else:
                hiss_VariadicFunctions.multiply_cc(interp,hiss_Stdlib.cons_h(hiss_HValue.String(product),hiss_HissTools.slice(args,2)),env,cc)
        elif (tmp == 8):
            l = _g.params[0]
            product = []
            toRepeat = hiss_HissTools.toList(hiss_HissTools.first(args))
            times = hiss_HissTools.toInt(hiss_HissTools.second(args))
            _g = 0
            _g1 = times
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                product = (product + toRepeat)
            if (hiss_Stdlib.length_h(args) == 2):
                cc(hiss_HValue.List(product))
            else:
                hiss_VariadicFunctions.multiply_cc(interp,hiss_Stdlib.cons_h(hiss_HValue.List(product),hiss_HissTools.slice(args,2)),env,cc)
        else:
            raise haxe_Exception.thrown(("Cannot multiply with first operand " + HxOverrides.stringOrNull(hiss_HissTools.toPrint(hiss_HissTools.first(args)))))

    @staticmethod
    def _numCompare(_hx_type,interp,args,env,cc):
        _g = hiss_Stdlib.length_h(args)
        if (_g == 0):
            raise haxe_Exception.thrown("Can't compare without operands")
        elif (_g == 1):
            cc(hiss_HValue.T)
        else:
            leftSide = hiss_HissTools.value(hiss_HissTools.first(args),interp)
            _g = 0
            _g1 = hiss_HissTools.unwrapList(hiss_Stdlib.rest_h(args),interp)
            while (_g < len(_g1)):
                val = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                rightSide = val
                _hx_pass = None
                pass1 = _hx_type.index
                if (pass1 == 0):
                    _hx_pass = (leftSide < rightSide)
                elif (pass1 == 1):
                    _hx_pass = (leftSide <= rightSide)
                elif (pass1 == 2):
                    _hx_pass = (leftSide > rightSide)
                elif (pass1 == 3):
                    _hx_pass = (leftSide >= rightSide)
                elif (pass1 == 4):
                    _hx_pass = HxOverrides.eq(leftSide,rightSide)
                else:
                    pass
                if _hx_pass:
                    leftSide = rightSide
                else:
                    cc(hiss_HValue.Nil)
                    return
            cc(hiss_HValue.T)
hiss_VariadicFunctions._hx_class = hiss_VariadicFunctions


class hiss_wrappers_HDate:
    _hx_class_name = "hiss.wrappers.HDate"
    __slots__ = ("_instance",)
    _hx_fields = ["_instance"]
    _hx_statics = ["_fromHaxeDate", "fromString", "fromTime", "now", "getDate", "getDay", "getYear", "getHours", "getMinutes", "getMonth", "getSeconds", "getTime", "getTimezoneOffset"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self._instance = Date(year,month,day,hour,_hx_min,sec)

    @staticmethod
    def _fromHaxeDate(date):
        hd = hiss_wrappers_HDate(2020,0,0,0,0,0)
        hd._instance = date
        return hd

    @staticmethod
    def fromString(s):
        return hiss_wrappers_HDate._fromHaxeDate(Date.fromString(s))

    @staticmethod
    def fromTime(t):
        return hiss_wrappers_HDate._fromHaxeDate(Date.fromTime(t))

    @staticmethod
    def now():
        return hiss_wrappers_HDate._fromHaxeDate(Date.now())

    @staticmethod
    def getDate(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return date._instance.date.day

    @staticmethod
    def getDay(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return HxOverrides.mod(date._instance.date.isoweekday(), 7)

    @staticmethod
    def getYear(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return date._instance.date.year

    @staticmethod
    def getHours(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return date._instance.date.hour

    @staticmethod
    def getMinutes(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return date._instance.date.minute

    @staticmethod
    def getMonth(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return (date._instance.date.month - 1)

    @staticmethod
    def getSeconds(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return date._instance.date.second

    @staticmethod
    def getTime(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return (date._instance.date.timestamp() * 1000)

    @staticmethod
    def getTimezoneOffset(date = None):
        if (date is None):
            date = hiss_wrappers_HDate.now()
        return date._instance.getTimezoneOffset()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._instance = None
hiss_wrappers_HDate._hx_class = hiss_wrappers_HDate


class hiss_wrappers_HFile:
    _hx_class_name = "hiss.wrappers.HFile"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent_d"]

    @staticmethod
    def getContent(path):
        return sys_io_File.getContent(path)

    @staticmethod
    def saveContent_d(path,content):
        sys_io_File.saveContent(path,content)
hiss_wrappers_HFile._hx_class = hiss_wrappers_HFile


class hiss_wrappers_HHttp:
    _hx_class_name = "hiss.wrappers.HHttp"
    __slots__ = ("_instance",)
    _hx_fields = ["_instance"]
    _hx_methods = ["setHeader_d", "setParameter_d", "setPostData_d"]
    _hx_statics = ["requestUrl", "request_dcc"]

    def __init__(self,url):
        self._instance = sys_Http(url)

    def setHeader_d(self,name,value):
        self._instance.setHeader(name,value)

    def setParameter_d(self,name,value):
        self._instance.setParameter(name,value)

    def setPostData_d(self,data = None):
        self._instance.setPostData(data)

    @staticmethod
    def requestUrl(url):
        return sys_Http.requestUrl(url)

    @staticmethod
    def request_dcc(interp,args,env,cc):
        http = Reflect.field(hiss_HissTools.value(hiss_HissTools.first(args),interp),"_instance")
        post = ((hiss_Stdlib.length_h(args) > 1) and hiss_HissTools.value(hiss_HissTools.second(args),interp))
        def _hx_local_0(dataString):
            cc(hiss_HissTools.toHValue(dataString))
        http.onData = _hx_local_0
        http.onError = interp.error
        http.request(post)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._instance = None
hiss_wrappers_HHttp._hx_class = hiss_wrappers_HHttp


class hiss_wrappers_HStringTools:
    _hx_class_name = "hiss.wrappers.HStringTools"
    __slots__ = ()
    _hx_statics = ["startsWith", "endsWith", "lpad", "rpad", "trim", "ltrim", "rtrim", "replace"]
hiss_wrappers_HStringTools._hx_class = hiss_wrappers_HStringTools


class hiss_wrappers_HType:
    _hx_class_name = "hiss.wrappers.HType"
    __slots__ = ()
    _hx_statics = ["createInstance"]

    @staticmethod
    def createInstance(cl,args):
        return cl(*args)
hiss_wrappers_HType._hx_class = hiss_wrappers_HType


class hx_strings__AnyAsString_AnyAsString_Impl_:
    _hx_class_name = "hx.strings._AnyAsString.AnyAsString_Impl_"
    __slots__ = ()
    _hx_statics = ["fromBool", "fromAny"]

    @staticmethod
    def fromBool(value):
        if value:
            return "true"
        else:
            return "false"

    @staticmethod
    def fromAny(value):
        return Std.string(value)
hx_strings__AnyAsString_AnyAsString_Impl_._hx_class = hx_strings__AnyAsString_AnyAsString_Impl_


class hx_strings__Char_CharCaseMapper:
    _hx_class_name = "hx.strings._Char.CharCaseMapper"
    __slots__ = ("mapU2L", "mapL2U")
    _hx_fields = ["mapU2L", "mapL2U"]
    _hx_methods = ["_addCaseMapping", "isLowerCase", "isUpperCase", "toLowerCase", "toUpperCase"]

    def __init__(self):
        self.mapL2U = haxe_ds_IntMap()
        self.mapU2L = haxe_ds_IntMap()
        self._addCaseMapping(97,65)
        self._addCaseMapping(98,66)
        self._addCaseMapping(99,67)
        self._addCaseMapping(100,68)
        self._addCaseMapping(101,69)
        self._addCaseMapping(102,70)
        self._addCaseMapping(103,71)
        self._addCaseMapping(104,72)
        self._addCaseMapping(105,73)
        self._addCaseMapping(106,74)
        self._addCaseMapping(107,75)
        self._addCaseMapping(108,76)
        self._addCaseMapping(109,77)
        self._addCaseMapping(110,78)
        self._addCaseMapping(111,79)
        self._addCaseMapping(112,80)
        self._addCaseMapping(113,81)
        self._addCaseMapping(114,82)
        self._addCaseMapping(115,83)
        self._addCaseMapping(116,84)
        self._addCaseMapping(117,85)
        self._addCaseMapping(118,86)
        self._addCaseMapping(119,87)
        self._addCaseMapping(120,88)
        self._addCaseMapping(121,89)
        self._addCaseMapping(122,90)
        self._addCaseMapping(224,192)
        self._addCaseMapping(225,193)
        self._addCaseMapping(226,194)
        self._addCaseMapping(227,195)
        self._addCaseMapping(228,196)
        self._addCaseMapping(229,197)
        self._addCaseMapping(230,198)
        self._addCaseMapping(231,199)
        self._addCaseMapping(232,200)
        self._addCaseMapping(233,201)
        self._addCaseMapping(234,202)
        self._addCaseMapping(235,203)
        self._addCaseMapping(236,204)
        self._addCaseMapping(237,205)
        self._addCaseMapping(238,206)
        self._addCaseMapping(239,207)
        self._addCaseMapping(240,208)
        self._addCaseMapping(241,209)
        self._addCaseMapping(242,210)
        self._addCaseMapping(243,211)
        self._addCaseMapping(244,212)
        self._addCaseMapping(245,213)
        self._addCaseMapping(246,214)
        self._addCaseMapping(248,216)
        self._addCaseMapping(249,217)
        self._addCaseMapping(250,218)
        self._addCaseMapping(251,219)
        self._addCaseMapping(252,220)
        self._addCaseMapping(253,221)
        self._addCaseMapping(254,222)
        self._addCaseMapping(255,376)
        self._addCaseMapping(257,256)
        self._addCaseMapping(259,258)
        self._addCaseMapping(261,260)
        self._addCaseMapping(263,262)
        self._addCaseMapping(265,264)
        self._addCaseMapping(267,266)
        self._addCaseMapping(269,268)
        self._addCaseMapping(271,270)
        self._addCaseMapping(273,272)
        self._addCaseMapping(275,274)
        self._addCaseMapping(277,276)
        self._addCaseMapping(279,278)
        self._addCaseMapping(281,280)
        self._addCaseMapping(283,282)
        self._addCaseMapping(285,284)
        self._addCaseMapping(287,286)
        self._addCaseMapping(289,288)
        self._addCaseMapping(291,290)
        self._addCaseMapping(293,292)
        self._addCaseMapping(295,294)
        self._addCaseMapping(297,296)
        self._addCaseMapping(299,298)
        self._addCaseMapping(301,300)
        self._addCaseMapping(303,302)
        self._addCaseMapping(305,73)
        self._addCaseMapping(307,306)
        self._addCaseMapping(309,308)
        self._addCaseMapping(311,310)
        self._addCaseMapping(314,313)
        self._addCaseMapping(316,315)
        self._addCaseMapping(318,317)
        self._addCaseMapping(320,319)
        self._addCaseMapping(322,321)
        self._addCaseMapping(324,323)
        self._addCaseMapping(326,325)
        self._addCaseMapping(328,327)
        self._addCaseMapping(331,330)
        self._addCaseMapping(333,332)
        self._addCaseMapping(335,334)
        self._addCaseMapping(337,336)
        self._addCaseMapping(339,338)
        self._addCaseMapping(341,340)
        self._addCaseMapping(343,342)
        self._addCaseMapping(345,344)
        self._addCaseMapping(347,346)
        self._addCaseMapping(349,348)
        self._addCaseMapping(351,350)
        self._addCaseMapping(353,352)
        self._addCaseMapping(355,354)
        self._addCaseMapping(357,356)
        self._addCaseMapping(359,358)
        self._addCaseMapping(361,360)
        self._addCaseMapping(363,362)
        self._addCaseMapping(365,364)
        self._addCaseMapping(367,366)
        self._addCaseMapping(369,368)
        self._addCaseMapping(371,370)
        self._addCaseMapping(373,372)
        self._addCaseMapping(375,374)
        self._addCaseMapping(378,377)
        self._addCaseMapping(380,379)
        self._addCaseMapping(382,381)
        self._addCaseMapping(387,386)
        self._addCaseMapping(389,388)
        self._addCaseMapping(392,391)
        self._addCaseMapping(396,395)
        self._addCaseMapping(402,401)
        self._addCaseMapping(409,408)
        self._addCaseMapping(417,416)
        self._addCaseMapping(419,418)
        self._addCaseMapping(421,420)
        self._addCaseMapping(424,423)
        self._addCaseMapping(429,428)
        self._addCaseMapping(432,431)
        self._addCaseMapping(436,435)
        self._addCaseMapping(438,437)
        self._addCaseMapping(441,440)
        self._addCaseMapping(445,444)
        self._addCaseMapping(454,452)
        self._addCaseMapping(457,455)
        self._addCaseMapping(460,458)
        self._addCaseMapping(462,461)
        self._addCaseMapping(464,463)
        self._addCaseMapping(466,465)
        self._addCaseMapping(468,467)
        self._addCaseMapping(470,469)
        self._addCaseMapping(472,471)
        self._addCaseMapping(474,473)
        self._addCaseMapping(476,475)
        self._addCaseMapping(479,478)
        self._addCaseMapping(481,480)
        self._addCaseMapping(483,482)
        self._addCaseMapping(485,484)
        self._addCaseMapping(487,486)
        self._addCaseMapping(489,488)
        self._addCaseMapping(491,490)
        self._addCaseMapping(493,492)
        self._addCaseMapping(495,494)
        self._addCaseMapping(499,497)
        self._addCaseMapping(501,500)
        self._addCaseMapping(507,506)
        self._addCaseMapping(509,508)
        self._addCaseMapping(511,510)
        self._addCaseMapping(513,512)
        self._addCaseMapping(515,514)
        self._addCaseMapping(517,516)
        self._addCaseMapping(519,518)
        self._addCaseMapping(521,520)
        self._addCaseMapping(523,522)
        self._addCaseMapping(525,524)
        self._addCaseMapping(527,526)
        self._addCaseMapping(529,528)
        self._addCaseMapping(531,530)
        self._addCaseMapping(533,532)
        self._addCaseMapping(535,534)
        self._addCaseMapping(595,385)
        self._addCaseMapping(596,390)
        self._addCaseMapping(599,394)
        self._addCaseMapping(600,398)
        self._addCaseMapping(601,399)
        self._addCaseMapping(603,400)
        self._addCaseMapping(608,403)
        self._addCaseMapping(611,404)
        self._addCaseMapping(616,407)
        self._addCaseMapping(617,406)
        self._addCaseMapping(623,412)
        self._addCaseMapping(626,413)
        self._addCaseMapping(629,415)
        self._addCaseMapping(643,425)
        self._addCaseMapping(648,430)
        self._addCaseMapping(650,433)
        self._addCaseMapping(651,434)
        self._addCaseMapping(658,439)
        self._addCaseMapping(924,181)
        self._addCaseMapping(940,902)
        self._addCaseMapping(941,904)
        self._addCaseMapping(942,905)
        self._addCaseMapping(943,906)
        self._addCaseMapping(945,913)
        self._addCaseMapping(946,914)
        self._addCaseMapping(947,915)
        self._addCaseMapping(948,916)
        self._addCaseMapping(949,917)
        self._addCaseMapping(950,918)
        self._addCaseMapping(951,919)
        self._addCaseMapping(952,920)
        self._addCaseMapping(953,921)
        self._addCaseMapping(954,922)
        self._addCaseMapping(955,923)
        self._addCaseMapping(956,924)
        self._addCaseMapping(957,925)
        self._addCaseMapping(958,926)
        self._addCaseMapping(959,927)
        self._addCaseMapping(960,928)
        self._addCaseMapping(961,929)
        self._addCaseMapping(963,931)
        self._addCaseMapping(964,932)
        self._addCaseMapping(965,933)
        self._addCaseMapping(966,934)
        self._addCaseMapping(967,935)
        self._addCaseMapping(968,936)
        self._addCaseMapping(969,937)
        self._addCaseMapping(970,938)
        self._addCaseMapping(971,939)
        self._addCaseMapping(972,908)
        self._addCaseMapping(973,910)
        self._addCaseMapping(974,911)
        self._addCaseMapping(995,994)
        self._addCaseMapping(997,996)
        self._addCaseMapping(999,998)
        self._addCaseMapping(1001,1000)
        self._addCaseMapping(1003,1002)
        self._addCaseMapping(1005,1004)
        self._addCaseMapping(1007,1006)
        self._addCaseMapping(1072,1040)
        self._addCaseMapping(1073,1041)
        self._addCaseMapping(1074,1042)
        self._addCaseMapping(1075,1043)
        self._addCaseMapping(1076,1044)
        self._addCaseMapping(1077,1045)
        self._addCaseMapping(1078,1046)
        self._addCaseMapping(1079,1047)
        self._addCaseMapping(1080,1048)
        self._addCaseMapping(1081,1049)
        self._addCaseMapping(1082,1050)
        self._addCaseMapping(1083,1051)
        self._addCaseMapping(1084,1052)
        self._addCaseMapping(1085,1053)
        self._addCaseMapping(1086,1054)
        self._addCaseMapping(1087,1055)
        self._addCaseMapping(1088,1056)
        self._addCaseMapping(1089,1057)
        self._addCaseMapping(1090,1058)
        self._addCaseMapping(1091,1059)
        self._addCaseMapping(1092,1060)
        self._addCaseMapping(1093,1061)
        self._addCaseMapping(1094,1062)
        self._addCaseMapping(1095,1063)
        self._addCaseMapping(1096,1064)
        self._addCaseMapping(1097,1065)
        self._addCaseMapping(1098,1066)
        self._addCaseMapping(1099,1067)
        self._addCaseMapping(1100,1068)
        self._addCaseMapping(1101,1069)
        self._addCaseMapping(1102,1070)
        self._addCaseMapping(1103,1071)
        self._addCaseMapping(1105,1025)
        self._addCaseMapping(1106,1026)
        self._addCaseMapping(1107,1027)
        self._addCaseMapping(1108,1028)
        self._addCaseMapping(1109,1029)
        self._addCaseMapping(1110,1030)
        self._addCaseMapping(1111,1031)
        self._addCaseMapping(1112,1032)
        self._addCaseMapping(1113,1033)
        self._addCaseMapping(1114,1034)
        self._addCaseMapping(1115,1035)
        self._addCaseMapping(1116,1036)
        self._addCaseMapping(1118,1038)
        self._addCaseMapping(1119,1039)
        self._addCaseMapping(1121,1120)
        self._addCaseMapping(1123,1122)
        self._addCaseMapping(1125,1124)
        self._addCaseMapping(1127,1126)
        self._addCaseMapping(1129,1128)
        self._addCaseMapping(1131,1130)
        self._addCaseMapping(1133,1132)
        self._addCaseMapping(1135,1134)
        self._addCaseMapping(1137,1136)
        self._addCaseMapping(1139,1138)
        self._addCaseMapping(1141,1140)
        self._addCaseMapping(1143,1142)
        self._addCaseMapping(1145,1144)
        self._addCaseMapping(1147,1146)
        self._addCaseMapping(1149,1148)
        self._addCaseMapping(1151,1150)
        self._addCaseMapping(1153,1152)
        self._addCaseMapping(1169,1168)
        self._addCaseMapping(1171,1170)
        self._addCaseMapping(1173,1172)
        self._addCaseMapping(1175,1174)
        self._addCaseMapping(1177,1176)
        self._addCaseMapping(1179,1178)
        self._addCaseMapping(1181,1180)
        self._addCaseMapping(1183,1182)
        self._addCaseMapping(1185,1184)
        self._addCaseMapping(1187,1186)
        self._addCaseMapping(1189,1188)
        self._addCaseMapping(1191,1190)
        self._addCaseMapping(1193,1192)
        self._addCaseMapping(1195,1194)
        self._addCaseMapping(1197,1196)
        self._addCaseMapping(1199,1198)
        self._addCaseMapping(1201,1200)
        self._addCaseMapping(1203,1202)
        self._addCaseMapping(1205,1204)
        self._addCaseMapping(1207,1206)
        self._addCaseMapping(1209,1208)
        self._addCaseMapping(1211,1210)
        self._addCaseMapping(1213,1212)
        self._addCaseMapping(1215,1214)
        self._addCaseMapping(1218,1217)
        self._addCaseMapping(1220,1219)
        self._addCaseMapping(1224,1223)
        self._addCaseMapping(1228,1227)
        self._addCaseMapping(1233,1232)
        self._addCaseMapping(1235,1234)
        self._addCaseMapping(1237,1236)
        self._addCaseMapping(1239,1238)
        self._addCaseMapping(1241,1240)
        self._addCaseMapping(1243,1242)
        self._addCaseMapping(1245,1244)
        self._addCaseMapping(1247,1246)
        self._addCaseMapping(1249,1248)
        self._addCaseMapping(1251,1250)
        self._addCaseMapping(1253,1252)
        self._addCaseMapping(1255,1254)
        self._addCaseMapping(1257,1256)
        self._addCaseMapping(1259,1258)
        self._addCaseMapping(1263,1262)
        self._addCaseMapping(1265,1264)
        self._addCaseMapping(1267,1266)
        self._addCaseMapping(1269,1268)
        self._addCaseMapping(1273,1272)
        self._addCaseMapping(1377,1329)
        self._addCaseMapping(1378,1330)
        self._addCaseMapping(1379,1331)
        self._addCaseMapping(1380,1332)
        self._addCaseMapping(1381,1333)
        self._addCaseMapping(1382,1334)
        self._addCaseMapping(1383,1335)
        self._addCaseMapping(1384,1336)
        self._addCaseMapping(1385,1337)
        self._addCaseMapping(1386,1338)
        self._addCaseMapping(1387,1339)
        self._addCaseMapping(1388,1340)
        self._addCaseMapping(1389,1341)
        self._addCaseMapping(1390,1342)
        self._addCaseMapping(1391,1343)
        self._addCaseMapping(1392,1344)
        self._addCaseMapping(1393,1345)
        self._addCaseMapping(1394,1346)
        self._addCaseMapping(1395,1347)
        self._addCaseMapping(1396,1348)
        self._addCaseMapping(1397,1349)
        self._addCaseMapping(1398,1350)
        self._addCaseMapping(1399,1351)
        self._addCaseMapping(1400,1352)
        self._addCaseMapping(1401,1353)
        self._addCaseMapping(1402,1354)
        self._addCaseMapping(1403,1355)
        self._addCaseMapping(1404,1356)
        self._addCaseMapping(1405,1357)
        self._addCaseMapping(1406,1358)
        self._addCaseMapping(1407,1359)
        self._addCaseMapping(1408,1360)
        self._addCaseMapping(1409,1361)
        self._addCaseMapping(1410,1362)
        self._addCaseMapping(1411,1363)
        self._addCaseMapping(1412,1364)
        self._addCaseMapping(1413,1365)
        self._addCaseMapping(1414,1366)
        self._addCaseMapping(4304,4256)
        self._addCaseMapping(4305,4257)
        self._addCaseMapping(4306,4258)
        self._addCaseMapping(4307,4259)
        self._addCaseMapping(4308,4260)
        self._addCaseMapping(4309,4261)
        self._addCaseMapping(4310,4262)
        self._addCaseMapping(4311,4263)
        self._addCaseMapping(4312,4264)
        self._addCaseMapping(4313,4265)
        self._addCaseMapping(4314,4266)
        self._addCaseMapping(4315,4267)
        self._addCaseMapping(4316,4268)
        self._addCaseMapping(4317,4269)
        self._addCaseMapping(4318,4270)
        self._addCaseMapping(4319,4271)
        self._addCaseMapping(4320,4272)
        self._addCaseMapping(4321,4273)
        self._addCaseMapping(4322,4274)
        self._addCaseMapping(4323,4275)
        self._addCaseMapping(4324,4276)
        self._addCaseMapping(4325,4277)
        self._addCaseMapping(4326,4278)
        self._addCaseMapping(4327,4279)
        self._addCaseMapping(4328,4280)
        self._addCaseMapping(4329,4281)
        self._addCaseMapping(4330,4282)
        self._addCaseMapping(4331,4283)
        self._addCaseMapping(4332,4284)
        self._addCaseMapping(4333,4285)
        self._addCaseMapping(4334,4286)
        self._addCaseMapping(4335,4287)
        self._addCaseMapping(4336,4288)
        self._addCaseMapping(4337,4289)
        self._addCaseMapping(4338,4290)
        self._addCaseMapping(4339,4291)
        self._addCaseMapping(4340,4292)
        self._addCaseMapping(4341,4293)
        self._addCaseMapping(7681,7680)
        self._addCaseMapping(7683,7682)
        self._addCaseMapping(7685,7684)
        self._addCaseMapping(7687,7686)
        self._addCaseMapping(7689,7688)
        self._addCaseMapping(7691,7690)
        self._addCaseMapping(7693,7692)
        self._addCaseMapping(7695,7694)
        self._addCaseMapping(7697,7696)
        self._addCaseMapping(7699,7698)
        self._addCaseMapping(7701,7700)
        self._addCaseMapping(7703,7702)
        self._addCaseMapping(7705,7704)
        self._addCaseMapping(7707,7706)
        self._addCaseMapping(7709,7708)
        self._addCaseMapping(7711,7710)
        self._addCaseMapping(7713,7712)
        self._addCaseMapping(7715,7714)
        self._addCaseMapping(7717,7716)
        self._addCaseMapping(7719,7718)
        self._addCaseMapping(7721,7720)
        self._addCaseMapping(7723,7722)
        self._addCaseMapping(7725,7724)
        self._addCaseMapping(7727,7726)
        self._addCaseMapping(7729,7728)
        self._addCaseMapping(7731,7730)
        self._addCaseMapping(7733,7732)
        self._addCaseMapping(7735,7734)
        self._addCaseMapping(7737,7736)
        self._addCaseMapping(7739,7738)
        self._addCaseMapping(7741,7740)
        self._addCaseMapping(7743,7742)
        self._addCaseMapping(7745,7744)
        self._addCaseMapping(7747,7746)
        self._addCaseMapping(7749,7748)
        self._addCaseMapping(7751,7750)
        self._addCaseMapping(7753,7752)
        self._addCaseMapping(7755,7754)
        self._addCaseMapping(7757,7756)
        self._addCaseMapping(7759,7758)
        self._addCaseMapping(7761,7760)
        self._addCaseMapping(7763,7762)
        self._addCaseMapping(7765,7764)
        self._addCaseMapping(7767,7766)
        self._addCaseMapping(7769,7768)
        self._addCaseMapping(7771,7770)
        self._addCaseMapping(7773,7772)
        self._addCaseMapping(7775,7774)
        self._addCaseMapping(7777,7776)
        self._addCaseMapping(7779,7778)
        self._addCaseMapping(7781,7780)
        self._addCaseMapping(7783,7782)
        self._addCaseMapping(7785,7784)
        self._addCaseMapping(7787,7786)
        self._addCaseMapping(7789,7788)
        self._addCaseMapping(7791,7790)
        self._addCaseMapping(7793,7792)
        self._addCaseMapping(7795,7794)
        self._addCaseMapping(7797,7796)
        self._addCaseMapping(7799,7798)
        self._addCaseMapping(7801,7800)
        self._addCaseMapping(7803,7802)
        self._addCaseMapping(7805,7804)
        self._addCaseMapping(7807,7806)
        self._addCaseMapping(7809,7808)
        self._addCaseMapping(7811,7810)
        self._addCaseMapping(7813,7812)
        self._addCaseMapping(7815,7814)
        self._addCaseMapping(7817,7816)
        self._addCaseMapping(7819,7818)
        self._addCaseMapping(7821,7820)
        self._addCaseMapping(7823,7822)
        self._addCaseMapping(7825,7824)
        self._addCaseMapping(7827,7826)
        self._addCaseMapping(7829,7828)
        self._addCaseMapping(7841,7840)
        self._addCaseMapping(7843,7842)
        self._addCaseMapping(7845,7844)
        self._addCaseMapping(7847,7846)
        self._addCaseMapping(7849,7848)
        self._addCaseMapping(7851,7850)
        self._addCaseMapping(7853,7852)
        self._addCaseMapping(7855,7854)
        self._addCaseMapping(7857,7856)
        self._addCaseMapping(7859,7858)
        self._addCaseMapping(7861,7860)
        self._addCaseMapping(7863,7862)
        self._addCaseMapping(7865,7864)
        self._addCaseMapping(7867,7866)
        self._addCaseMapping(7869,7868)
        self._addCaseMapping(7871,7870)
        self._addCaseMapping(7873,7872)
        self._addCaseMapping(7875,7874)
        self._addCaseMapping(7877,7876)
        self._addCaseMapping(7879,7878)
        self._addCaseMapping(7881,7880)
        self._addCaseMapping(7883,7882)
        self._addCaseMapping(7885,7884)
        self._addCaseMapping(7887,7886)
        self._addCaseMapping(7889,7888)
        self._addCaseMapping(7891,7890)
        self._addCaseMapping(7893,7892)
        self._addCaseMapping(7895,7894)
        self._addCaseMapping(7897,7896)
        self._addCaseMapping(7899,7898)
        self._addCaseMapping(7901,7900)
        self._addCaseMapping(7903,7902)
        self._addCaseMapping(7905,7904)
        self._addCaseMapping(7907,7906)
        self._addCaseMapping(7909,7908)
        self._addCaseMapping(7911,7910)
        self._addCaseMapping(7913,7912)
        self._addCaseMapping(7915,7914)
        self._addCaseMapping(7917,7916)
        self._addCaseMapping(7919,7918)
        self._addCaseMapping(7921,7920)
        self._addCaseMapping(7923,7922)
        self._addCaseMapping(7925,7924)
        self._addCaseMapping(7927,7926)
        self._addCaseMapping(7929,7928)
        self._addCaseMapping(7936,7944)
        self._addCaseMapping(7937,7945)
        self._addCaseMapping(7938,7946)
        self._addCaseMapping(7939,7947)
        self._addCaseMapping(7940,7948)
        self._addCaseMapping(7941,7949)
        self._addCaseMapping(7942,7950)
        self._addCaseMapping(7943,7951)
        self._addCaseMapping(7952,7960)
        self._addCaseMapping(7953,7961)
        self._addCaseMapping(7954,7962)
        self._addCaseMapping(7955,7963)
        self._addCaseMapping(7956,7964)
        self._addCaseMapping(7957,7965)
        self._addCaseMapping(7968,7976)
        self._addCaseMapping(7969,7977)
        self._addCaseMapping(7970,7978)
        self._addCaseMapping(7971,7979)
        self._addCaseMapping(7972,7980)
        self._addCaseMapping(7973,7981)
        self._addCaseMapping(7974,7982)
        self._addCaseMapping(7975,7983)
        self._addCaseMapping(7984,7992)
        self._addCaseMapping(7985,7993)
        self._addCaseMapping(7986,7994)
        self._addCaseMapping(7987,7995)
        self._addCaseMapping(7988,7996)
        self._addCaseMapping(7989,7997)
        self._addCaseMapping(7990,7998)
        self._addCaseMapping(7991,7999)
        self._addCaseMapping(8000,8008)
        self._addCaseMapping(8001,8009)
        self._addCaseMapping(8002,8010)
        self._addCaseMapping(8003,8011)
        self._addCaseMapping(8004,8012)
        self._addCaseMapping(8005,8013)
        self._addCaseMapping(8017,8025)
        self._addCaseMapping(8019,8027)
        self._addCaseMapping(8021,8029)
        self._addCaseMapping(8023,8031)
        self._addCaseMapping(8032,8040)
        self._addCaseMapping(8033,8041)
        self._addCaseMapping(8034,8042)
        self._addCaseMapping(8035,8043)
        self._addCaseMapping(8036,8044)
        self._addCaseMapping(8037,8045)
        self._addCaseMapping(8038,8046)
        self._addCaseMapping(8039,8047)
        self._addCaseMapping(8064,8072)
        self._addCaseMapping(8065,8073)
        self._addCaseMapping(8066,8074)
        self._addCaseMapping(8067,8075)
        self._addCaseMapping(8068,8076)
        self._addCaseMapping(8069,8077)
        self._addCaseMapping(8070,8078)
        self._addCaseMapping(8071,8079)
        self._addCaseMapping(8080,8088)
        self._addCaseMapping(8081,8089)
        self._addCaseMapping(8082,8090)
        self._addCaseMapping(8083,8091)
        self._addCaseMapping(8084,8092)
        self._addCaseMapping(8085,8093)
        self._addCaseMapping(8086,8094)
        self._addCaseMapping(8087,8095)
        self._addCaseMapping(8096,8104)
        self._addCaseMapping(8097,8105)
        self._addCaseMapping(8098,8106)
        self._addCaseMapping(8099,8107)
        self._addCaseMapping(8100,8108)
        self._addCaseMapping(8101,8109)
        self._addCaseMapping(8102,8110)
        self._addCaseMapping(8103,8111)
        self._addCaseMapping(8112,8120)
        self._addCaseMapping(8113,8121)
        self._addCaseMapping(8144,8152)
        self._addCaseMapping(8145,8153)
        self._addCaseMapping(8160,8168)
        self._addCaseMapping(8161,8169)
        self._addCaseMapping(9424,9398)
        self._addCaseMapping(9425,9399)
        self._addCaseMapping(9426,9400)
        self._addCaseMapping(9427,9401)
        self._addCaseMapping(9428,9402)
        self._addCaseMapping(9429,9403)
        self._addCaseMapping(9430,9404)
        self._addCaseMapping(9431,9405)
        self._addCaseMapping(9432,9406)
        self._addCaseMapping(9433,9407)
        self._addCaseMapping(9434,9408)
        self._addCaseMapping(9435,9409)
        self._addCaseMapping(9436,9410)
        self._addCaseMapping(9437,9411)
        self._addCaseMapping(9438,9412)
        self._addCaseMapping(9439,9413)
        self._addCaseMapping(9440,9414)
        self._addCaseMapping(9441,9415)
        self._addCaseMapping(9442,9416)
        self._addCaseMapping(9443,9417)
        self._addCaseMapping(9444,9418)
        self._addCaseMapping(9445,9419)
        self._addCaseMapping(9446,9420)
        self._addCaseMapping(9447,9421)
        self._addCaseMapping(9448,9422)
        self._addCaseMapping(9449,9423)
        self._addCaseMapping(65345,65313)
        self._addCaseMapping(65346,65314)
        self._addCaseMapping(65347,65315)
        self._addCaseMapping(65348,65316)
        self._addCaseMapping(65349,65317)
        self._addCaseMapping(65350,65318)
        self._addCaseMapping(65351,65319)
        self._addCaseMapping(65352,65320)
        self._addCaseMapping(65353,65321)
        self._addCaseMapping(65354,65322)
        self._addCaseMapping(65355,65323)
        self._addCaseMapping(65356,65324)
        self._addCaseMapping(65357,65325)
        self._addCaseMapping(65358,65326)
        self._addCaseMapping(65359,65327)
        self._addCaseMapping(65360,65328)
        self._addCaseMapping(65361,65329)
        self._addCaseMapping(65362,65330)
        self._addCaseMapping(65363,65331)
        self._addCaseMapping(65364,65332)
        self._addCaseMapping(65365,65333)
        self._addCaseMapping(65366,65334)
        self._addCaseMapping(65367,65335)
        self._addCaseMapping(65368,65336)
        self._addCaseMapping(65369,65337)
        self._addCaseMapping(65370,65338)

    def _addCaseMapping(self,lowerChar,upperChar):
        if (not (upperChar in self.mapU2L.h)):
            self.mapU2L.set(upperChar,lowerChar)
        if (not (lowerChar in self.mapL2U.h)):
            self.mapL2U.set(lowerChar,upperChar)

    def isLowerCase(self,ch):
        return (ch in self.mapL2U.h)

    def isUpperCase(self,ch):
        return (ch in self.mapU2L.h)

    def toLowerCase(self,ch):
        lowerChar = self.mapU2L.h.get(ch,None)
        if (lowerChar is None):
            return ch
        else:
            return lowerChar

    def toUpperCase(self,ch):
        upperChar = self.mapL2U.h.get(ch,None)
        if (upperChar is None):
            return ch
        else:
            return upperChar

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mapU2L = None
        _hx_o.mapL2U = None
hx_strings__Char_CharCaseMapper._hx_class = hx_strings__Char_CharCaseMapper


class hx_strings__Char_Char_Impl_:
    _hx_class_name = "hx.strings._Char.Char_Impl_"
    __slots__ = ()
    _hx_statics = ["CHAR_CASE_MAPPER", "BACKSPACE", "TAB", "LF", "CR", "ESC", "SPACE", "EXCLAMATION_MARK", "DOUBLE_QUOTE", "HASH", "DOLLAR", "AMPERSAND", "SINGLE_QUOTE", "BRACKET_ROUND_LEFT", "BRACKET_ROUND_RIGHT", "ASTERISK", "PLUS", "COMMA", "MINUS", "DOT", "SLASH", "ZERO", "ONE", "TWO", "TRHEE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "COLON", "SEMICOLON", "LOWER_THAN", "EQUALS", "GREATER_THAN", "QUESTION_MARK", "BRACKET_SQUARE_LEFT", "BACKSLASH", "BRACKET_SQUARE_RIGHT", "CARET", "UNDERSCORE", "BRACKET_CURLY_LEFT", "PIPE", "BRACKET_CURLY_RIGHT", "fromString", "of", "op_plus_string", "op_plus_string2", "op_plus", "isAscii", "isAsciiAlpha", "isAsciiAlphanumeric", "isAsciiControl", "isAsciiPrintable", "isDigit", "isEOF", "isSpace", "isUTF8", "isWhitespace", "isLowerCase", "isUpperCase", "toLowerCase", "toUpperCase", "toInt", "toString"]

    @staticmethod
    def fromString(_hx_str):
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((strLen == 0) or ((0 >= strLen))):
            return -1
        else:
            return HxString.charCodeAt(_hx_str,0)

    @staticmethod
    def of(ch):
        return ch

    @staticmethod
    def op_plus_string(ch,other):
        return (HxOverrides.stringOrNull("".join(map(chr,[ch]))) + ("null" if other is None else other))

    @staticmethod
    def op_plus_string2(_hx_str,ch):
        return (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull("".join(map(chr,[ch]))))

    @staticmethod
    def op_plus(ch,other):
        return (ch + other)

    @staticmethod
    def isAscii(this1):
        if (this1 > -1):
            return (this1 < 128)
        else:
            return False

    @staticmethod
    def isAsciiAlpha(this1):
        if (not (((this1 > 64) and ((this1 < 91))))):
            if (this1 > 96):
                return (this1 < 123)
            else:
                return False
        else:
            return True

    @staticmethod
    def isAsciiAlphanumeric(this1):
        if (not ((((this1 > 64) and ((this1 < 91))) or (((this1 > 96) and ((this1 < 123))))))):
            if (this1 > 47):
                return (this1 < 58)
            else:
                return False
        else:
            return True

    @staticmethod
    def isAsciiControl(this1):
        if (not (((this1 > -1) and ((this1 < 32))))):
            return (this1 == 127)
        else:
            return True

    @staticmethod
    def isAsciiPrintable(this1):
        if (this1 > 31):
            return (this1 < 127)
        else:
            return False

    @staticmethod
    def isDigit(this1):
        if (this1 > 47):
            return (this1 < 58)
        else:
            return False

    @staticmethod
    def isEOF(this1):
        return (this1 == -1)

    @staticmethod
    def isSpace(this1):
        return (this1 == 32)

    @staticmethod
    def isUTF8(this1):
        if (this1 > -1):
            return (this1 < 1114112)
        else:
            return False

    @staticmethod
    def isWhitespace(this1):
        if (not (((this1 > 8) and ((this1 < 14))))):
            return (this1 == 32)
        else:
            return True

    @staticmethod
    def isLowerCase(this1):
        return (this1 in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h)

    @staticmethod
    def isUpperCase(this1):
        return (this1 in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h)

    @staticmethod
    def toLowerCase(this1):
        lowerChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h.get(this1,None)
        if (lowerChar is None):
            return this1
        else:
            return lowerChar

    @staticmethod
    def toUpperCase(this1):
        upperChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h.get(this1,None)
        if (upperChar is None):
            return this1
        else:
            return upperChar

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def toString(this1):
        return "".join(map(chr,[this1]))
hx_strings__Char_Char_Impl_._hx_class = hx_strings__Char_Char_Impl_


class hx_strings_CharIterator:
    _hx_class_name = "hx.strings.CharIterator"
    __slots__ = ("index", "line", "col", "currChar", "prevBuffer", "prevBufferPrevIdx", "prevBufferNextIdx")
    _hx_fields = ["index", "line", "col", "currChar", "prevBuffer", "prevBufferPrevIdx", "prevBufferNextIdx"]
    _hx_methods = ["get_current", "get_pos", "hasPrev", "prev", "hasNext", "next", "getChar", "isEOF"]
    _hx_statics = ["fromString", "fromArray", "fromInput", "fromIterator"]

    def __init__(self,prevBufferSize):
        self.prevBufferNextIdx = -1
        self.prevBufferPrevIdx = -1
        self.currChar = -1
        self.col = 0
        self.line = 0
        self.index = -1
        tmp = None
        if (prevBufferSize > 0):
            this1 = hx_strings_internal__RingBuffer_RingBufferImpl((prevBufferSize + 1))
            tmp = this1
        else:
            tmp = None
        self.prevBuffer = tmp

    def get_current(self):
        if (self.index > -1):
            return self.currChar
        else:
            return None

    def get_pos(self):
        return hx_strings_CharPos(self.index,self.line,self.col)

    def hasPrev(self):
        return (self.prevBufferPrevIdx > -1)

    def prev(self):
        if (self.prevBufferPrevIdx <= -1):
            raise haxe_Exception.thrown(haxe_io_Eof())
        prevChar = self.prevBuffer.get(self.prevBufferPrevIdx)
        self.currChar = prevChar.char
        self.index = prevChar.index
        self.line = prevChar.line
        self.col = prevChar.col
        self.prevBufferNextIdx = ((self.prevBufferPrevIdx + 1) if (((self.prevBufferPrevIdx + 1) < self.prevBuffer.length)) else -1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.prevBufferPrevIdx
        _hx_local_0.prevBufferPrevIdx = (_hx_local_1 - 1)
        _hx_local_1
        return self.currChar

    def hasNext(self):
        if (self.prevBufferNextIdx > -1):
            return True
        else:
            return (not self.isEOF())

    def next(self):
        if (self.prevBufferNextIdx > -1):
            prevChar = self.prevBuffer.get(self.prevBufferNextIdx)
            self.currChar = prevChar.char
            self.index = prevChar.index
            self.line = prevChar.line
            self.col = prevChar.col
            self.prevBufferPrevIdx = (self.prevBufferNextIdx - 1)
            self.prevBufferNextIdx = ((self.prevBufferNextIdx + 1) if (((self.prevBufferNextIdx + 1) < self.prevBuffer.length)) else -1)
            return self.currChar
        if self.isEOF():
            raise haxe_Exception.thrown(haxe_io_Eof())
        if ((self.currChar == 10) or ((self.currChar < 0))):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.line
            _hx_local_0.line = (_hx_local_1 + 1)
            _hx_local_1
            self.col = 0
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.index
        _hx_local_2.index = (_hx_local_3 + 1)
        _hx_local_3
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.col
        _hx_local_4.col = (_hx_local_5 + 1)
        _hx_local_5
        self.currChar = self.getChar()
        if (self.prevBuffer is not None):
            self.prevBuffer.add(hx_strings__CharIterator_CharWithPos(self.currChar,self.index,self.col,self.line))
            self.prevBufferPrevIdx = (self.prevBuffer.length - 2)
            self.prevBufferNextIdx = -1
        return self.currChar

    def getChar(self):
        raise haxe_Exception.thrown("Not implemented")

    def isEOF(self):
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def fromString(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_StringCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromArray(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_ArrayCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromInput(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_InputCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromIterator(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_IteratorCharIterator(chars,prevBufferSize)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.line = None
        _hx_o.col = None
        _hx_o.currChar = None
        _hx_o.prevBuffer = None
        _hx_o.prevBufferPrevIdx = None
        _hx_o.prevBufferNextIdx = None
hx_strings_CharIterator._hx_class = hx_strings_CharIterator


class hx_strings_CharPos:
    _hx_class_name = "hx.strings.CharPos"
    __slots__ = ("index", "line", "col")
    _hx_fields = ["index", "line", "col"]
    _hx_methods = ["toString"]

    def __init__(self,index,line,col):
        self.index = index
        self.line = line
        self.col = col

    def toString(self):
        return (((((("CharPos[index=" + Std.string(self.index)) + ", line=") + Std.string(self.line)) + ", col=") + Std.string(self.col)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.line = None
        _hx_o.col = None
hx_strings_CharPos._hx_class = hx_strings_CharPos


class hx_strings__CharIterator_CharWithPos(hx_strings_CharPos):
    _hx_class_name = "hx.strings._CharIterator.CharWithPos"
    __slots__ = ("char",)
    _hx_fields = ["char"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharPos


    def __init__(self,char,index,line,col):
        self.char = None
        super().__init__(index,line,col)
        self.char = char

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.char = None
hx_strings__CharIterator_CharWithPos._hx_class = hx_strings__CharIterator_CharWithPos


class hx_strings_internal__RingBuffer_RingBufferImpl:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBufferImpl"
    __slots__ = ("buffer", "bufferStartIdx", "bufferEndIdx", "bufferMaxIdx", "length", "size")
    _hx_fields = ["buffer", "bufferStartIdx", "bufferEndIdx", "bufferMaxIdx", "length", "size"]
    _hx_methods = ["add", "get", "iterator", "toArray"]

    def __init__(self,size):
        self.length = 0
        self.bufferEndIdx = -1
        self.bufferStartIdx = 0
        if (size < 1):
            raise haxe_Exception.thrown("[size] must be > 0")
        this1 = [None]*size
        self.buffer = this1
        self.size = size
        self.bufferMaxIdx = (size - 1)

    def add(self,item):
        if (self.length == self.size):
            self.bufferEndIdx = self.bufferStartIdx
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bufferStartIdx
            _hx_local_0.bufferStartIdx = (_hx_local_1 + 1)
            _hx_local_1
            if (self.bufferStartIdx > self.bufferMaxIdx):
                self.bufferStartIdx = 0
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.bufferEndIdx
            _hx_local_2.bufferEndIdx = (_hx_local_3 + 1)
            _hx_local_3
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.length
            _hx_local_4.length = (_hx_local_5 + 1)
            _hx_local_5
        self.buffer[self.bufferEndIdx] = item

    def get(self,index):
        if ((index < 0) or ((index > self.bufferMaxIdx))):
            raise haxe_Exception.thrown((("[index] " + Std.string(index)) + " is out of bound"))
        realIdx = (self.bufferStartIdx + index)
        if (realIdx > self.bufferMaxIdx):
            realIdx = (realIdx - self.length)
        return self.buffer[realIdx]

    def iterator(self):
        return hx_strings_internal__RingBuffer_RingBufferIterator(self)

    def toArray(self):
        arr = list()
        i = self.iterator()
        while i.hasNext():
            i1 = i.next()
            arr.append(i1)
        return arr

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.bufferStartIdx = None
        _hx_o.bufferEndIdx = None
        _hx_o.bufferMaxIdx = None
        _hx_o.length = None
        _hx_o.size = None
hx_strings_internal__RingBuffer_RingBufferImpl._hx_class = hx_strings_internal__RingBuffer_RingBufferImpl


class hx_strings__CharIterator_NullCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.NullCharIterator"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["isEOF"]
    _hx_statics = ["INSTANCE"]
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self):
        super().__init__(0)

    def isEOF(self):
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hx_strings__CharIterator_NullCharIterator._hx_class = hx_strings__CharIterator_NullCharIterator


class hx_strings__CharIterator_ArrayCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.ArrayCharIterator"
    __slots__ = ("chars", "charsMaxIndex")
    _hx_fields = ["chars", "charsMaxIndex"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.charsMaxIndex = None
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars
        self.charsMaxIndex = (len(chars) - 1)

    def isEOF(self):
        return (self.index >= self.charsMaxIndex)

    def getChar(self):
        return python_internal_ArrayImpl._get(self.chars, self.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
        _hx_o.charsMaxIndex = None
hx_strings__CharIterator_ArrayCharIterator._hx_class = hx_strings__CharIterator_ArrayCharIterator


class hx_strings__CharIterator_IteratorCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.IteratorCharIterator"
    __slots__ = ("chars",)
    _hx_fields = ["chars"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars

    def isEOF(self):
        return (not self.chars.hasNext())

    def getChar(self):
        return self.chars.next()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
hx_strings__CharIterator_IteratorCharIterator._hx_class = hx_strings__CharIterator_IteratorCharIterator


class hx_strings__CharIterator_InputCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.InputCharIterator"
    __slots__ = ("byteIndex", "input", "currCharIndex", "nextChar", "nextCharAvailable")
    _hx_fields = ["byteIndex", "input", "currCharIndex", "nextChar", "nextCharAvailable"]
    _hx_methods = ["isEOF", "getChar", "readUtf8Char", "readUtf8MultiSequenceByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.nextChar = None
        self.input = None
        self.nextCharAvailable = None
        self.currCharIndex = -1
        self.byteIndex = 0
        super().__init__(prevBufferSize)
        self.input = chars

    def isEOF(self):
        if (self.nextCharAvailable == None):
            try:
                byte1 = self.input.readByte()
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.byteIndex
                _hx_local_0.byteIndex = (_hx_local_1 + 1)
                _hx_local_1
                tmp = None
                if (byte1 <= 127):
                    tmp = byte1
                else:
                    byte1 = (byte1 & -129)
                    byte1 = (byte1 & -65)
                    totalBytes = 2
                    isBit6Set = (1 == (((byte1 >> 5) & 1)))
                    isBit5Set = False
                    if isBit6Set:
                        byte1 = (byte1 & -33)
                        totalBytes = (totalBytes + 1)
                        isBit5Set = (1 == (((byte1 >> 4) & 1)))
                        if isBit5Set:
                            byte1 = (byte1 & -17)
                            totalBytes = (totalBytes + 1)
                            if (1 == (((byte1 >> 3) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
                    result = (byte1 << ((6 * ((totalBytes - 1)))))
                    byte = self.input.readByte()
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.byteIndex
                    _hx_local_8.byteIndex = (_hx_local_9 + 1)
                    _hx_local_9
                    if (1 != (((byte >> 7) & 1))):
                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                    if (1 == (((byte >> 6) & 1))):
                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                    byte2 = (byte & -129)
                    result = (result + ((byte2 << ((6 * ((totalBytes - 2)))))))
                    if isBit6Set:
                        byte = self.input.readByte()
                        _hx_local_11 = self
                        _hx_local_12 = _hx_local_11.byteIndex
                        _hx_local_11.byteIndex = (_hx_local_12 + 1)
                        _hx_local_12
                        if (1 != (((byte >> 7) & 1))):
                            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                        if (1 == (((byte >> 6) & 1))):
                            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                        byte3 = (byte & -129)
                        result = (result + ((byte3 << ((6 * ((totalBytes - 3)))))))
                        if isBit5Set:
                            byte = self.input.readByte()
                            _hx_local_14 = self
                            _hx_local_15 = _hx_local_14.byteIndex
                            _hx_local_14.byteIndex = (_hx_local_15 + 1)
                            _hx_local_15
                            if (1 != (((byte >> 7) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            if (1 == (((byte >> 6) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            byte4 = (byte & -129)
                            result = (result + ((byte4 << ((6 * ((totalBytes - 4)))))))
                    if ((self.index == 0) and ((result == 65279))):
                        byte1 = self.input.readByte()
                        _hx_local_17 = self
                        _hx_local_18 = _hx_local_17.byteIndex
                        _hx_local_17.byteIndex = (_hx_local_18 + 1)
                        _hx_local_18
                        if (byte1 <= 127):
                            tmp = byte1
                        else:
                            byte1 = (byte1 & -129)
                            byte1 = (byte1 & -65)
                            totalBytes = 2
                            isBit6Set = (1 == (((byte1 >> 5) & 1)))
                            isBit5Set = False
                            if isBit6Set:
                                byte1 = (byte1 & -33)
                                totalBytes = (totalBytes + 1)
                                isBit5Set = (1 == (((byte1 >> 4) & 1)))
                                if isBit5Set:
                                    byte1 = (byte1 & -17)
                                    totalBytes = (totalBytes + 1)
                                    if (1 == (((byte1 >> 3) & 1))):
                                        raise haxe_Exception.thrown((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
                            result1 = (byte1 << ((6 * ((totalBytes - 1)))))
                            byte = self.input.readByte()
                            _hx_local_25 = self
                            _hx_local_26 = _hx_local_25.byteIndex
                            _hx_local_25.byteIndex = (_hx_local_26 + 1)
                            _hx_local_26
                            if (1 != (((byte >> 7) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            if (1 == (((byte >> 6) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            byte2 = (byte & -129)
                            result1 = (result1 + ((byte2 << ((6 * ((totalBytes - 2)))))))
                            if isBit6Set:
                                byte = self.input.readByte()
                                _hx_local_28 = self
                                _hx_local_29 = _hx_local_28.byteIndex
                                _hx_local_28.byteIndex = (_hx_local_29 + 1)
                                _hx_local_29
                                if (1 != (((byte >> 7) & 1))):
                                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                if (1 == (((byte >> 6) & 1))):
                                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                byte3 = (byte & -129)
                                result1 = (result1 + ((byte3 << ((6 * ((totalBytes - 3)))))))
                                if isBit5Set:
                                    byte = self.input.readByte()
                                    _hx_local_31 = self
                                    _hx_local_32 = _hx_local_31.byteIndex
                                    _hx_local_31.byteIndex = (_hx_local_32 + 1)
                                    _hx_local_32
                                    if (1 != (((byte >> 7) & 1))):
                                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                    if (1 == (((byte >> 6) & 1))):
                                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                    byte4 = (byte & -129)
                                    result1 = (result1 + ((byte4 << ((6 * ((totalBytes - 4)))))))
                            tmp = (self.readUtf8Char() if (((self.index == 0) and ((result1 == 65279)))) else result1)
                    else:
                        tmp = result
                self.nextChar = tmp
                self.nextCharAvailable = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                    self.nextCharAvailable = False
                else:
                    raise _g
        return (self.nextCharAvailable != True)

    def getChar(self):
        if (self.index != self.currCharIndex):
            self.currCharIndex = self.index
            self.nextCharAvailable = None
            return self.nextChar
        return self.currChar

    def readUtf8Char(self):
        byte1 = self.input.readByte()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.byteIndex
        _hx_local_0.byteIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (byte1 <= 127):
            return byte1
        byte1 = (byte1 & -129)
        byte1 = (byte1 & -65)
        totalBytes = 2
        isBit6Set = (1 == (((byte1 >> 5) & 1)))
        isBit5Set = False
        if isBit6Set:
            byte1 = (byte1 & -33)
            totalBytes = (totalBytes + 1)
            isBit5Set = (1 == (((byte1 >> 4) & 1)))
            if isBit5Set:
                byte1 = (byte1 & -17)
                totalBytes = (totalBytes + 1)
                if (1 == (((byte1 >> 3) & 1))):
                    raise haxe_Exception.thrown((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
        result = (byte1 << ((6 * ((totalBytes - 1)))))
        byte = self.input.readByte()
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.byteIndex
        _hx_local_8.byteIndex = (_hx_local_9 + 1)
        _hx_local_9
        if (1 != (((byte >> 7) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        if (1 == (((byte >> 6) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        byte2 = (byte & -129)
        result = (result + ((byte2 << ((6 * ((totalBytes - 2)))))))
        if isBit6Set:
            byte = self.input.readByte()
            _hx_local_11 = self
            _hx_local_12 = _hx_local_11.byteIndex
            _hx_local_11.byteIndex = (_hx_local_12 + 1)
            _hx_local_12
            if (1 != (((byte >> 7) & 1))):
                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
            if (1 == (((byte >> 6) & 1))):
                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
            byte3 = (byte & -129)
            result = (result + ((byte3 << ((6 * ((totalBytes - 3)))))))
            if isBit5Set:
                byte = self.input.readByte()
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.byteIndex
                _hx_local_14.byteIndex = (_hx_local_15 + 1)
                _hx_local_15
                if (1 != (((byte >> 7) & 1))):
                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                if (1 == (((byte >> 6) & 1))):
                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                byte4 = (byte & -129)
                result = (result + ((byte4 << ((6 * ((totalBytes - 4)))))))
        if ((self.index == 0) and ((result == 65279))):
            return self.readUtf8Char()
        return result

    def readUtf8MultiSequenceByte(self):
        byte = self.input.readByte()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.byteIndex
        _hx_local_0.byteIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (1 != (((byte >> 7) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        if (1 == (((byte >> 6) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        return (byte & -129)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.byteIndex = None
        _hx_o.input = None
        _hx_o.currCharIndex = None
        _hx_o.nextChar = None
        _hx_o.nextCharAvailable = None
hx_strings__CharIterator_InputCharIterator._hx_class = hx_strings__CharIterator_InputCharIterator


class hx_strings__CharIterator_StringCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.StringCharIterator"
    __slots__ = ("chars", "charsMaxIndex")
    _hx_fields = ["chars", "charsMaxIndex"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.charsMaxIndex = None
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars
        self.charsMaxIndex = (((0 if ((chars is None)) else len(chars))) - 1)

    def isEOF(self):
        return (self.index >= self.charsMaxIndex)

    def getChar(self):
        return HxString.charCodeAt(self.chars,self.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
        _hx_o.charsMaxIndex = None
hx_strings__CharIterator_StringCharIterator._hx_class = hx_strings__CharIterator_StringCharIterator


class hx_strings_Pattern:
    _hx_class_name = "hx.strings.Pattern"
    __slots__ = ("pattern", "options", "ereg")
    _hx_fields = ["pattern", "options", "ereg"]
    _hx_methods = ["matcher", "replace", "remove", "split"]
    _hx_statics = ["__meta__", "compile"]

    def __init__(self,pattern,options):
        self.pattern = pattern
        self.options = options
        self.ereg = EReg(pattern,options)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.options
        _hx_local_0.options = (("null" if _hx_local_1 is None else _hx_local_1) + "u")
        _hx_local_0.options

    def matcher(self,_hx_str):
        return hx_strings__Pattern_MatcherImpl(self.ereg,self.pattern,self.options,_hx_str)

    def replace(self,_hx_str,replaceWith):
        return self.ereg.replace(_hx_str,replaceWith)

    def remove(self,_hx_str):
        return self.ereg.replace(_hx_str,"")

    def split(self,_hx_str):
        return self.ereg.split(_hx_str)

    @staticmethod
    def compile(pattern,options = None):
        if (options is None):
            return hx_strings_Pattern(pattern,"")
        _g = options
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 0):
            _hx_str = _g.params[0]
            str1 = hx_strings_Strings.toLowerCase8(_hx_str)
            if ((str1 is None) or ((len(str1) == 0))):
                tmp = str1
            else:
                def _hx_local_0(ch):
                    return "".join(map(chr,[ch]))
                def _hx_local_1(ch):
                    _this = None
                    strLen = len("i")
                    if (ch != ((-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt("i",0)))):
                        strLen = len("m")
                        _this = (ch == ((-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt("m",0))))
                    else:
                        _this = True
                    if (not _this):
                        strLen = len("g")
                        return (ch == ((-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt("g",0))))
                    else:
                        return True
                _this = list(map(_hx_local_0,list(filter(_hx_local_1,hx_strings_Strings.toChars(str1)))))
                tmp = "".join([python_Boot.toString1(x1,'') for x1 in _this])
        elif (tmp1 == 1):
            opt = _g.params[0]
            tmp = Std.string(opt)
        elif (tmp1 == 2):
            arr = _g.params[0]
            def _hx_local_2(m):
                return (m is not None)
            _this = list(filter(_hx_local_2,arr))
            tmp = "".join([python_Boot.toString1(x1,'') for x1 in _this])
        else:
            pass
        return hx_strings_Pattern(pattern,tmp)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.options = None
        _hx_o.ereg = None
hx_strings_Pattern._hx_class = hx_strings_Pattern


class hx_strings_Matcher:
    _hx_class_name = "hx.strings.Matcher"
    __slots__ = ()
    _hx_methods = ["iterate", "map", "matched", "matchedPos", "matches", "matchesInRegion", "reset", "substringAfterMatch", "substringBeforeMatch"]
    _hx_statics = ["__meta__"]
hx_strings_Matcher._hx_class = hx_strings_Matcher


class hx_strings__Pattern_MatcherImpl:
    _hx_class_name = "hx.strings._Pattern.MatcherImpl"
    __slots__ = ("ereg", "isMatch", "str")
    _hx_fields = ["ereg", "isMatch", "str"]
    _hx_methods = ["reset", "iterate", "map", "matched", "matches", "matchesInRegion", "matchedPos", "substringAfterMatch", "substringBeforeMatch", "_cloneEReg"]
    _hx_interfaces = [hx_strings_Matcher]

    def __init__(self,ereg,pattern,options,_hx_str):
        self.str = None
        self.isMatch = None
        self.ereg = None
        self.ereg = self._cloneEReg(ereg,pattern,options)
        self.str = _hx_str
        self.isMatch = None

    def reset(self,_hx_str):
        self.str = _hx_str
        self.isMatch = None
        return self

    def iterate(self,onMatch):
        startAt = 0
        while self.ereg.matchSub(self.str,startAt):
            self.isMatch = True
            _this = self.ereg
            matchedPos_pos = _this.matchObj.start()
            matchedPos_len = (_this.matchObj.end() - _this.matchObj.start())
            onMatch(self)
            startAt = (matchedPos_pos + matchedPos_len)
        self.isMatch = False

    def map(self,mapper):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(ereg):
                _gthis.isMatch = True
                return mapper(_gthis)
            return self.ereg.map(self.str,_hx_local_0)
        return _hx_local_1()

    def matched(self,n = None):
        if (n is None):
            n = 0
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            raise haxe_Exception.thrown("No string matched")
        result = self.ereg.matchObj.group(n)
        return result

    def matches(self):
        _this = self.ereg
        _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
        def _hx_local_1():
            def _hx_local_0():
                self.isMatch = (_this.matchObj is not None)
                return self.isMatch
            return _hx_local_0()
        return _hx_local_1()

    def matchesInRegion(self,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        def _hx_local_1():
            def _hx_local_0():
                self.isMatch = self.ereg.matchSub(self.str,pos,_hx_len)
                return self.isMatch
            return _hx_local_0()
        return _hx_local_1()

    def matchedPos(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            raise haxe_Exception.thrown("No string matched")
        _this = self.ereg
        return _hx_AnonObject({'pos': _this.matchObj.start(), 'len': (_this.matchObj.end() - _this.matchObj.start())})

    def substringAfterMatch(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            return ""
        _this = self.ereg
        return HxString.substr(_this.matchObj.string,_this.matchObj.end(),None)

    def substringBeforeMatch(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            return ""
        _this = self.ereg
        return HxString.substr(_this.matchObj.string,0,_this.matchObj.start())

    def _cloneEReg(self,_hx_from,pattern,options):
        clone = Type.createEmptyInstance(EReg)
        value = Reflect.field(_hx_from,"pattern")
        setattr(clone,(("_hx_" + "pattern") if (("pattern" in python_Boot.keywords)) else (("_hx_" + "pattern") if (((((len("pattern") > 2) and ((ord("pattern"[0]) == 95))) and ((ord("pattern"[1]) == 95))) and ((ord("pattern"[(len("pattern") - 1)]) != 95)))) else "pattern")),value)
        value = Reflect.field(_hx_from,"global")
        setattr(clone,(("_hx_" + "global") if (("global" in python_Boot.keywords)) else (("_hx_" + "global") if (((((len("global") > 2) and ((ord("global"[0]) == 95))) and ((ord("global"[1]) == 95))) and ((ord("global"[(len("global") - 1)]) != 95)))) else "global")),value)
        return clone

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ereg = None
        _hx_o.isMatch = None
        _hx_o.str = None
hx_strings__Pattern_MatcherImpl._hx_class = hx_strings__Pattern_MatcherImpl


class hx_strings_StringBuilder:
    _hx_class_name = "hx.strings.StringBuilder"
    __slots__ = ("sb", "pre", "len", "length")
    _hx_fields = ["sb", "pre", "len"]
    _hx_methods = ["get_length", "add", "addChar", "addAll", "clear", "isEmpty", "newLine", "insert", "insertChar", "insertAll", "asOutput", "toString"]

    def __init__(self,initialContent = None):
        self.length = None
        self.len = 0
        self.pre = None
        self.sb = StringBuf()
        if (initialContent is not None):
            self.add(initialContent)

    def get_length(self):
        return self.len

    def add(self,item):
        _this = self.sb
        s = Std.string(item)
        _this.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
        _hx_local_0.len
        return self

    def addChar(self,ch):
        _this = self.sb
        s = "".join(map(chr,[ch]))
        _this.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + 1)
        _hx_local_1
        return self

    def addAll(self,items):
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            _this = self.sb
            s = Std.string(item)
            _this.b.write(s)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.len
            _hx_local_1.len = (_hx_local_2 + (0 if ((item is None)) else len(item)))
            _hx_local_1.len
        return self

    def clear(self):
        self.pre = None
        self.sb = StringBuf()
        self.len = 0
        return self

    def isEmpty(self):
        return (self.len == 0)

    def newLine(self):
        self.sb.b.write("\n")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + 1)
        _hx_local_1
        return self

    def insert(self,pos,item):
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must not be negative")
        if (pos > self.len):
            raise haxe_Exception.thrown("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.add(item)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            self.pre.insert(0, item)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
            _hx_local_0.len
            return self
        pre_len = 0
        if (self.pre is not None):
            i = len(self.pre)
            _g = 0
            _g1 = len(self.pre)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _hx_str = (self.pre[i] if i >= 0 and i < len(self.pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    self.pre.insert((i + 1), item)
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.len
                    _hx_local_2.len = (_hx_local_3 + (0 if ((item is None)) else len(item)))
                    _hx_local_2.len
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((self.pre[i] if i >= 0 and i < len(self.pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(self.pre, i, (preSplitted[0] if 0 < len(preSplitted) else None))
                    self.pre.insert((i + 1), item)
                    self.pre.insert((i + 2), (preSplitted[1] if 1 < len(preSplitted) else None))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.len
                    _hx_local_4.len = (_hx_local_5 + (0 if ((item is None)) else len(item)))
                    _hx_local_4.len
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            self.add(item)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this.b.write(s)
        _this = self.sb
        s = Std.string(item)
        _this.b.write(s)
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.len
        _hx_local_6.len = (_hx_local_7 + (0 if ((item is None)) else len(item)))
        _hx_local_6.len
        _this = self.sb
        s = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this.b.write(s)
        return self

    def insertChar(self,pos,ch):
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must not be negative")
        if (pos > self.len):
            raise haxe_Exception.thrown("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.addChar(ch)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            _this = self.pre
            x = "".join(map(chr,[ch]))
            _this.insert(0, x)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + 1)
            _hx_local_1
            return self
        pre_len = 0
        if (self.pre is not None):
            i = len(self.pre)
            _g = 0
            _g1 = len(self.pre)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _hx_str = (self.pre[i] if i >= 0 and i < len(self.pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    _this = self.pre
                    x = "".join(map(chr,[ch]))
                    _this.insert((i + 1), x)
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.len
                    _hx_local_2.len = (_hx_local_3 + 1)
                    _hx_local_3
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((self.pre[i] if i >= 0 and i < len(self.pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(self.pre, i, (preSplitted[0] if 0 < len(preSplitted) else None))
                    _this1 = self.pre
                    x1 = "".join(map(chr,[ch]))
                    _this1.insert((i + 1), x1)
                    self.pre.insert((i + 2), (preSplitted[1] if 1 < len(preSplitted) else None))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.len
                    _hx_local_4.len = (_hx_local_5 + 1)
                    _hx_local_5
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            self.addChar(ch)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this.b.write(s)
        self.addChar(ch)
        _this = self.sb
        s = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this.b.write(s)
        return self

    def insertAll(self,pos,items):
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must not be negative")
        if (pos > self.len):
            raise haxe_Exception.thrown("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.addAll(items)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            i = len(items)
            while True:
                tmp = i
                i = (i - 1)
                if (not ((tmp > 0))):
                    break
                item = (items[i] if i >= 0 and i < len(items) else None)
                self.pre.insert(0, item)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.len
                _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
                _hx_local_0.len
            return self
        pre_len = 0
        if (self.pre is not None):
            i = len(self.pre)
            _g = 0
            _g1 = len(self.pre)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _hx_str = (self.pre[i] if i >= 0 and i < len(self.pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    j = len(items)
                    while True:
                        tmp = j
                        j = (j - 1)
                        if (not ((tmp > 0))):
                            break
                        item = (items[j] if j >= 0 and j < len(items) else None)
                        self.pre.insert((i + 1), item)
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.len
                        _hx_local_2.len = (_hx_local_3 + (0 if ((item is None)) else len(item)))
                        _hx_local_2.len
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((self.pre[i] if i >= 0 and i < len(self.pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(self.pre, i, (preSplitted[0] if 0 < len(preSplitted) else None))
                    self.pre.insert((i + 1), (preSplitted[1] if 1 < len(preSplitted) else None))
                    j1 = len(items)
                    while True:
                        tmp1 = j1
                        j1 = (j1 - 1)
                        if (not ((tmp1 > 0))):
                            break
                        item1 = (items[j1] if j1 >= 0 and j1 < len(items) else None)
                        self.pre.insert((i + 1), item1)
                        _hx_local_4 = self
                        _hx_local_5 = _hx_local_4.len
                        _hx_local_4.len = (_hx_local_5 + (0 if ((item1 is None)) else len(item1)))
                        _hx_local_4.len
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            _g = 0
            while (_g < len(items)):
                item = (items[_g] if _g >= 0 and _g < len(items) else None)
                _g = (_g + 1)
                self.add(item)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this.b.write(s)
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            _this = self.sb
            s = Std.string(item)
            _this.b.write(s)
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.len
            _hx_local_8.len = (_hx_local_9 + (0 if ((item is None)) else len(item)))
            _hx_local_8.len
        _this = self.sb
        s = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this.b.write(s)
        return self

    def asOutput(self):
        return hx_strings__StringBuilder_OutputWrapper(self)

    def toString(self):
        if (self.pre is None):
            return self.sb.b.getvalue()
        _this = self.pre
        _hx_str = (HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _this])) + HxOverrides.stringOrNull(self.sb.b.getvalue()))
        self.clear()
        self.add(_hx_str)
        return _hx_str

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sb = None
        _hx_o.pre = None
        _hx_o.len = None
hx_strings_StringBuilder._hx_class = hx_strings_StringBuilder


class hx_strings__StringBuilder_OutputWrapper(haxe_io_Output):
    _hx_class_name = "hx.strings._StringBuilder.OutputWrapper"
    __slots__ = ("sb", "bo")
    _hx_fields = ["sb", "bo"]
    _hx_methods = ["flush", "writeByte", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,sb):
        self.bo = None
        self.sb = sb

    def flush(self):
        if ((self.bo is not None) and ((len(self.bo.b.b) > 0))):
            self.sb.add(self.bo.getBytes().toString())

    def writeByte(self,c):
        if (self.bo is None):
            self.bo = haxe_io_BytesOutput()
        self.bo.writeByte(c)

    def writeString(self,_hx_str,encoding = None):
        self.flush()
        self.sb.add(_hx_str)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sb = None
        _hx_o.bo = None
hx_strings__StringBuilder_OutputWrapper._hx_class = hx_strings__StringBuilder_OutputWrapper


class hx_strings_internal_OS:
    _hx_class_name = "hx.strings.internal.OS"
    __slots__ = ()
    _hx_statics = ["isWindows"]
hx_strings_internal_OS._hx_class = hx_strings_internal_OS

class hx_strings_internal__Either3__Either3(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.internal._Either3._Either3"
    _hx_constructs = ["a", "b", "c"]

    @staticmethod
    def a(v):
        return hx_strings_internal__Either3__Either3("a", 0, (v,))

    @staticmethod
    def b(v):
        return hx_strings_internal__Either3__Either3("b", 1, (v,))

    @staticmethod
    def c(v):
        return hx_strings_internal__Either3__Either3("c", 2, (v,))
hx_strings_internal__Either3__Either3._hx_class = hx_strings_internal__Either3__Either3


class hx_strings_Strings:
    _hx_class_name = "hx.strings.Strings"
    __slots__ = ()
    _hx_statics = ["REGEX_ANSI_ESC", "REGEX_HTML_UNESCAPE", "REGEX_SPLIT_LINES", "REGEX_REMOVE_XML_TAGS", "POS_NOT_FOUND", "NEW_LINE_NIX", "NEW_LINE_WIN", "NEW_LINE", "_getNotFoundDefault", "_charCodeAt8Unsafe", "_splitAsciiWordsUnsafe", "ansiToHtml", "appendIfMissing", "base64Encode", "base64Decode", "charAt8", "charCodeAt8", "compact", "contains", "containsOnly", "containsAll", "containsAllIgnoreCase", "containsAny", "containsAnyIgnoreCase", "containsNone", "containsNoneIgnoreCase", "containsWhitespaces", "countMatches", "countMatchesIgnoreCase", "compare", "compareIgnoreCase", "diff", "diffAt", "ellipsizeLeft", "ellipsizeMiddle", "ellipsizeRight", "endsWith", "endsWithAny", "endsWithAnyIgnoreCase", "endsWithIgnoreCase", "equals", "equalsIgnoreCase", "filter", "filterChars", "getFuzzyDistance", "getLevenshteinDistance", "getLongestCommonSubstring", "hashCode", "htmlDecode", "htmlEncode", "insertAt", "ifBlank", "ifEmpty", "ifNull", "indentLines", "indexOf8", "isBlank", "isDigits", "isEmpty", "isNotBlank", "isNotEmpty", "isLowerCase", "isUpperCase", "iterate", "iterateChars", "lastIndexOf8", "length8", "left", "lpad", "map", "prependIfMissing", "quoteDouble", "quoteSingle", "removeAfter", "removeAfterLast", "removeAfterIgnoreCase", "removeAfterLastIgnoreCase", "removeAt", "removeBefore", "removeBeforeLast", "removeBeforeIgnoreCase", "removeBeforeLastIgnoreCase", "removeAll", "removeFirst", "removeFirstIgnoreCase", "removeAnsi", "removeLeading", "removeTags", "removeTrailing", "repeat", "replaceAll", "replaceFirst", "replaceFirstIgnoreCase", "reverse", "right", "rpad", "split8", "splitAt", "splitEvery", "splitLines", "startsWith", "startsWithAny", "startsWithAnyIgnoreCase", "startsWithIgnoreCase", "substr8", "substring8", "substringAfter", "substringAfterIgnoreCase", "substringBetween", "substringBetweenIgnoreCase", "substringAfterLast", "substringAfterLastIgnoreCase", "substringBefore", "substringBeforeIgnoreCase", "substringBeforeLast", "substringBeforeLastIgnoreCase", "toBool", "toBytes", "toChar", "toCharIterator", "toChars", "toPattern", "toEReg", "toFloat", "toHex", "toInt", "toLowerCase8", "toLowerCaseFirstChar", "toLowerCamel", "toLowerHyphen", "toLowerUnderscore", "toTitle", "toUpperCamel", "toUpperUnderscore", "toString", "toUpperCase8", "toUpperCaseFirstChar", "trim", "trimRight", "trimLeft", "trimLines", "trimToNull", "trimToEmpty", "truncate", "urlDecode", "urlEncode", "wrap"]

    @staticmethod
    def _getNotFoundDefault(_hx_str,notFoundDefault):
        notFoundDefault1 = notFoundDefault
        if (notFoundDefault1 == 1):
            return None
        elif (notFoundDefault1 == 2):
            return ""
        elif (notFoundDefault1 == 3):
            return _hx_str
        else:
            pass

    @staticmethod
    def _charCodeAt8Unsafe(_hx_str,pos):
        return HxString.charCodeAt(_hx_str,pos)

    @staticmethod
    def _splitAsciiWordsUnsafe(_hx_str):
        words = list()
        currentWord = hx_strings_StringBuilder()
        chars = hx_strings_Strings.toChars(_hx_str)
        _hx_len = len(chars)
        lastIndex = (_hx_len - 1)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = (chars[i] if i >= 0 and i < len(chars) else None)
            if (((ch > 64) and ((ch < 91))) or (((ch > 96) and ((ch < 123))))):
                chNext = (python_internal_ArrayImpl._get(chars, (i + 1)) if ((i < lastIndex)) else -1)
                currentWord.addChar(ch)
                if ((chNext > 47) and ((chNext < 58))):
                    x = currentWord.toString()
                    words.append(x)
                    currentWord.clear()
                elif (ch in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h):
                    if ((chNext in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h) and ((len(chars) > ((i + 2))))):
                        if (not (python_internal_ArrayImpl._get(chars, (i + 2)) in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h)):
                            x1 = currentWord.toString()
                            words.append(x1)
                            currentWord.clear()
                elif (chNext in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h):
                    x2 = currentWord.toString()
                    words.append(x2)
                    currentWord.clear()
            elif ((ch > 47) and ((ch < 58))):
                currentWord.addChar(ch)
                chNext1 = (python_internal_ArrayImpl._get(chars, (i + 1)) if ((i < lastIndex)) else -1)
                if (not (((chNext1 > 47) and ((chNext1 < 58))))):
                    x3 = currentWord.toString()
                    words.append(x3)
                    currentWord.clear()
            elif (currentWord.len > 0):
                x4 = currentWord.toString()
                words.append(x4)
                currentWord.clear()
        if (currentWord.len > 0):
            x = currentWord.toString()
            words.append(x)
        return words

    @staticmethod
    def ansiToHtml(_hx_str,renderMethod = None,initialState = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (renderMethod is None):
            renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes
        styleOrClassAttribute = None
        styleOrClassAttribute1 = renderMethod.index
        if (styleOrClassAttribute1 == 0):
            styleOrClassAttribute = "style"
        elif (styleOrClassAttribute1 == 1):
            styleOrClassAttribute = "class"
        elif (styleOrClassAttribute1 == 2):
            cb = renderMethod.params[0]
            styleOrClassAttribute = "class"
        else:
            pass
        sb = hx_strings_StringBuilder()
        if ((initialState is not None) and ((((((initialState.fgcolor is not None) or ((initialState.bgcolor is not None))) or initialState.bold) or initialState.underline) or initialState.blink))):
            sb.add((("<span " + ("null" if styleOrClassAttribute is None else styleOrClassAttribute)) + "=\"")).add(initialState.toCSS(renderMethod)).add("\">")
        effectiveState = hx_strings_AnsiState(initialState)
        strLenMinus1 = (((0 if ((_hx_str is None)) else len(_hx_str))) - 1)
        i = -1
        lookAhead = hx_strings_StringBuilder()
        while (i < strLenMinus1):
            i = (i + 1)
            ch = HxString.charCodeAt(_hx_str,i)
            if (((ch == 27) and ((i < strLenMinus1))) and ((HxString.charCodeAt(_hx_str,(i + 1)) == 91))):
                lookAhead.clear()
                currentState = hx_strings_AnsiState(effectiveState)
                currentGraphicModeParam = 0
                isValidEscapeSequence = False
                i = (i + 1)
                while (i < strLenMinus1):
                    i = (i + 1)
                    ch2 = HxString.charCodeAt(_hx_str,i)
                    lookAhead.addChar(ch2)
                    ch21 = ch2
                    if (ch21 == 48):
                        currentGraphicModeParam = (currentGraphicModeParam * 10)
                    elif (ch21 == 49):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 1)
                    elif (ch21 == 50):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 2)
                    elif (ch21 == 51):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 3)
                    elif (ch21 == 52):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 4)
                    elif (ch21 == 53):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 5)
                    elif (ch21 == 54):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 6)
                    elif (ch21 == 55):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 7)
                    elif (ch21 == 56):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 8)
                    elif (ch21 == 57):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 9)
                    elif (ch21 == 59):
                        currentState.setGraphicModeParameter(currentGraphicModeParam)
                        currentGraphicModeParam = 0
                    elif (ch21 == 109):
                        currentState.setGraphicModeParameter(currentGraphicModeParam)
                        if (((((effectiveState.fgcolor is not None) or ((effectiveState.bgcolor is not None))) or effectiveState.bold) or effectiveState.underline) or effectiveState.blink):
                            sb.add("</span>")
                        if (((((currentState.fgcolor is not None) or ((currentState.bgcolor is not None))) or currentState.bold) or currentState.underline) or currentState.blink):
                            sb.add((("<span " + ("null" if styleOrClassAttribute is None else styleOrClassAttribute)) + "=\"")).add(currentState.toCSS(renderMethod)).add("\">")
                        effectiveState = currentState
                        isValidEscapeSequence = True
                        break
                    else:
                        break
                if (not isValidEscapeSequence):
                    sb.addChar(27).add("[").add(Std.string(lookAhead))
            else:
                sb.addChar(ch)
        if (((((effectiveState.fgcolor is not None) or ((effectiveState.bgcolor is not None))) or effectiveState.bold) or effectiveState.underline) or effectiveState.blink):
            sb.add("</span>")
        return sb.toString()

    @staticmethod
    def appendIfMissing(_hx_str,suffix):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return (("null" if _hx_str is None else _hx_str) + ("null" if suffix is None else suffix))
        if hx_strings_Strings.endsWith(_hx_str,suffix):
            return _hx_str
        return (("null" if _hx_str is None else _hx_str) + ("null" if suffix is None else suffix))

    @staticmethod
    def base64Encode(plain):
        if (plain is None):
            return None
        return haxe_crypto_Base64.encode((None if ((plain is None)) else haxe_io_Bytes.ofString(plain)))

    @staticmethod
    def base64Decode(encoded):
        if (encoded is None):
            return None
        return haxe_crypto_Base64.decode(encoded).toString()

    @staticmethod
    def charAt8(_hx_str,pos,resultIfOutOfBound = None):
        if (resultIfOutOfBound is None):
            resultIfOutOfBound = ""
        if ((((_hx_str is None) or ((len(_hx_str) == 0))) or ((pos < 0))) or ((pos >= ((0 if ((_hx_str is None)) else len(_hx_str)))))):
            return resultIfOutOfBound
        if ((pos < 0) or ((pos >= len(_hx_str)))):
            return ""
        else:
            return _hx_str[pos]

    @staticmethod
    def charCodeAt8(_hx_str,pos,resultIfOutOfBound = None):
        if (resultIfOutOfBound is None):
            resultIfOutOfBound = -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (((strLen == 0) or ((pos < 0))) or ((pos >= strLen))):
            return resultIfOutOfBound
        return HxString.charCodeAt(_hx_str,pos)

    @staticmethod
    def compact(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        needWhiteSpace = False
        _g = 0
        _g1 = hx_strings_Strings.toChars(_hx_str)
        while (_g < len(_g1)):
            char = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((char > 8) and ((char < 14))) or ((char == 32))):
                if (sb.len != 0):
                    needWhiteSpace = True
                continue
            elif needWhiteSpace:
                sb.addChar(32)
                needWhiteSpace = False
            sb.addChar(char)
        return sb.toString()

    @staticmethod
    def contains(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if (searchFor == ""):
            return True
        startIndex = None
        return (((searchIn.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor,startIndex))) > -1)

    @staticmethod
    def containsOnly(searchIn,allowedChars):
        if ((searchIn is None) or ((len(searchIn) == 0))):
            return True
        if (allowedChars is None):
            return False
        allowedCharsArray = None
        _g = allowedChars
        allowedCharsArray1 = _g.index
        if (allowedCharsArray1 == 0):
            _hx_str = _g.params[0]
            allowedCharsArray = hx_strings_Strings.toChars(_hx_str)
        elif (allowedCharsArray1 == 1):
            chars = _g.params[0]
            allowedCharsArray = chars
        else:
            pass
        _g = 0
        _g1 = hx_strings_Strings.toChars(searchIn)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (python_internal_ArrayImpl.indexOf(allowedCharsArray,ch,None) < 0):
                return False
        return True

    @staticmethod
    def containsAll(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            tmp = None
            if ((searchIn is None) or ((candidate is None))):
                tmp = False
            elif (candidate == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(candidate) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,candidate,startIndex))) > -1)
            if (not tmp):
                return False
        return True

    @staticmethod
    def containsAllIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = searchIn.lower()
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            searchFor1 = candidate.lower()
            tmp = None
            if ((searchIn is None) or ((searchFor1 is None))):
                tmp = False
            elif (searchFor1 == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(searchFor1) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor1,startIndex))) > -1)
            if (not tmp):
                return False
        return True

    @staticmethod
    def containsAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            tmp = None
            if ((searchIn is None) or ((candidate is None))):
                tmp = False
            elif (candidate == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(candidate) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,candidate,startIndex))) > -1)
            if tmp:
                return True
        return False

    @staticmethod
    def containsAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = searchIn.lower()
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            searchFor1 = candidate.lower()
            tmp = None
            if ((searchIn is None) or ((searchFor1 is None))):
                tmp = False
            elif (searchFor1 == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(searchFor1) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor1,startIndex))) > -1)
            if tmp:
                return True
        return False

    @staticmethod
    def containsNone(searchIn,searchFor):
        return (not hx_strings_Strings.containsAny(searchIn,searchFor))

    @staticmethod
    def containsNoneIgnoreCase(searchIn,searchFor):
        return (not hx_strings_Strings.containsAnyIgnoreCase(searchIn,searchFor))

    @staticmethod
    def containsWhitespaces(searchIn):
        if (searchIn is None):
            return False
        _g = 0
        _g1 = hx_strings_Strings.toChars(searchIn)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((ch > 8) and ((ch < 14))) or ((ch == 32))):
                return True
        return False

    @staticmethod
    def countMatches(searchIn,searchFor,startAt = None):
        if (startAt is None):
            startAt = 0
        if ((((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))) or ((startAt >= len(searchIn)))):
            return 0
        if (startAt < 0):
            startAt = 0
        count = 0
        foundAt = ((startAt - 1) if ((startAt > -1)) else 0)
        while True:
            startIndex = (foundAt + 1)
            foundAt = (searchIn.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor,startIndex))
            if (not ((foundAt > -1))):
                break
            count = (count + 1)
        return count

    @staticmethod
    def countMatchesIgnoreCase(searchIn,searchFor,startAt = None):
        if (startAt is None):
            startAt = 0
        if ((((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))) or ((startAt >= len(searchIn)))):
            return 0
        if (startAt < 0):
            startAt = 0
        searchIn = searchIn.lower()
        searchFor = searchFor.lower()
        count = 0
        foundAt = ((startAt - 1) if ((startAt > -1)) else 0)
        while True:
            startIndex = (foundAt + 1)
            foundAt = (searchIn.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor,startIndex))
            if (not ((foundAt > -1))):
                break
            count = (count + 1)
        return count

    @staticmethod
    def compare(_hx_str,other):
        if (_hx_str is None):
            if (other is None):
                return 0
            else:
                return -1
        if (other is None):
            if (_hx_str is None):
                return 0
            else:
                return 1
        if (_hx_str > other):
            return 1
        elif (_hx_str == other):
            return 0
        else:
            return -1

    @staticmethod
    def compareIgnoreCase(_hx_str,other):
        if (_hx_str is None):
            if (other is None):
                return 0
            else:
                return -1
        if (other is None):
            if (_hx_str is None):
                return 0
            else:
                return 1
        _hx_str = hx_strings_Strings.toLowerCase8(_hx_str)
        other = hx_strings_Strings.toLowerCase8(other)
        if (_hx_str > other):
            return 1
        elif (_hx_str == other):
            return 0
        else:
            return -1

    @staticmethod
    def diff(left,right):
        diff = hx_strings_StringDiff()
        diff.at = hx_strings_Strings.diffAt(left,right)
        diff.left = hx_strings_Strings.substr8(left,diff.at)
        diff.right = hx_strings_Strings.substr8(right,diff.at)
        return diff

    @staticmethod
    def diffAt(_hx_str,other):
        if (_hx_str == other):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        otherLen = (0 if ((other is None)) else len(other))
        if ((strLen == 0) or ((otherLen == 0))):
            return 0
        checkLen = (otherLen if ((strLen > otherLen)) else strLen)
        _g = 0
        _g1 = checkLen
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (HxString.charCodeAt(_hx_str,i) != HxString.charCodeAt(other,i)):
                return i
        return checkLen

    @staticmethod
    def ellipsizeLeft(_hx_str,maxLength,ellipsis = None):
        if (ellipsis is None):
            ellipsis = "..."
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise haxe_Exception.thrown(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        return (("null" if ellipsis is None else ellipsis) + HxOverrides.stringOrNull(hx_strings_Strings.right(_hx_str,(maxLength - ellipsisLen))))

    @staticmethod
    def ellipsizeMiddle(_hx_str,maxLength,ellipsis = None):
        if (ellipsis is None):
            ellipsis = "..."
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise haxe_Exception.thrown(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        maxStrLen = (maxLength - ellipsisLen)
        leftLen = Math.floor(((maxStrLen / 2) + 0.5))
        rightLen = (maxStrLen - leftLen)
        return ((HxOverrides.stringOrNull(((_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= leftLen)) else hx_strings_Strings.substring8(_hx_str,0,leftLen)))) + ("null" if ellipsis is None else ellipsis)) + HxOverrides.stringOrNull(hx_strings_Strings.right(_hx_str,rightLen)))

    @staticmethod
    def ellipsizeRight(_hx_str,maxLength,ellipsis = None):
        if (ellipsis is None):
            ellipsis = "..."
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise haxe_Exception.thrown(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        _hx_len = (maxLength - ellipsisLen)
        return (HxOverrides.stringOrNull(((_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= _hx_len)) else hx_strings_Strings.substring8(_hx_str,0,_hx_len)))) + ("null" if ellipsis is None else ellipsis))

    @staticmethod
    def endsWith(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        return searchIn.endswith(searchFor)

    @staticmethod
    def endsWithAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.endsWith(searchIn,candidate)):
                return True
        return False

    @staticmethod
    def endsWithAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = hx_strings_Strings.toLowerCase8(searchIn)
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.endsWith(searchIn,hx_strings_Strings.toLowerCase8(candidate))):
                return True
        return False

    @staticmethod
    def endsWithIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        return hx_strings_Strings.endsWith(searchIn.lower(),searchFor.lower())

    @staticmethod
    def equals(_hx_str,other):
        return (_hx_str == other)

    @staticmethod
    def equalsIgnoreCase(_hx_str,other):
        return (hx_strings_Strings.toLowerCase8(_hx_str) == hx_strings_Strings.toLowerCase8(other))

    @staticmethod
    def filter(_hx_str,_hx_filter,separator = None):
        if (separator is None):
            separator = ""
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        _this = list(filter(_hx_filter,hx_strings_Strings.split8(_hx_str,[separator])))
        return separator.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def filterChars(_hx_str,_hx_filter):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(ch):
            return "".join(map(chr,[ch]))
        _this = list(map(_hx_local_0,list(filter(_hx_filter,hx_strings_Strings.toChars(_hx_str)))))
        return "".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def getFuzzyDistance(left,right):
        if (((left is None) or ((len(left) == 0))) or (((right is None) or ((len(right) == 0))))):
            return 0
        left = hx_strings_Strings.toLowerCase8(left)
        right = hx_strings_Strings.toLowerCase8(right)
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        leftLastMatchAt = -100
        rightLastMatchAt = -100
        score = 0
        _g = 0
        _g1 = len(leftChars)
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            leftChar = (leftChars[leftIdx] if leftIdx >= 0 and leftIdx < len(leftChars) else None)
            _g2 = ((rightLastMatchAt + 1) if ((rightLastMatchAt > -1)) else 0)
            _g3 = len(rightChars)
            while (_g2 < _g3):
                rightIdx = _g2
                _g2 = (_g2 + 1)
                rightChar = (rightChars[rightIdx] if rightIdx >= 0 and rightIdx < len(rightChars) else None)
                if (leftChar == rightChar):
                    score = (score + 1)
                    if ((leftLastMatchAt == ((leftIdx - 1))) and ((rightLastMatchAt == ((rightIdx - 1))))):
                        score = (score + 2)
                    leftLastMatchAt = leftIdx
                    rightLastMatchAt = rightIdx
                    break
        return score

    @staticmethod
    def getLevenshteinDistance(left,right):
        leftLen = (0 if ((left is None)) else len(left))
        rightLen = (0 if ((right is None)) else len(right))
        if (leftLen == 0):
            return rightLen
        if (rightLen == 0):
            return leftLen
        if (leftLen > rightLen):
            tmp = left
            left = right
            right = tmp
            tmpLen = leftLen
            leftLen = rightLen
            rightLen = tmpLen
        prevCosts = list()
        costs = list()
        _g = 0
        _g1 = (leftLen + 1)
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            prevCosts.append(leftIdx)
            costs.append(0)
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        def _hx_local_0(a,b):
            if (a > b):
                return b
            else:
                return a
        _hx_min = _hx_local_0
        _g = 1
        _g1 = (rightLen + 1)
        while (_g < _g1):
            rightIdx = _g
            _g = (_g + 1)
            rightChar = python_internal_ArrayImpl._get(rightChars, (rightIdx - 1))
            python_internal_ArrayImpl._set(costs, 0, rightIdx)
            _g2 = 1
            _g3 = (leftLen + 1)
            while (_g2 < _g3):
                leftIdx = _g2
                _g2 = (_g2 + 1)
                leftIdxMinus1 = (leftIdx - 1)
                cost = (0 if (((leftChars[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(leftChars) else None) == rightChar)) else 1)
                python_internal_ArrayImpl._set(costs, leftIdx, _hx_min(_hx_min(((costs[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(costs) else None) + 1),((prevCosts[leftIdx] if leftIdx >= 0 and leftIdx < len(prevCosts) else None) + 1)),((prevCosts[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(prevCosts) else None) + cost)))
            tmp = prevCosts
            prevCosts = costs
            costs = tmp
        return (prevCosts[leftLen] if leftLen >= 0 and leftLen < len(prevCosts) else None)

    @staticmethod
    def getLongestCommonSubstring(left,right):
        if ((left is None) or ((right is None))):
            return None
        leftLen = (0 if ((left is None)) else len(left))
        rightLen = (0 if ((right is None)) else len(right))
        if ((leftLen == 0) or ((rightLen == 0))):
            return ""
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        leftSubStartAt = 0
        leftSubLen = 0
        _g = 0
        _g1 = leftLen
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = rightLen
            while (_g2 < _g3):
                rightIdx = _g2
                _g2 = (_g2 + 1)
                currLen = 0
                while (python_internal_ArrayImpl._get(leftChars, (leftIdx + currLen)) == python_internal_ArrayImpl._get(rightChars, (rightIdx + currLen))):
                    currLen = (currLen + 1)
                    if (((leftIdx + currLen) >= leftLen) or (((rightIdx + currLen) >= rightLen))):
                        break
                if (currLen > leftSubLen):
                    leftSubLen = currLen
                    leftSubStartAt = leftIdx
        return hx_strings_Strings.substr8(left,leftSubStartAt,leftSubLen)

    @staticmethod
    def hashCode(_hx_str,algo = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return 0
        if (algo is None):
            algo = hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC
        if (algo is None):
            return hash(_hx_str)
        else:
            tmp = algo.index
            if (tmp == 1):
                return haxe_crypto_Adler32.make((None if ((_hx_str is None)) else haxe_io_Bytes.ofString(_hx_str)))
            elif (tmp == 2):
                return haxe_crypto_Crc32.make((None if ((_hx_str is None)) else haxe_io_Bytes.ofString(_hx_str)))
            elif (tmp == 3):
                hc = 5381
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = (((((((((((hc << 5)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) ^ ch)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            elif (tmp == 4):
                hc = 0
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = ((((((((((hc << 5)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + ch) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            elif (tmp == 5):
                hc = 0
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = (((((((((((((hc << 6)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (((((hc << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + ch) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            else:
                return hash(_hx_str)

    @staticmethod
    def htmlDecode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        _this = hx_strings_Strings.REGEX_HTML_UNESCAPE
        def _hx_local_2():
            def _hx_local_1(m):
                match = m.matched()
                match1 = match
                _hx_local_0 = len(match1)
                if (_hx_local_0 == 5):
                    if (match1 == "&amp;"):
                        return "&"
                    else:
                        this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        return "".join(map(chr,[this1]))
                elif (_hx_local_0 == 4):
                    if (match1 == "&gt;"):
                        return ">"
                    elif (match1 == "&lt;"):
                        return "<"
                    else:
                        this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        return "".join(map(chr,[this1]))
                elif (_hx_local_0 == 6):
                    if (match1 == "&apos;"):
                        return "'"
                    elif (match1 == "&nbsp;"):
                        return " "
                    elif (match1 == "&quot;"):
                        return "\""
                    else:
                        this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        return "".join(map(chr,[this1]))
                else:
                    this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                    return "".join(map(chr,[this1]))
            return hx_strings__Pattern_MatcherImpl(_this.ereg,_this.pattern,_this.options,_hx_str).map(_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def htmlEncode(_hx_str,escapeQuotes = None):
        if (escapeQuotes is None):
            escapeQuotes = False
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        isFirstSpace = True
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = HxString.charCodeAt(_hx_str,i)
            ch1 = ch
            if (ch1 == 32):
                if isFirstSpace:
                    sb.add(" ")
                    isFirstSpace = False
                else:
                    sb.add("&nbsp;")
            elif (ch1 == 34):
                sb.add(("&quot;" if escapeQuotes else "\""))
            elif (ch1 == 38):
                sb.add("&amp;")
            elif (ch1 == 39):
                sb.add(("&#039;" if escapeQuotes else "'"))
            elif (ch1 == 60):
                sb.add("&lt;")
            elif (ch1 == 62):
                sb.add("&gt;")
            elif (ch > 127):
                sb.add("&#").add(Std.string(ch)).add(";")
            else:
                sb.addChar(ch)
            if (ch != 32):
                isFirstSpace = True
        return sb.toString()

    @staticmethod
    def insertAt(_hx_str,pos,insertion):
        if (_hx_str is None):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (pos < 0):
            pos = (strLen + pos)
        if ((pos < 0) or ((pos > strLen))):
            raise haxe_Exception.thrown("Absolute value of [pos] must be <= str.length")
        if ((insertion is None) or ((len(insertion) == 0))):
            return _hx_str
        return ((HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,0,pos)) + Std.string(insertion)) + HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,pos)))

    @staticmethod
    def ifBlank(_hx_str,fallback):
        if (True if ((_hx_str is None)) else (len(StringTools.trim(_hx_str)) == 0)):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def ifEmpty(_hx_str,fallback):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def ifNull(_hx_str,fallback):
        if (_hx_str is None):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def indentLines(_hx_str,indentWith):
        if (_hx_str is None):
            return None
        if ((len(_hx_str) == 0) or (((indentWith is None) or ((len(indentWith) == 0))))):
            return _hx_str
        isFirstLine = True
        sb = hx_strings_StringBuilder()
        _g = 0
        _g1 = hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if isFirstLine:
                isFirstLine = False
            else:
                sb.newLine()
            sb.add(indentWith)
            sb.add(line)
        return sb.toString()

    @staticmethod
    def indexOf8(_hx_str,searchFor,startAt = None):
        if (startAt is None):
            startAt = 0
        if ((_hx_str is None) or ((searchFor is None))):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        searchForLen = (0 if ((searchFor is None)) else len(searchFor))
        if (startAt < 0):
            startAt = 0
        if (searchForLen == 0):
            if (startAt == 0):
                return 0
            if ((startAt > 0) and ((startAt < strLen))):
                return startAt
            return strLen
        if (startAt >= strLen):
            return -1
        if (startAt is None):
            return _hx_str.find(searchFor)
        else:
            return HxString.indexOfImpl(_hx_str,searchFor,startAt)

    @staticmethod
    def isBlank(_hx_str):
        if (_hx_str is None):
            return True
        else:
            return (len(StringTools.trim(_hx_str)) == 0)

    @staticmethod
    def isDigits(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = HxString.charCodeAt(_hx_str,i)
            if (not (((this1 > 47) and ((this1 < 58))))):
                return False
        return True

    @staticmethod
    def isEmpty(_hx_str):
        if (_hx_str is not None):
            return (len(_hx_str) == 0)
        else:
            return True

    @staticmethod
    def isNotBlank(_hx_str):
        if (_hx_str is not None):
            return (len(StringTools.trim(_hx_str)) > 0)
        else:
            return False

    @staticmethod
    def isNotEmpty(_hx_str):
        if (_hx_str is not None):
            return (len(_hx_str) > 0)
        else:
            return False

    @staticmethod
    def isLowerCase(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        return (_hx_str == hx_strings_Strings.toLowerCase8(_hx_str))

    @staticmethod
    def isUpperCase(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        return (_hx_str == hx_strings_Strings.toUpperCase8(_hx_str))

    @staticmethod
    def iterate(_hx_str,callback,separator = None):
        if (separator is None):
            separator = ""
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return
        _g = 0
        _g1 = hx_strings_Strings.split8(_hx_str,[separator])
        while (_g < len(_g1)):
            sub = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            callback(sub)

    @staticmethod
    def iterateChars(_hx_str,callback):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            callback(HxString.charCodeAt(_hx_str,i))

    @staticmethod
    def lastIndexOf8(_hx_str,searchFor,startAt = None):
        if ((_hx_str is None) or ((searchFor is None))):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        searchForLen = (0 if ((searchFor is None)) else len(searchFor))
        if (startAt is None):
            startAt = strLen
        if (searchForLen == 0):
            if (startAt < 0):
                return 0
            if (startAt > strLen):
                return strLen
            return startAt
        if (startAt < 0):
            return -1
        elif (startAt >= strLen):
            startAt = (strLen - 1)
        strNeedsUTF8Workaround = (len(_hx_str) != strLen)
        searchForNeedsUTF8Workaround = (len(searchFor) != searchForLen)
        if (searchForNeedsUTF8Workaround and (not strNeedsUTF8Workaround)):
            return -1
        searchForChars = hx_strings_Strings.toChars(searchFor)
        startAt = (startAt + ((searchForLen - 1)))
        searchForPosToCheck = (searchForLen - 1)
        strPos = strLen
        while True:
            tmp = strPos
            strPos = (strPos - 1)
            if (not ((tmp > 0))):
                break
            if (strPos > startAt):
                continue
            strCh = HxString.charCodeAt(_hx_str,strPos)
            if (strCh == (searchForChars[searchForPosToCheck] if searchForPosToCheck >= 0 and searchForPosToCheck < len(searchForChars) else None)):
                if (searchForPosToCheck == 0):
                    return strPos
                searchForPosToCheck = (searchForPosToCheck - 1)
            else:
                searchForPosToCheck = (searchForLen - 1)
        return -1

    @staticmethod
    def length8(_hx_str):
        if (_hx_str is None):
            return 0
        return len(_hx_str)

    @staticmethod
    def left(_hx_str,_hx_len):
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= _hx_len):
            return _hx_str
        return hx_strings_Strings.substring8(_hx_str,0,_hx_len)

    @staticmethod
    def lpad(_hx_str,targetLength,padStr = None,canOverflow = None):
        if (padStr is None):
            padStr = " "
        if (canOverflow is None):
            canOverflow = True
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((_hx_str is None) or ((strLen > targetLength))):
            return _hx_str
        if ((padStr is None) or ((len(padStr) == 0))):
            padStr = " "
        sb = [_hx_str]
        padLen = (0 if ((padStr is None)) else len(padStr))
        while (strLen < targetLength):
            sb.insert(0, padStr)
            strLen = (strLen + padLen)
        if canOverflow:
            return "".join([python_Boot.toString1(x1,'') for x1 in sb])
        return hx_strings_Strings.right("".join([python_Boot.toString1(x1,'') for x1 in sb]),targetLength)

    @staticmethod
    def map(_hx_str,mapper,separator = None):
        if (separator is None):
            separator = ""
        if (_hx_str is None):
            return None
        if (separator is None):
            raise haxe_Exception.thrown("[separator] must not be null")
        return list(map(mapper,hx_strings_Strings.split8(_hx_str,[separator])))

    @staticmethod
    def prependIfMissing(_hx_str,suffix):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return (("null" if suffix is None else suffix) + ("null" if _hx_str is None else _hx_str))
        if hx_strings_Strings.startsWith(_hx_str,suffix):
            return _hx_str
        return (("null" if suffix is None else suffix) + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def quoteDouble(_hx_str):
        if (_hx_str is None):
            return _hx_str
        if (len(_hx_str) == 0):
            return "\"\""
        tmp = None
        if (_hx_str is None):
            tmp = False
        else:
            startIndex = None
            tmp = (((_hx_str.find("\"") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"\"",startIndex))) > -1)
        if (not tmp):
            return (("\"" + ("null" if _hx_str is None else _hx_str)) + "\"")
        return (("\"" + HxOverrides.stringOrNull(hx_strings_Strings.replaceAll(_hx_str,"\"","\\\""))) + "\"")

    @staticmethod
    def quoteSingle(_hx_str):
        if (_hx_str is None):
            return _hx_str
        if (len(_hx_str) == 0):
            return "''"
        tmp = None
        if (_hx_str is None):
            tmp = False
        else:
            startIndex = None
            tmp = (((_hx_str.find("'") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"'",startIndex))) > -1)
        if (not tmp):
            return (("'" + ("null" if _hx_str is None else _hx_str)) + "'")
        return (("'" + HxOverrides.stringOrNull(hx_strings_Strings.replaceAll(_hx_str,"'","\\'"))) + "'")

    @staticmethod
    def removeAfter(_hx_str,searchFor):
        return hx_strings_Strings.substringBefore(_hx_str,searchFor)

    @staticmethod
    def removeAfterLast(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeLast(_hx_str,searchFor)

    @staticmethod
    def removeAfterIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAfterLastIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeLastIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAt(_hx_str,pos,length):
        if (((_hx_str is None) or ((len(_hx_str) == 0))) or ((length < 1))):
            return _hx_str
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (pos < 0):
            pos = (strLen + pos)
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must be smaller than -1 * str.length")
        if ((pos + length) >= strLen):
            return hx_strings_Strings.substring8(_hx_str,0,pos)
        return (HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,0,pos)) + HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,(pos + length))))

    @staticmethod
    def removeBefore(_hx_str,searchFor):
        return hx_strings_Strings.substringAfter(_hx_str,searchFor)

    @staticmethod
    def removeBeforeLast(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterLast(_hx_str,searchFor)

    @staticmethod
    def removeBeforeIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeBeforeLastIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterLastIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAll(searchIn,searchFor):
        return hx_strings_Strings.replaceAll(searchIn,searchFor,"")

    @staticmethod
    def removeFirst(searchIn,searchFor):
        return hx_strings_Strings.replaceFirst(searchIn,searchFor,"")

    @staticmethod
    def removeFirstIgnoreCase(searchIn,searchFor):
        return hx_strings_Strings.replaceFirstIgnoreCase(searchIn,searchFor,"")

    @staticmethod
    def removeAnsi(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return hx_strings_Strings.REGEX_ANSI_ESC.ereg.replace(_hx_str,"")

    @staticmethod
    def removeLeading(searchIn,searchFor):
        if (((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))):
            return searchIn
        while hx_strings_Strings.startsWith(searchIn,searchFor):
            searchIn = HxString.substring(searchIn,len(searchFor),len(searchIn))
        return searchIn

    @staticmethod
    def removeTags(xml):
        if ((xml is None) or ((len(xml) == 0))):
            return xml
        return hx_strings_Strings.REGEX_REMOVE_XML_TAGS.ereg.replace(xml,"")

    @staticmethod
    def removeTrailing(searchIn,searchFor):
        if (((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))):
            return searchIn
        while hx_strings_Strings.endsWith(searchIn,searchFor):
            searchIn = HxString.substring(searchIn,0,(len(searchIn) - len(searchFor)))
        return searchIn

    @staticmethod
    def repeat(_hx_str,count,separator = None):
        if (separator is None):
            separator = ""
        if (_hx_str is None):
            return None
        if (count < 1):
            return ""
        if (count == 1):
            return _hx_str
        _g = []
        _g1 = 0
        _g2 = count
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(_hx_str)
        return separator.join([python_Boot.toString1(x1,'') for x1 in _g])

    @staticmethod
    def replaceAll(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        return StringTools.replace(searchIn,searchFor,replaceWith)

    @staticmethod
    def replaceFirst(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        foundAt = None
        if (len(searchFor) == 0):
            if (((0 if ((searchIn is None)) else len(searchIn))) > 1):
                foundAt = 1
            else:
                return searchIn
        else:
            foundAt = hx_strings_Strings.indexOf8(searchIn,searchFor)
        return ((HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,0,foundAt)) + ("null" if replaceWith is None else replaceWith)) + HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,(foundAt + ((0 if ((searchFor is None)) else len(searchFor)))))))

    @staticmethod
    def replaceFirstIgnoreCase(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        searchFor = searchFor.lower()
        foundAt = None
        if (len(searchFor) == 0):
            if (((0 if ((searchIn is None)) else len(searchIn))) > 1):
                foundAt = 1
            else:
                return searchIn
        else:
            foundAt = hx_strings_Strings.indexOf8(searchIn.lower(),searchFor)
        return ((HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,0,foundAt)) + ("null" if replaceWith is None else replaceWith)) + HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,(foundAt + ((0 if ((searchFor is None)) else len(searchFor)))))))

    @staticmethod
    def reverse(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        chars = hx_strings_Strings.split8(_hx_str,[""])
        chars.reverse()
        return "".join([python_Boot.toString1(x1,'') for x1 in chars])

    @staticmethod
    def right(_hx_str,_hx_len):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return hx_strings_Strings.substring8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - _hx_len))

    @staticmethod
    def rpad(_hx_str,targetLength,padStr = None,canOverflow = None):
        if (padStr is None):
            padStr = " "
        if (canOverflow is None):
            canOverflow = True
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((_hx_str is None) or ((strLen > targetLength))):
            return _hx_str
        if ((padStr is None) or ((len(padStr) == 0))):
            padStr = " "
        padLen = (0 if ((padStr is None)) else len(padStr))
        sb = hx_strings_StringBuilder(_hx_str)
        while (strLen < targetLength):
            sb.add(padStr)
            strLen = (strLen + padLen)
        if canOverflow:
            return sb.toString()
        _hx_str = sb.toString()
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= targetLength):
            return _hx_str
        else:
            return hx_strings_Strings.substring8(_hx_str,0,targetLength)

    @staticmethod
    def split8(_hx_str,separator,maxParts = None):
        if (maxParts is None):
            maxParts = 0
        if ((_hx_str is None) or ((separator is None))):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return []
        def _hx_local_0(s):
            return (s is not None)
        separators = list(filter(_hx_local_0,separator))
        if (len(separators) == 0):
            return None
        if ((maxParts <= 0) and ((len(separators) == 1))):
            delimiter = (separators[0] if 0 < len(separators) else None)
            if (delimiter == ""):
                return list(_hx_str)
            else:
                return _hx_str.split(delimiter)
        if (python_internal_ArrayImpl.indexOf(separators,"",None) > -1):
            if (maxParts <= 0):
                _g = []
                _g1 = 0
                _g2 = strLen
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = HxString.substr(_hx_str,i,1)
                    _g.append(x)
                return _g
            if (maxParts > strLen):
                maxParts = strLen
            maxParts = (maxParts - 1)
            _g = []
            _g1 = 0
            _g2 = maxParts
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = HxString.substr(_hx_str,i,1)
                _g.append(x)
            result = _g
            x = HxString.substr(_hx_str,maxParts,(strLen - maxParts))
            result.append(x)
            return result
        _g = []
        _g1 = 0
        while (_g1 < len(separators)):
            sep = (separators[_g1] if _g1 >= 0 and _g1 < len(separators) else None)
            _g1 = (_g1 + 1)
            x = (0 if ((sep is None)) else len(sep))
            _g.append(x)
        separatorsLengths = _g
        lastFoundAt = 0
        result = []
        resultCount = 0
        while True:
            separatorLen = 0
            foundAt = -1
            _g = 0
            _g1 = len(separators)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                sepFoundAt = hx_strings_Strings.indexOf8(_hx_str,(separators[i] if i >= 0 and i < len(separators) else None),lastFoundAt)
                if (sepFoundAt != -1):
                    if ((foundAt == -1) or ((sepFoundAt < foundAt))):
                        foundAt = sepFoundAt
                        separatorLen = (separatorsLengths[i] if i >= 0 and i < len(separatorsLengths) else None)
            resultCount = (resultCount + 1)
            if ((foundAt == -1) or ((resultCount == maxParts))):
                x = HxString.substr(_hx_str,lastFoundAt,(strLen - lastFoundAt))
                result.append(x)
                break
            x1 = HxString.substr(_hx_str,lastFoundAt,(foundAt - lastFoundAt))
            result.append(x1)
            lastFoundAt = (foundAt + separatorLen)
        return result

    @staticmethod
    def splitAt(_hx_str,splitPos):
        if (_hx_str is None):
            return None
        if ((splitPos is None) or ((len(splitPos) == 0))):
            return [_hx_str]
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return [_hx_str]
        pos = list()
        _g = 0
        _g1 = splitPos
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p < 0):
                p = (strLen + p)
            if ((p < 0) or ((p >= strLen))):
                continue
            if (python_internal_ArrayImpl.indexOf(pos,p,None) > -1):
                continue
            pos.append(p)
        def _hx_local_1(a,b):
            if (a < b):
                return -1
            elif (a > b):
                return 1
            else:
                return 0
        pos.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        result = list()
        lastPos = 0
        _g = 0
        while (_g < len(pos)):
            p = (pos[_g] if _g >= 0 and _g < len(pos) else None)
            _g = (_g + 1)
            chunk = hx_strings_Strings.substring8(_hx_str,lastPos,p)
            if ((chunk is not None) and ((len(chunk) > 0))):
                result.append(chunk)
            lastPos = p
        chunk = hx_strings_Strings.substring8(_hx_str,lastPos)
        if ((chunk is not None) and ((len(chunk) > 0))):
            result.append(chunk)
        return result

    @staticmethod
    def splitEvery(_hx_str,count):
        if (_hx_str is None):
            return None
        if (count < 1):
            raise haxe_Exception.thrown("[count] must be greater than 0")
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((strLen == 0) or ((count >= strLen))):
            return [_hx_str]
        result = list()
        pos = 0
        while True:
            chunk = hx_strings_Strings.substr8(_hx_str,pos,count)
            pos = (pos + count)
            if ((chunk is None) or ((len(chunk) == 0))):
                break
            result.append(chunk)
        return result

    @staticmethod
    def splitLines(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return []
        else:
            return hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)

    @staticmethod
    def startsWith(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if (((searchFor is None) or ((len(searchFor) == 0))) or ((searchIn == searchFor))):
            return True
        return searchIn.startswith(searchFor)

    @staticmethod
    def startsWithAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.startsWith(searchIn,candidate)):
                return True
        return False

    @staticmethod
    def startsWithAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = hx_strings_Strings.toLowerCase8(searchIn)
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.startsWith(searchIn,hx_strings_Strings.toLowerCase8(candidate))):
                return True
        return False

    @staticmethod
    def startsWithIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if ((searchFor is None) or ((len(searchFor) == 0))):
            return True
        return hx_strings_Strings.startsWith(searchIn.lower(),searchFor.lower())

    @staticmethod
    def substr8(_hx_str,startAt,_hx_len = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (_hx_len is None):
            _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        if (_hx_len <= 0):
            return ""
        if (startAt < 0):
            startAt = (startAt + (0 if ((_hx_str is None)) else len(_hx_str)))
            if (startAt < 0):
                startAt = 0
        return HxString.substr(_hx_str,startAt,_hx_len)

    @staticmethod
    def substring8(_hx_str,startAt,endAt = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (endAt is None):
            endAt = (0 if ((_hx_str is None)) else len(_hx_str))
        return HxString.substring(_hx_str,startAt,endAt)

    @staticmethod
    def substringAfter(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = None
        foundAt = (_hx_str.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,searchFor,startIndex))
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringAfterIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = (_this.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_this,searchFor,startIndex))
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringBetween(_hx_str,after,before = None,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (before is None):
            before = after
        if (((_hx_str == "") or (((after is None) or ((len(after) == 0))))) or (((before is None) or ((len(before) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = None
        foundAfterAt = (_hx_str.find(after) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,after,startIndex))
        if (foundAfterAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = (foundAfterAt + len(after))
        foundBeforeAt = (_hx_str.find(before) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,before,startIndex))
        if (foundBeforeAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAfterAt + len(after)),foundBeforeAt)

    @staticmethod
    def substringBetweenIgnoreCase(_hx_str,after,before = None,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (before is None):
            before = after
        if (((_hx_str == "") or (((after is None) or ((len(after) == 0))))) or (((before is None) or ((len(before) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        strLower = hx_strings_Strings.toLowerCase8(_hx_str)
        after = hx_strings_Strings.toLowerCase8(after)
        before = hx_strings_Strings.toLowerCase8(before)
        startIndex = None
        foundAfterAt = (strLower.find(after) if ((startIndex is None)) else HxString.indexOfImpl(strLower,after,startIndex))
        if (foundAfterAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = (foundAfterAt + len(after))
        foundBeforeAt = (strLower.find(before) if ((startIndex is None)) else HxString.indexOfImpl(strLower,before,startIndex))
        if (foundBeforeAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAfterAt + len(after)),foundBeforeAt)

    @staticmethod
    def substringAfterLast(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _hx_str.rfind(searchFor, 0, len(_hx_str))
        elif (searchFor == ""):
            length = len(_hx_str)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _hx_str.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _hx_str.find(searchFor, startLeft, len(_hx_str))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringAfterLastIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _this.rfind(searchFor, 0, len(_this))
        elif (searchFor == ""):
            length = len(_this)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _this.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _this.find(searchFor, startLeft, len(_this))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringBefore(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = None
        foundAt = (_hx_str.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,searchFor,startIndex))
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = (_this.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_this,searchFor,startIndex))
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeLast(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _hx_str.rfind(searchFor, 0, len(_hx_str))
        elif (searchFor == ""):
            length = len(_hx_str)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _hx_str.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _hx_str.find(searchFor, startLeft, len(_hx_str))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeLastIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _this.rfind(searchFor, 0, len(_this))
        elif (searchFor == ""):
            length = len(_this)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _this.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _this.find(searchFor, startLeft, len(_this))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def toBool(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        _g = _hx_str.lower()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 1):
            if (_g == "0"):
                return False
            else:
                return True
        elif (_hx_local_0 == 5):
            if (_g == "false"):
                return False
            else:
                return True
        elif (_hx_local_0 == 2):
            if (_g == "no"):
                return False
            else:
                return True
        else:
            return True

    @staticmethod
    def toBytes(_hx_str):
        if (_hx_str is None):
            return None
        return haxe_io_Bytes.ofString(_hx_str)

    @staticmethod
    def toChar(charCode):
        return charCode

    @staticmethod
    def toCharIterator(_hx_str):
        if (_hx_str is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        else:
            return hx_strings__CharIterator_StringCharIterator(_hx_str,0)

    @staticmethod
    def toChars(_hx_str):
        if (_hx_str is None):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return []
        _g = []
        _g1 = 0
        _g2 = strLen
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = HxString.charCodeAt(_hx_str,i)
            _g.append(x)
        return _g

    @staticmethod
    def toPattern(_hx_str,options = None):
        if (_hx_str is None):
            return None
        return hx_strings_Pattern.compile(_hx_str,options)

    @staticmethod
    def toEReg(_hx_str,opt = None):
        if (opt is None):
            opt = ""
        if (_hx_str is None):
            return None
        return EReg(_hx_str,opt)

    @staticmethod
    def toFloat(_hx_str,ifUnparseable = None):
        result = Std.parseFloat(_hx_str)
        if python_lib_Math.isnan(result):
            return ifUnparseable
        return result

    @staticmethod
    def toHex(num,minDigits = None,upperCase = None):
        if (minDigits is None):
            minDigits = 0
        if (upperCase is None):
            upperCase = True
        hexed = StringTools.hex(num,0)
        if (not upperCase):
            return hexed.lower()
        if (len(hexed) >= minDigits):
            return hexed
        return hx_strings_Strings.lpad(hexed,minDigits,"0")

    @staticmethod
    def toInt(_hx_str,ifUnparseable = None):
        result = Std.parseInt(_hx_str)
        if (result is None):
            return ifUnparseable
        return result

    @staticmethod
    def toLowerCase8(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return _hx_str.lower()

    @staticmethod
    def toLowerCaseFirstChar(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        this1 = HxString.charCodeAt(_hx_str,0)
        lowerChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h.get(this1,None)
        firstChar = (this1 if ((lowerChar is None)) else lowerChar)
        if (len(_hx_str) == 1):
            return "".join(map(chr,[firstChar]))
        other = hx_strings_Strings.substr8(_hx_str,1)
        return (HxOverrides.stringOrNull("".join(map(chr,[firstChar]))) + ("null" if other is None else other))

    @staticmethod
    def toLowerCamel(_hx_str,keepUppercasedWords = None):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        if keepUppercasedWords:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(word))
        else:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(word)))
        return hx_strings_Strings.toLowerCaseFirstChar(sb.toString())

    @staticmethod
    def toLowerHyphen(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toLowerCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "-".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toLowerUnderscore(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toLowerCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "_".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toTitle(_hx_str,keepUppercasedWords = None):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if keepUppercasedWords:
            def _hx_local_0(s):
                if (hx_strings_Strings.toUpperCase8(s) == s):
                    return s
                else:
                    return hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s))
            _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
            return " ".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_1(s):
            return hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s))
        _this = list(map(_hx_local_1,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toUpperCamel(_hx_str,keepUppercasedWords = None):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        if keepUppercasedWords:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(word))
        else:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(word)))
        return sb.toString()

    @staticmethod
    def toUpperUnderscore(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toUpperCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "_".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toString(_hx_str):
        if (_hx_str is None):
            return "null"
        else:
            return _hx_str

    @staticmethod
    def toUpperCase8(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return _hx_str.upper()

    @staticmethod
    def toUpperCaseFirstChar(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        this1 = HxString.charCodeAt(_hx_str,0)
        upperChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h.get(this1,None)
        firstChar = (this1 if ((upperChar is None)) else upperChar)
        if (len(_hx_str) == 1):
            return "".join(map(chr,[firstChar]))
        other = hx_strings_Strings.substr8(_hx_str,1)
        return (HxOverrides.stringOrNull("".join(map(chr,[firstChar]))) + ("null" if other is None else other))

    @staticmethod
    def trim(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.trim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        this1 = hx_strings_internal__Either2__Either2.b(removableChars)
        this2 = hx_strings_internal__Either2__Either2.b(removableChars)
        return hx_strings_Strings.trimLeft(hx_strings_Strings.trimRight(_hx_str,this1),this2)

    @staticmethod
    def trimRight(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.rtrim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        if (len(removableChars) == 0):
            return _hx_str
        _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        i = (_hx_len - 1)
        while True:
            tmp = None
            if (i > -1):
                str1 = hx_strings_Strings.charAt8(_hx_str,i)
                strLen = (0 if ((str1 is None)) else len(str1))
                tmp = (python_internal_ArrayImpl.indexOf(removableChars,(-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt(str1,0)),None) > -1)
            else:
                tmp = False
            if (not tmp):
                break
            i = (i - 1)
        if (i < ((_hx_len - 1))):
            return hx_strings_Strings.substring8(_hx_str,0,(i + 1))
        return _hx_str

    @staticmethod
    def trimLeft(_hx_str,charsToRemove = None):
        if (_hx_str is None):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.ltrim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        if (len(removableChars) == 0):
            return _hx_str
        _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        i = 0
        while True:
            tmp = None
            if (i < _hx_len):
                str1 = hx_strings_Strings.charAt8(_hx_str,i)
                strLen = (0 if ((str1 is None)) else len(str1))
                tmp = (python_internal_ArrayImpl.indexOf(removableChars,(-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt(str1,0)),None) > -1)
            else:
                tmp = False
            if (not tmp):
                break
            i = (i + 1)
        if (i > 0):
            return hx_strings_Strings.substring8(_hx_str,i,_hx_len)
        return _hx_str

    @staticmethod
    def trimLines(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(line):
            return hx_strings_Strings.trim(line,charsToRemove)
        _this = list(map(_hx_local_0,hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)))
        return "\n".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def trimToNull(_hx_str):
        if (_hx_str is None):
            return None
        trimmed = hx_strings_Strings.trim(_hx_str)
        if ((trimmed is None) or ((len(trimmed) == 0))):
            return None
        return trimmed

    @staticmethod
    def trimToEmpty(_hx_str):
        trimmed = hx_strings_Strings.trim(_hx_str)
        if ((trimmed is None) or ((len(trimmed) == 0))):
            return ""
        return trimmed

    @staticmethod
    def truncate(_hx_str,maxLength):
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        else:
            return hx_strings_Strings.substring8(_hx_str,0,maxLength)

    @staticmethod
    def urlDecode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return python_lib_urllib_Parse.unquote(_hx_str)

    @staticmethod
    def urlEncode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return python_lib_urllib_Parse.quote(_hx_str,"")

    @staticmethod
    def wrap(_hx_str,maxLineLength,splitLongWords = None,newLineSeparator = None):
        if (splitLongWords is None):
            splitLongWords = True
        if (newLineSeparator is None):
            newLineSeparator = "\n"
        if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLineLength) or ((maxLineLength < 1))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        wordChars = []
        currLineLength = 0
        _g = 0
        _g1 = hx_strings_Strings.toChars(_hx_str)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((ch > 8) and ((ch < 14))) or ((ch == 32))):
                if (len(wordChars) > 0):
                    _g2 = 0
                    while (_g2 < len(wordChars)):
                        wordCh = (wordChars[_g2] if _g2 >= 0 and _g2 < len(wordChars) else None)
                        _g2 = (_g2 + 1)
                        if ((currLineLength == maxLineLength) and splitLongWords):
                            sb.add(newLineSeparator)
                            currLineLength = 0
                        currLineLength = (currLineLength + 1)
                        sb.addChar(wordCh)
                    wordChars = []
                if (currLineLength >= maxLineLength):
                    sb.add(newLineSeparator)
                    currLineLength = 0
                sb.addChar(ch)
                currLineLength = (currLineLength + 1)
            else:
                wordChars.append(ch)
        if (len(wordChars) > 0):
            _g = 0
            while (_g < len(wordChars)):
                wordCh = (wordChars[_g] if _g >= 0 and _g < len(wordChars) else None)
                _g = (_g + 1)
                if ((currLineLength == maxLineLength) and splitLongWords):
                    sb.add(newLineSeparator)
                    currLineLength = 0
                currLineLength = (currLineLength + 1)
                sb.addChar(wordCh)
        return sb.toString()
hx_strings_Strings._hx_class = hx_strings_Strings


class hx_strings_StringDiff:
    _hx_class_name = "hx.strings.StringDiff"
    __slots__ = ("at", "left", "right")
    _hx_fields = ["at", "left", "right"]
    _hx_methods = ["toString"]

    def __init__(self):
        self.right = None
        self.left = None
        self.at = None

    def toString(self):
        return (((((("StringDiff[at=" + Std.string(self.at)) + ", left=") + HxOverrides.stringOrNull(self.left)) + ", right=") + HxOverrides.stringOrNull(self.right)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.at = None
        _hx_o.left = None
        _hx_o.right = None
hx_strings_StringDiff._hx_class = hx_strings_StringDiff

class hx_strings_HashCodeAlgorithm(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.HashCodeAlgorithm"
    _hx_constructs = ["PLATFORM_SPECIFIC", "ADLER32", "CRC32B", "DJB2A", "JAVA", "SDBM"]
hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC = hx_strings_HashCodeAlgorithm("PLATFORM_SPECIFIC", 0, ())
hx_strings_HashCodeAlgorithm.ADLER32 = hx_strings_HashCodeAlgorithm("ADLER32", 1, ())
hx_strings_HashCodeAlgorithm.CRC32B = hx_strings_HashCodeAlgorithm("CRC32B", 2, ())
hx_strings_HashCodeAlgorithm.DJB2A = hx_strings_HashCodeAlgorithm("DJB2A", 3, ())
hx_strings_HashCodeAlgorithm.JAVA = hx_strings_HashCodeAlgorithm("JAVA", 4, ())
hx_strings_HashCodeAlgorithm.SDBM = hx_strings_HashCodeAlgorithm("SDBM", 5, ())
hx_strings_HashCodeAlgorithm._hx_class = hx_strings_HashCodeAlgorithm

class hx_strings_AnsiToHtmlRenderMethod(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.AnsiToHtmlRenderMethod"
    _hx_constructs = ["StyleAttributes", "CssClasses", "CssClassesCallback"]

    @staticmethod
    def CssClassesCallback(func):
        return hx_strings_AnsiToHtmlRenderMethod("CssClassesCallback", 2, (func,))
hx_strings_AnsiToHtmlRenderMethod.StyleAttributes = hx_strings_AnsiToHtmlRenderMethod("StyleAttributes", 0, ())
hx_strings_AnsiToHtmlRenderMethod.CssClasses = hx_strings_AnsiToHtmlRenderMethod("CssClasses", 1, ())
hx_strings_AnsiToHtmlRenderMethod._hx_class = hx_strings_AnsiToHtmlRenderMethod


class hx_strings_AnsiState:
    _hx_class_name = "hx.strings.AnsiState"
    __slots__ = ("bgcolor", "blink", "bold", "fgcolor", "underline")
    _hx_fields = ["bgcolor", "blink", "bold", "fgcolor", "underline"]
    _hx_methods = ["isActive", "reset", "copyFrom", "setGraphicModeParameter", "toCSS"]
    _hx_statics = ["defaultCssClassesCallback"]

    def __init__(self,copyFrom = None):
        self.underline = None
        self.fgcolor = None
        self.bold = None
        self.blink = None
        self.bgcolor = None
        if (copyFrom is None):
            self.reset()
        else:
            self.copyFrom(copyFrom)

    def isActive(self):
        if (not (((((self.fgcolor is not None) or ((self.bgcolor is not None))) or self.bold) or self.underline))):
            return self.blink
        else:
            return True

    def reset(self):
        self.fgcolor = None
        self.bgcolor = None
        self.bold = False
        self.underline = False
        self.blink = False

    def copyFrom(self,other):
        self.fgcolor = other.fgcolor
        self.bgcolor = other.bgcolor
        self.bold = other.bold
        self.underline = other.underline
        self.blink = other.blink

    def setGraphicModeParameter(self,param):
        param1 = param
        if (param1 == 0):
            self.reset()
        elif (param1 == 1):
            self.bold = True
        elif (param1 == 4):
            self.underline = True
        elif (param1 == 5):
            self.blink = True
        elif (param1 == 30):
            self.fgcolor = "black"
        elif (param1 == 31):
            self.fgcolor = "red"
        elif (param1 == 32):
            self.fgcolor = "green"
        elif (param1 == 33):
            self.fgcolor = "yellow"
        elif (param1 == 34):
            self.fgcolor = "blue"
        elif (param1 == 35):
            self.fgcolor = "magenta"
        elif (param1 == 36):
            self.fgcolor = "cyan"
        elif (param1 == 37):
            self.fgcolor = "white"
        elif (param1 == 40):
            self.bgcolor = "black"
        elif (param1 == 41):
            self.bgcolor = "red"
        elif (param1 == 42):
            self.bgcolor = "green"
        elif (param1 == 43):
            self.bgcolor = "yellow"
        elif (param1 == 44):
            self.bgcolor = "blue"
        elif (param1 == 45):
            self.bgcolor = "magenta"
        elif (param1 == 46):
            self.bgcolor = "cyan"
        elif (param1 == 47):
            self.bgcolor = "white"
        else:
            pass

    def toCSS(self,renderMethod):
        if (((((self.fgcolor is not None) or ((self.bgcolor is not None))) or self.bold) or self.underline) or self.blink):
            sb = hx_strings_StringBuilder()
            if (renderMethod is None):
                renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes
            tmp = renderMethod.index
            if (tmp == 0):
                if (self.fgcolor is not None):
                    sb.add("color:").add(self.fgcolor).add(";")
                if (self.bgcolor is not None):
                    sb.add("background-color:").add(self.bgcolor).add(";")
                if self.bold:
                    sb.add("font-weight:bold;")
                if self.underline:
                    sb.add("text-decoration:underline;")
                if self.blink:
                    sb.add("text-decoration:blink;")
            elif (tmp == 1):
                sb.add(hx_strings_AnsiState.defaultCssClassesCallback(self))
            elif (tmp == 2):
                func = renderMethod.params[0]
                sb.add(func(self))
            else:
                pass
            return sb.toString()
        return ""

    @staticmethod
    def defaultCssClassesCallback(state):
        classes = []
        if (state.fgcolor is not None):
            x = ("ansi_fg_" + HxOverrides.stringOrNull(state.fgcolor))
            classes.append(x)
        if (state.bgcolor is not None):
            x = ("ansi_bg_" + HxOverrides.stringOrNull(state.bgcolor))
            classes.append(x)
        if state.bold:
            classes.append("ansi_bold")
        if state.underline:
            classes.append("ansi_underline")
        if state.blink:
            classes.append("ansi_blink")
        return " ".join([python_Boot.toString1(x1,'') for x1 in classes])

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bgcolor = None
        _hx_o.blink = None
        _hx_o.bold = None
        _hx_o.fgcolor = None
        _hx_o.underline = None
hx_strings_AnsiState._hx_class = hx_strings_AnsiState


class hx_strings_internal_Bits:
    _hx_class_name = "hx.strings.internal.Bits"
    __slots__ = ()
    _hx_statics = ["clearBit", "setBit", "toggleBit", "getBit"]

    @staticmethod
    def clearBit(num,bitPos):
        return (num & ~((1 << ((bitPos - 1)))))

    @staticmethod
    def setBit(num,bitPos):
        return (num | ((1 << ((bitPos - 1)))))

    @staticmethod
    def toggleBit(num,bitPos):
        return (num ^ ((1 << ((bitPos - 1)))))

    @staticmethod
    def getBit(num,bitPos):
        return (1 == (((num >> ((bitPos - 1))) & 1)))
hx_strings_internal_Bits._hx_class = hx_strings_internal_Bits


class hx_strings_internal__Either2_Either2_Impl_:
    _hx_class_name = "hx.strings.internal._Either2.Either2_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "fromA", "fromB"]
    value = None

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def get_value(this1):
        return this1

    @staticmethod
    def fromA(value):
        this1 = hx_strings_internal__Either2__Either2.a(value)
        return this1

    @staticmethod
    def fromB(value):
        this1 = hx_strings_internal__Either2__Either2.b(value)
        return this1
hx_strings_internal__Either2_Either2_Impl_._hx_class = hx_strings_internal__Either2_Either2_Impl_

class hx_strings_internal__Either2__Either2(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.internal._Either2._Either2"
    _hx_constructs = ["a", "b"]

    @staticmethod
    def a(v):
        return hx_strings_internal__Either2__Either2("a", 0, (v,))

    @staticmethod
    def b(v):
        return hx_strings_internal__Either2__Either2("b", 1, (v,))
hx_strings_internal__Either2__Either2._hx_class = hx_strings_internal__Either2__Either2


class hx_strings_internal__Either3_Either3_Impl_:
    _hx_class_name = "hx.strings.internal._Either3.Either3_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "fromA", "fromB", "fromC"]
    value = None

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def get_value(this1):
        return this1

    @staticmethod
    def fromA(value):
        this1 = hx_strings_internal__Either3__Either3.a(value)
        return this1

    @staticmethod
    def fromB(value):
        this1 = hx_strings_internal__Either3__Either3.b(value)
        return this1

    @staticmethod
    def fromC(value):
        this1 = hx_strings_internal__Either3__Either3.c(value)
        return this1
hx_strings_internal__Either3_Either3_Impl_._hx_class = hx_strings_internal__Either3_Either3_Impl_


class hx_strings_internal__OneOrMany_OneOrMany_Impl_:
    _hx_class_name = "hx.strings.internal._OneOrMany.OneOrMany_Impl_"
    __slots__ = ()
    _hx_statics = ["fromSingle"]

    @staticmethod
    def fromSingle(value):
        return [value]
hx_strings_internal__OneOrMany_OneOrMany_Impl_._hx_class = hx_strings_internal__OneOrMany_OneOrMany_Impl_


class hx_strings_internal__RingBuffer_RingBuffer_Impl_:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBuffer_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get"]

    @staticmethod
    def _new(size):
        this1 = hx_strings_internal__RingBuffer_RingBufferImpl(size)
        return this1

    @staticmethod
    def get(this1,index):
        return this1.get(index)
hx_strings_internal__RingBuffer_RingBuffer_Impl_._hx_class = hx_strings_internal__RingBuffer_RingBuffer_Impl_


class hx_strings_internal__RingBuffer_RingBufferIterator:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBufferIterator"
    __slots__ = ("buff", "idx")
    _hx_fields = ["buff", "idx"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,buff):
        self.idx = -1
        self.buff = buff

    def hasNext(self):
        return ((self.idx + 1) < self.buff.length)

    def next(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.idx
        _hx_local_0.idx = (_hx_local_1 + 1)
        _hx_local_1
        return self.buff.get(self.idx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buff = None
        _hx_o.idx = None
hx_strings_internal__RingBuffer_RingBufferIterator._hx_class = hx_strings_internal__RingBuffer_RingBufferIterator


class ihx_ConsoleReader:
    _hx_class_name = "ihx.ConsoleReader"
    __slots__ = ("cmd", "code", "history", "codeSet")
    _hx_fields = ["cmd", "code", "history", "codeSet"]
    _hx_methods = ["saveHistory", "readLine"]
    _hx_statics = ["main"]

    def __init__(self,maxHistory = None,historyFile = None):
        if (maxHistory is None):
            maxHistory = -1
        if (historyFile is None):
            historyFile = ""
        self.codeSet = None
        self.code = 0
        self.cmd = ihx_PartialCommand()
        self.history = ihx_History(maxHistory,historyFile)
        if (Sys.systemName() == "Windows"):
            self.codeSet = _hx_AnonObject({'arrow': 224, 'up': 72, 'down': 80, 'right': 77, 'left': 75, 'home': 71, 'end': 79, 'backspace': 8, 'ctrlc': 3, 'enter': 13, 'ctrla': 1, 'ctrle': 5, 'ctrlb': 2, 'ctrlf': 6, 'ctrld': 4, 'ctrlp': -1, 'ctrln': -1, 'ctrlk': -1, 'ctrlu': -1, 'ctrly': -1})
        else:
            self.codeSet = _hx_AnonObject({'arrow': 27, 'up': 65, 'down': 66, 'right': 67, 'left': 68, 'home': 72, 'end': 70, 'backspace': 127, 'ctrlc': 3, 'enter': 13, 'ctrla': 1, 'ctrle': 5, 'ctrlb': 2, 'ctrlf': 6, 'ctrld': 4, 'ctrlp': 16, 'ctrln': 14, 'ctrlk': 11, 'ctrlu': 21, 'ctrly': 25})

    def saveHistory(self):
        self.history.save()

    def readLine(self):
        self.cmd.set("")
        while True:
            clearPrevCommand = self.cmd.clearString()
            self.code = Sys.getChar(False)
            if (self.code == self.codeSet.arrow):
                if (Sys.systemName() != "Windows"):
                    Sys.getChar(False)
                self.code = Sys.getChar(False)
                _g = self.code
                if (self.code == self.codeSet.up):
                    self.cmd.set(self.history.prev())
                elif (self.code == self.codeSet.down):
                    self.cmd.set(self.history.next())
                elif (self.code == self.codeSet.right):
                    self.cmd.cursorForward()
                elif (self.code == self.codeSet.left):
                    self.cmd.cursorBack()
                elif (self.code == self.codeSet.home):
                    self.cmd.home()
                elif (self.code == self.codeSet.end):
                    self.cmd.end()
                elif ((self.code == self.codeSet.ctrld) and ((Sys.systemName() == "Windows"))):
                    self.cmd._hx_del()
            else:
                _g1 = self.code
                if (self.code == self.codeSet.ctrlc):
                    if (len(self.cmd.toString()) > 0):
                        self.cmd.set("")
                    else:
                        _hx_str = ""
                        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                        self.history.save()
                        Sys.exit(1)
                elif (self.code == self.codeSet.enter):
                    str1 = ""
                    python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                    self.history.add(self.cmd.toString())
                    return self.cmd.toString()
                elif (self.code == self.codeSet.ctrld):
                    if (len(self.cmd.toString()) > 0):
                        self.cmd._hx_del()
                    else:
                        str2 = ""
                        python_Lib.printString((("" + ("null" if str2 is None else str2)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                        self.history.save()
                        Sys.exit(1)
                elif (self.code == self.codeSet.ctrlp):
                    self.cmd.set(self.history.prev())
                elif (self.code == self.codeSet.ctrln):
                    self.cmd.set(self.history.next())
                elif (self.code == self.codeSet.ctrlk):
                    self.cmd.killRight()
                elif (self.code == self.codeSet.ctrlu):
                    self.cmd.killLeft()
                elif (self.code == self.codeSet.ctrly):
                    self.cmd.yank()
                elif (self.code == self.codeSet.ctrla):
                    self.cmd.home()
                elif (self.code == self.codeSet.ctrle):
                    self.cmd.end()
                elif (self.code == self.codeSet.ctrlf):
                    self.cmd.cursorForward()
                elif (self.code == self.codeSet.ctrlb):
                    self.cmd.cursorBack()
                elif (self.code == self.codeSet.backspace):
                    self.cmd.backspace()
                elif ((self.code >= 32) and ((self.code <= 126))):
                    code = self.code
                    self.cmd.addChar("".join(map(chr,[code])))
            python_Lib.printString(Std.string(clearPrevCommand))
            python_Lib.printString(Std.string(self.cmd.toConsole()))

    @staticmethod
    def main():
        cr = ihx_ConsoleReader()
        cmdStr = cr.readLine()
        _hx_str = Std.string(("\n" + ("null" if cmdStr is None else cmdStr)))
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cmd = None
        _hx_o.code = None
        _hx_o.history = None
        _hx_o.codeSet = None
ihx_ConsoleReader._hx_class = ihx_ConsoleReader


class ihx_History:
    _hx_class_name = "ihx.History"
    __slots__ = ("commands", "maxCommands", "saveFile", "pos")
    _hx_fields = ["commands", "maxCommands", "saveFile", "pos"]
    _hx_methods = ["load", "save", "isFull", "add", "next", "prev"]

    def __init__(self,maxCommands = None,saveFile = None):
        if (maxCommands is None):
            maxCommands = -1
        if (saveFile is None):
            saveFile = ""
        self.pos = None
        self.commands = None
        self.maxCommands = (maxCommands + 1)
        self.saveFile = saveFile
        if (len(saveFile) > 0):
            self.load()
        else:
            self.commands = [""]
            self.pos = 1
        self.save()
        self.pos = len(self.commands)

    def load(self):
        try:
            _this = sys_io_File.getContent(self.saveFile)
            self.commands = _this.split("\n")
            self.commands.insert(0, "")
        except BaseException as _g:
            None
            err = haxe_Exception.caught(_g).unwrap()
            _hx_str = Std.string(((("Warning! Failed to read history from " + HxOverrides.stringOrNull(self.saveFile)) + ": ") + Std.string(err)))
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
            self.commands = [""]
        if self.isFull():
            _this = self.commands
            _hx_len = (len(self.commands) - self.maxCommands)
            pos = 0
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]
            self.commands = res

    def save(self):
        if (len(self.saveFile) > 0):
            try:
                tmp = self.saveFile
                _this = self.commands[1:None]
                sys_io_File.saveContent(tmp,"\n".join([python_Boot.toString1(x1,'') for x1 in _this]))
            except BaseException as _g:
                None
                err = haxe_Exception.caught(_g).unwrap()
                _hx_str = Std.string(((("Warning! Failed to write history to " + HxOverrides.stringOrNull(self.saveFile)) + ": ") + Std.string(err)))
                python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                self.saveFile = ""

    def isFull(self):
        if (self.maxCommands > 0):
            return (len(self.commands) > self.maxCommands)
        else:
            return False

    def add(self,cmd):
        _this = self.commands
        _this.append(cmd)
        if self.isFull():
            _this = self.commands
            if (len(_this) != 0):
                _this.pop(0)
        self.pos = len(self.commands)

    def next(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_0.pos
        return python_internal_ArrayImpl._get(self.commands, HxOverrides.mod(self.pos, len(self.commands)))

    def prev(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 1)
        _hx_local_0.pos
        if (self.pos < 0):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + len(self.commands))
            _hx_local_2.pos
        return python_internal_ArrayImpl._get(self.commands, HxOverrides.mod(self.pos, len(self.commands)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.commands = None
        _hx_o.maxCommands = None
        _hx_o.saveFile = None
        _hx_o.pos = None
ihx_History._hx_class = ihx_History


class ihx_PartialCommand:
    _hx_class_name = "ihx.PartialCommand"
    __slots__ = ("str", "pos", "killedText", "prompt")
    _hx_fields = ["str", "pos", "killedText", "prompt"]
    _hx_methods = ["addChar", "backspace", "del", "cursorForward", "cursorBack", "home", "end", "set", "toString", "toConsole", "clearString", "killLeft", "killRight", "killText", "yank"]

    def __init__(self,initialCommand = None):
        if (initialCommand is None):
            initialCommand = ""
        self.prompt = None
        self.killedText = None
        self.pos = None
        self.str = None
        self.set(initialCommand)
        self.prompt = ""
        self.killedText = ""

    def addChar(self,ch):
        if (self.pos == len(self.str)):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.str
            _hx_local_0.str = (("null" if _hx_local_1 is None else _hx_local_1) + ("null" if ch is None else ch))
            _hx_local_0.str
        else:
            self.str = ((HxOverrides.stringOrNull(HxString.substr(self.str,0,self.pos)) + ("null" if ch is None else ch)) + HxOverrides.stringOrNull(HxString.substr(self.str,self.pos,None)))
        self.cursorForward()

    def backspace(self):
        if (self.pos == 0):
            return
        self.str = (HxOverrides.stringOrNull(HxString.substr(self.str,0,(self.pos - 1))) + HxOverrides.stringOrNull(HxString.substr(self.str,self.pos,None)))
        self.cursorBack()

    def _hx_del(self):
        if (self.pos == len(self.str)):
            return
        self.str = (HxOverrides.stringOrNull(HxString.substr(self.str,0,self.pos)) + HxOverrides.stringOrNull(HxString.substr(self.str,(self.pos + 1),None)))

    def cursorForward(self):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            return _hx_local_0.pos
        a = _hx_local_2()
        b = len(self.str)
        x = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else min(a,b)))
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.pos = tmp

    def cursorBack(self):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 - 1)
            return _hx_local_0.pos
        a = _hx_local_2()
        x = (a if (python_lib_Math.isnan(a)) else (0 if (python_lib_Math.isnan(0)) else max(a,0)))
        tmp = None
        try:
            tmp = int(x)
        except BaseException as _g:
            None
            tmp = None
        self.pos = tmp

    def home(self):
        self.pos = 0

    def end(self):
        self.pos = len(self.str)

    def set(self,newStr):
        self.str = newStr
        self.pos = len(self.str)

    def toString(self):
        return self.str

    def toConsole(self):
        return (((((("\r" + HxOverrides.stringOrNull(self.prompt)) + HxOverrides.stringOrNull(self.str)) + " ") + "\r") + HxOverrides.stringOrNull(self.prompt)) + HxOverrides.stringOrNull(HxString.substr(self.str,0,self.pos)))

    def clearString(self):
        return ("\r" + HxOverrides.stringOrNull(StringTools.rpad(""," ",(len(self.str) + len(self.prompt)))))

    def killLeft(self):
        self.killText(0,self.pos)

    def killRight(self):
        self.killText(self.pos,len(self.str))

    def killText(self,startIndex,endIndex):
        if ((startIndex < self.pos) and ((self.pos <= endIndex))):
            self.pos = startIndex
        self.killedText = HxString.substring(self.str,startIndex,endIndex)
        self.str = (HxOverrides.stringOrNull(HxString.substring(self.str,0,startIndex)) + HxOverrides.stringOrNull(HxString.substr(self.str,endIndex,None)))

    def yank(self):
        self.str = ((HxOverrides.stringOrNull(HxString.substring(self.str,0,self.pos)) + HxOverrides.stringOrNull(self.killedText)) + HxOverrides.stringOrNull(HxString.substr(self.str,self.pos,None)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + len(self.killedText))
        _hx_local_0.pos

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.str = None
        _hx_o.pos = None
        _hx_o.killedText = None
        _hx_o.prompt = None
ihx_PartialCommand._hx_class = ihx_PartialCommand


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "length", "rshift", "modf", "mod", "arrayGet", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def length(x):
        if isinstance(x,str):
            return len(x)
        elif isinstance(x,list):
            return len(x)
        return x.length

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def arrayGet(a,i):
        if isinstance(a,list):
            x = a
            if ((i > -1) and ((i < len(x)))):
                return x[i]
            else:
                return None
        else:
            return a[i]

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    def readinto(self,b):
        raise haxe_Exception.thrown("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
python_io_NativeInput._hx_class = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "readAll", "readLine"]
python_io_IInput._hx_class = python_io_IInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "prepare"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def close(self):
        self.stream.close()

    def prepare(self,nbytes):
        self.stream.truncate(nbytes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
python_io_NativeOutput._hx_class = python_io_NativeOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "close", "writeFullBytes", "prepare", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]
python_io_IFileOutput._hx_class = python_io_IFileOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextInput._hx_class = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))
python_io_IoTools._hx_class = python_io_IoTools


class sys_net_Socket:
    _hx_class_name = "sys.net.Socket"
    __slots__ = ("_hx___s", "input", "output")
    _hx_fields = ["__s", "input", "output"]
    _hx_methods = ["__initSocket", "close", "connect", "shutdown", "setTimeout", "fileno"]

    def __init__(self):
        self.output = None
        self.input = None
        self._hx___s = None
        self._hx___initSocket()
        self.input = sys_net__Socket_SocketInput(self._hx___s)
        self.output = sys_net__Socket_SocketOutput(self._hx___s)

    def _hx___initSocket(self):
        self._hx___s = python_lib_socket_Socket()

    def close(self):
        self._hx___s.close()

    def connect(self,host,port):
        host_str = host.toString()
        self._hx___s.connect((host_str, port))

    def shutdown(self,read,write):
        self._hx___s.shutdown((python_lib_Socket.SHUT_RDWR if ((read and write)) else (python_lib_Socket.SHUT_RD if read else python_lib_Socket.SHUT_WR)))

    def setTimeout(self,timeout):
        self._hx___s.settimeout(timeout)

    def fileno(self):
        return self._hx___s.fileno()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___s = None
        _hx_o.input = None
        _hx_o.output = None
sys_net_Socket._hx_class = sys_net_Socket


class python_net_SslSocket(sys_net_Socket):
    _hx_class_name = "python.net.SslSocket"
    __slots__ = ("hostName",)
    _hx_fields = ["hostName"]
    _hx_methods = ["__initSocket", "connect"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = sys_net_Socket


    def __init__(self):
        self.hostName = None
        super().__init__()

    def _hx___initSocket(self):
        context = python_lib_ssl_SSLContext(python_lib_Ssl.PROTOCOL_SSLv23)
        context.verify_mode = python_lib_Ssl.CERT_REQUIRED
        context.set_default_verify_paths()
        context.options = (context.options | python_lib_Ssl.OP_NO_SSLv2)
        context.options = (context.options | python_lib_Ssl.OP_NO_SSLv3)
        context.options = (context.options | python_lib_Ssl.OP_NO_COMPRESSION)
        context.options = (context.options | python_lib_Ssl.OP_NO_TLSv1)
        self._hx___s = python_lib_socket_Socket()
        self._hx___s = context.wrap_socket(self._hx___s,False,True,True,self.hostName)

    def connect(self,host,port):
        self.hostName = host.host
        super().connect(host,port)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.hostName = None
python_net_SslSocket._hx_class = python_net_SslSocket


class sys_Http(haxe_http_HttpBase):
    _hx_class_name = "sys.Http"
    __slots__ = ("noShutdown", "cnxTimeout", "responseHeaders", "chunk_size", "chunk_buf", "file")
    _hx_fields = ["noShutdown", "cnxTimeout", "responseHeaders", "chunk_size", "chunk_buf", "file"]
    _hx_methods = ["request", "customRequest", "writeBody", "readHttpResponse", "readChunk"]
    _hx_statics = ["PROXY", "requestUrl"]
    _hx_interfaces = []
    _hx_super = haxe_http_HttpBase


    def __init__(self,url):
        self.file = None
        self.chunk_buf = None
        self.chunk_size = None
        self.responseHeaders = None
        self.noShutdown = None
        self.cnxTimeout = 10
        super().__init__(url)

    def request(self,post = None):
        _gthis = self
        output = haxe_io_BytesOutput()
        old = self.onError
        err = False
        def _hx_local_0(e):
            nonlocal err
            _gthis.responseBytes = output.getBytes()
            err = True
            _gthis.onError = old
            _gthis.onError(e)
        self.onError = _hx_local_0
        post = ((post or ((self.postBytes is not None))) or ((self.postData is not None)))
        self.customRequest(post,output)
        if (not err):
            self.success(output.getBytes())

    def customRequest(self,post,api,sock = None,method = None):
        self.responseAsString = None
        self.responseBytes = None
        url_regexp = EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)$","")
        url_regexp.matchObj = python_lib_Re.search(url_regexp.pattern,self.url)
        if (url_regexp.matchObj is None):
            self.onError("Invalid URL")
            return
        secure = (url_regexp.matchObj.group(1) == "https://")
        if (sock is None):
            if secure:
                sock = python_net_SslSocket()
            else:
                sock = sys_net_Socket()
            sock.setTimeout(self.cnxTimeout)
        host = url_regexp.matchObj.group(2)
        portString = url_regexp.matchObj.group(3)
        request = url_regexp.matchObj.group(4)
        if ((("" if ((0 >= len(request))) else request[0])) != "/"):
            request = ("/" + ("null" if request is None else request))
        port = ((443 if secure else 80) if (((portString is None) or ((portString == "")))) else Std.parseInt(HxString.substr(portString,1,(len(portString) - 1))))
        multipart = (self.file is not None)
        boundary = None
        uri = None
        if multipart:
            post = True
            boundary = (((Std.string(int((python_lib_Random.random() * 1000))) + Std.string(int((python_lib_Random.random() * 1000)))) + Std.string(int((python_lib_Random.random() * 1000)))) + Std.string(int((python_lib_Random.random() * 1000))))
            while (len(boundary) < 38):
                boundary = ("-" + ("null" if boundary is None else boundary))
            b_b = python_lib_io_StringIO()
            _g = 0
            _g1 = self.params
            while (_g < len(_g1)):
                p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                b_b.write("--")
                b_b.write(Std.string(boundary))
                b_b.write("\r\n")
                b_b.write("Content-Disposition: form-data; name=\"")
                b_b.write(Std.string(p.name))
                b_b.write("\"")
                b_b.write("\r\n")
                b_b.write("\r\n")
                b_b.write(Std.string(p.value))
                b_b.write("\r\n")
            b_b.write("--")
            b_b.write(Std.string(boundary))
            b_b.write("\r\n")
            b_b.write("Content-Disposition: form-data; name=\"")
            b_b.write(Std.string(self.file.param))
            b_b.write("\"; filename=\"")
            b_b.write(Std.string(self.file.filename))
            b_b.write("\"")
            b_b.write("\r\n")
            b_b.write(Std.string(((("Content-Type: " + HxOverrides.stringOrNull(self.file.mimeType)) + "\r\n") + "\r\n")))
            uri = b_b.getvalue()
        else:
            _g = 0
            _g1 = self.params
            while (_g < len(_g1)):
                p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (uri is None):
                    uri = ""
                else:
                    uri = (("null" if uri is None else uri) + "&")
                uri = (("null" if uri is None else uri) + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(p.name,"")) + "=") + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(("" + HxOverrides.stringOrNull(p.value)),""))))))
        b = haxe_io_BytesOutput()
        if (method is not None):
            b.writeString(method)
            b.writeString(" ")
        elif post:
            b.writeString("POST ")
        else:
            b.writeString("GET ")
        if (sys_Http.PROXY is not None):
            b.writeString("http://")
            b.writeString(host)
            if (port != 80):
                b.writeString(":")
                b.writeString(("" + Std.string(port)))
        b.writeString(request)
        if ((not post) and ((uri is not None))):
            if (HxString.indexOfImpl(request,"?",0) >= 0):
                b.writeString("&")
            else:
                b.writeString("?")
            b.writeString(uri)
        b.writeString(((" HTTP/1.1\r\nHost: " + ("null" if host is None else host)) + "\r\n"))
        if (self.postData is not None):
            self.postBytes = haxe_io_Bytes.ofString(self.postData)
            self.postData = None
        if (self.postBytes is not None):
            b.writeString((("Content-Length: " + Std.string(self.postBytes.length)) + "\r\n"))
        elif (post and ((uri is not None))):
            def _hx_local_4(h):
                return (h.name == "Content-Type")
            if (multipart or (not Lambda.exists(self.headers,_hx_local_4))):
                b.writeString("Content-Type: ")
                if multipart:
                    b.writeString("multipart/form-data")
                    b.writeString("; boundary=")
                    b.writeString(boundary)
                else:
                    b.writeString("application/x-www-form-urlencoded")
                b.writeString("\r\n")
            if multipart:
                b.writeString((("Content-Length: " + Std.string(((((len(uri) + self.file.size) + len(boundary)) + 6)))) + "\r\n"))
            else:
                b.writeString((("Content-Length: " + Std.string(len(uri))) + "\r\n"))
        b.writeString("Connection: close\r\n")
        _g = 0
        _g1 = self.headers
        while (_g < len(_g1)):
            h = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.writeString(h.name)
            b.writeString(": ")
            b.writeString(h.value)
            b.writeString("\r\n")
        b.writeString("\r\n")
        if (self.postBytes is not None):
            b.writeFullBytes(self.postBytes,0,self.postBytes.length)
        elif (post and ((uri is not None))):
            b.writeString(uri)
        try:
            if (sys_Http.PROXY is not None):
                sock.connect(sys_net_Host(sys_Http.PROXY.host),sys_Http.PROXY.port)
            else:
                sock.connect(sys_net_Host(host),port)
            if multipart:
                self.writeBody(b,self.file.io,self.file.size,boundary,sock)
            else:
                self.writeBody(b,None,0,None,sock)
            self.readHttpResponse(api,sock)
            sock.close()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            try:
                sock.close()
            except BaseException as _g:
                pass
            self.onError(Std.string(e))

    def writeBody(self,body,fileInput,fileSize,boundary,sock):
        if (body is not None):
            _hx_bytes = body.getBytes()
            sock.output.writeFullBytes(_hx_bytes,0,_hx_bytes.length)
        if (boundary is not None):
            bufsize = 4096
            buf = haxe_io_Bytes.alloc(bufsize)
            while (fileSize > 0):
                size = (bufsize if ((fileSize > bufsize)) else fileSize)
                _hx_len = 0
                try:
                    _hx_len = fileInput.readBytes(buf,0,size)
                except BaseException as _g:
                    None
                    if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                        break
                    else:
                        raise _g
                sock.output.writeFullBytes(buf,0,_hx_len)
                fileSize = (fileSize - _hx_len)
            sock.output.writeString("\r\n")
            sock.output.writeString("--")
            sock.output.writeString(boundary)
            sock.output.writeString("--")

    def readHttpResponse(self,api,sock):
        b = haxe_io_BytesBuffer()
        k = 4
        s = haxe_io_Bytes.alloc(4)
        sock.setTimeout(self.cnxTimeout)
        while True:
            p = sock.input.readBytes(s,0,k)
            while (p != k):
                p = (p + sock.input.readBytes(s,p,(k - p)))
            if ((k < 0) or ((k > s.length))):
                raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
            b.b.extend(s.b[0:k])
            k1 = k
            if (k1 == 1):
                c = s.b[0]
                if (c == 10):
                    break
                if (c == 13):
                    k = 3
                else:
                    k = 4
            elif (k1 == 2):
                c1 = s.b[1]
                if (c1 == 10):
                    if (s.b[0] == 13):
                        break
                    k = 4
                elif (c1 == 13):
                    k = 3
                else:
                    k = 4
            elif (k1 == 3):
                c2 = s.b[2]
                if (c2 == 10):
                    if (s.b[1] != 13):
                        k = 4
                    elif (s.b[0] != 10):
                        k = 2
                    else:
                        break
                elif (c2 == 13):
                    if ((s.b[1] != 10) or ((s.b[0] != 13))):
                        k = 1
                    else:
                        k = 3
                else:
                    k = 4
            elif (k1 == 4):
                c3 = s.b[3]
                if (c3 == 10):
                    if (s.b[2] != 13):
                        continue
                    elif ((s.b[1] != 10) or ((s.b[0] != 13))):
                        k = 2
                    else:
                        break
                elif (c3 == 13):
                    if ((s.b[2] != 10) or ((s.b[1] != 13))):
                        k = 3
                    else:
                        k = 1
            else:
                pass
        _this = b.getBytes().toString()
        headers = _this.split("\r\n")
        response = (None if ((len(headers) == 0)) else headers.pop(0))
        rp = response.split(" ")
        status = Std.parseInt((rp[1] if 1 < len(rp) else None))
        if ((status == 0) or ((status is None))):
            raise haxe_Exception.thrown("Response status error")
        if (len(headers) != 0):
            headers.pop()
        if (len(headers) != 0):
            headers.pop()
        self.responseHeaders = haxe_ds_StringMap()
        size = None
        chunked = False
        _g = 0
        while (_g < len(headers)):
            hline = (headers[_g] if _g >= 0 and _g < len(headers) else None)
            _g = (_g + 1)
            a = hline.split(": ")
            hname = (None if ((len(a) == 0)) else a.pop(0))
            hval = ((a[0] if 0 < len(a) else None) if ((len(a) == 1)) else ": ".join([python_Boot.toString1(x1,'') for x1 in a]))
            hval = StringTools.ltrim(StringTools.rtrim(hval))
            self.responseHeaders.h[hname] = hval
            _g1 = hname.lower()
            _hx_local_2 = len(_g1)
            if (_hx_local_2 == 17):
                if (_g1 == "transfer-encoding"):
                    chunked = (hval.lower() == "chunked")
            elif (_hx_local_2 == 14):
                if (_g1 == "content-length"):
                    size = Std.parseInt(hval)
            else:
                pass
        self.onStatus(status)
        chunk_re = EReg("^([0-9A-Fa-f]+)[ ]*\r\n","m")
        self.chunk_size = None
        self.chunk_buf = None
        bufsize = 1024
        buf = haxe_io_Bytes.alloc(bufsize)
        if chunked:
            try:
                while True:
                    _hx_len = sock.input.readBytes(buf,0,bufsize)
                    if (not self.readChunk(chunk_re,api,buf,_hx_len)):
                        break
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                    raise haxe_Exception.thrown("Transfer aborted")
                else:
                    raise _g
        elif (size is None):
            if (not self.noShutdown):
                sock.shutdown(False,True)
            try:
                while True:
                    _hx_len = sock.input.readBytes(buf,0,bufsize)
                    if (_hx_len == 0):
                        break
                    api.writeBytes(buf,0,_hx_len)
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                    raise _g
        else:
            api.prepare(size)
            try:
                while (size > 0):
                    _hx_len = sock.input.readBytes(buf,0,(bufsize if ((size > bufsize)) else size))
                    api.writeBytes(buf,0,_hx_len)
                    size = (size - _hx_len)
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                    raise haxe_Exception.thrown("Transfer aborted")
                else:
                    raise _g
        if (chunked and (((self.chunk_size is not None) or ((self.chunk_buf is not None))))):
            raise haxe_Exception.thrown("Invalid chunk")
        if ((status < 200) or ((status >= 400))):
            raise haxe_Exception.thrown(("Http Error #" + Std.string(status)))
        api.close()

    def readChunk(self,chunk_re,api,buf,_hx_len):
        if (self.chunk_size is None):
            if (self.chunk_buf is not None):
                b = haxe_io_BytesBuffer()
                b.b.extend(self.chunk_buf.b)
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
                b.b.extend(buf.b[0:_hx_len])
                buf = b.getBytes()
                _hx_len = (_hx_len + self.chunk_buf.length)
                self.chunk_buf = None
            s = buf.toString()
            chunk_re.matchObj = python_lib_Re.search(chunk_re.pattern,s)
            if (chunk_re.matchObj is not None):
                p_pos = chunk_re.matchObj.start()
                p_len = (chunk_re.matchObj.end() - chunk_re.matchObj.start())
                if (p_len <= _hx_len):
                    cstr = chunk_re.matchObj.group(1)
                    self.chunk_size = Std.parseInt(("0x" + ("null" if cstr is None else cstr)))
                    if (self.chunk_size == 0):
                        self.chunk_size = None
                        self.chunk_buf = None
                        return False
                    _hx_len = (_hx_len - p_len)
                    return self.readChunk(chunk_re,api,buf.sub(p_len,_hx_len),_hx_len)
            if (_hx_len > 10):
                self.onError("Invalid chunk")
                return False
            self.chunk_buf = buf.sub(0,_hx_len)
            return True
        if (self.chunk_size > _hx_len):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.chunk_size
            _hx_local_2.chunk_size = (_hx_local_3 - _hx_len)
            _hx_local_2.chunk_size
            api.writeBytes(buf,0,_hx_len)
            return True
        end = (self.chunk_size + 2)
        if (_hx_len >= end):
            if (self.chunk_size > 0):
                api.writeBytes(buf,0,self.chunk_size)
            _hx_len = (_hx_len - end)
            self.chunk_size = None
            if (_hx_len == 0):
                return True
            return self.readChunk(chunk_re,api,buf.sub(end,_hx_len),_hx_len)
        if (self.chunk_size > 0):
            api.writeBytes(buf,0,self.chunk_size)
        _hx_local_5 = self
        _hx_local_6 = _hx_local_5.chunk_size
        _hx_local_5.chunk_size = (_hx_local_6 - _hx_len)
        _hx_local_5.chunk_size
        return True

    @staticmethod
    def requestUrl(url):
        h = sys_Http(url)
        r = None
        def _hx_local_0(d):
            nonlocal r
            r = d
        h.onData = _hx_local_0
        def _hx_local_1(e):
            raise haxe_Exception.thrown(e)
        h.onError = _hx_local_1
        h.request(False)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.noShutdown = None
        _hx_o.cnxTimeout = None
        _hx_o.responseHeaders = None
        _hx_o.chunk_size = None
        _hx_o.chunk_buf = None
        _hx_o.file = None
sys_Http._hx_class = sys_Http


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()
sys_io_File._hx_class = sys_io_File


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "readAll", "readLine"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def readAll(self,bufsize = None):
        return self.impl.readAll(bufsize)

    def readLine(self):
        return self.impl.readLine()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileInput._hx_class = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "close", "writeFullBytes", "prepare", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def prepare(self,nbytes):
        self.impl.prepare(nbytes)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileOutput._hx_class = sys_io_FileOutput


class sys_io_Process:
    _hx_class_name = "sys.io.Process"
    __slots__ = ("stdout", "stderr", "stdin", "p")
    _hx_fields = ["stdout", "stderr", "stdin", "p"]
    _hx_methods = ["exitCode", "close"]

    def __init__(self,cmd,args = None,detached = None):
        self.stdin = None
        self.stderr = None
        self.stdout = None
        if detached:
            raise haxe_Exception.thrown("Detached process is not supported on this platform")
        args1 = (cmd if ((args is None)) else ([cmd] + args))
        o = _hx_AnonObject({'shell': (args is None), 'stdin': python_lib_Subprocess.PIPE, 'stdout': python_lib_Subprocess.PIPE, 'stderr': python_lib_Subprocess.PIPE})
        Reflect.setField(o,"bufsize",(Reflect.field(o,"bufsize") if (python_Boot.hasField(o,"bufsize")) else 0))
        Reflect.setField(o,"executable",(Reflect.field(o,"executable") if (python_Boot.hasField(o,"executable")) else None))
        Reflect.setField(o,"stdin",(Reflect.field(o,"stdin") if (python_Boot.hasField(o,"stdin")) else None))
        Reflect.setField(o,"stdout",(Reflect.field(o,"stdout") if (python_Boot.hasField(o,"stdout")) else None))
        Reflect.setField(o,"stderr",(Reflect.field(o,"stderr") if (python_Boot.hasField(o,"stderr")) else None))
        Reflect.setField(o,"preexec_fn",(Reflect.field(o,"preexec_fn") if (python_Boot.hasField(o,"preexec_fn")) else None))
        Reflect.setField(o,"close_fds",(Reflect.field(o,"close_fds") if (python_Boot.hasField(o,"close_fds")) else None))
        Reflect.setField(o,"shell",(Reflect.field(o,"shell") if (python_Boot.hasField(o,"shell")) else None))
        Reflect.setField(o,"cwd",(Reflect.field(o,"cwd") if (python_Boot.hasField(o,"cwd")) else None))
        Reflect.setField(o,"env",(Reflect.field(o,"env") if (python_Boot.hasField(o,"env")) else None))
        Reflect.setField(o,"universal_newlines",(Reflect.field(o,"universal_newlines") if (python_Boot.hasField(o,"universal_newlines")) else None))
        Reflect.setField(o,"startupinfo",(Reflect.field(o,"startupinfo") if (python_Boot.hasField(o,"startupinfo")) else None))
        Reflect.setField(o,"creationflags",(Reflect.field(o,"creationflags") if (python_Boot.hasField(o,"creationflags")) else 0))
        self.p = (python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo"),Reflect.field(o,"creationflags")) if ((Sys.systemName() == "Windows")) else python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo")))
        self.stdout = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stdout)))
        self.stderr = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stderr)))
        self.stdin = python_io_IoTools.createFileOutputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedWriter(self.p.stdin)))

    def exitCode(self,block = None):
        if (block is None):
            block = True
        if (block == False):
            return self.p.poll()
        return self.p.wait()

    def close(self):
        ver = python_lib_Sys.version_info
        if ((ver[0] > 3) or (((ver[0] == 3) and ((ver[1] >= 3))))):
            try:
                self.p.terminate()
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),ProcessLookupError)):
                    raise _g
        else:
            try:
                self.p.terminate()
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),OSError)):
                    raise _g

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stdout = None
        _hx_o.stderr = None
        _hx_o.stdin = None
        _hx_o.p = None
sys_io_Process._hx_class = sys_io_Process


class sys_net_Host:
    _hx_class_name = "sys.net.Host"
    __slots__ = ("host", "name")
    _hx_fields = ["host", "name"]
    _hx_methods = ["toString"]

    def __init__(self,name):
        self.host = name
        self.name = name

    def toString(self):
        return self.name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.host = None
        _hx_o.name = None
sys_net_Host._hx_class = sys_net_Host


class sys_net__Socket_SocketInput(haxe_io_Input):
    _hx_class_name = "sys.net._Socket.SocketInput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self._hx___s = s

    def readByte(self):
        r = None
        try:
            r = self._hx___s.recv(1,0)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g
        if (len(r) == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        return r[0]

    def readBytes(self,buf,pos,_hx_len):
        r = None
        data = buf.b
        try:
            r = self._hx___s.recv(_hx_len,0)
            _g = pos
            _g1 = (pos + len(r))
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                data.__setitem__(i,r[(i - pos)])
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g
        if (len(r) == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        return len(r)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___s = None
sys_net__Socket_SocketInput._hx_class = sys_net__Socket_SocketInput


class sys_net__Socket_SocketOutput(haxe_io_Output):
    _hx_class_name = "sys.net._Socket.SocketOutput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["writeByte", "writeBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,s):
        self._hx___s = s

    def writeByte(self,c):
        try:
            self._hx___s.send(bytes([c]),0)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g

    def writeBytes(self,buf,pos,_hx_len):
        try:
            data = buf.b
            payload = data[pos:pos+_hx_len]
            r = self._hx___s.send(payload,0)
            return r
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g

    def close(self):
        super().close()
        if (self._hx___s is not None):
            self._hx___s.close()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___s = None
sys_net__Socket_SocketOutput._hx_class = sys_net__Socket_SocketOutput


class utest_Assert:
    _hx_class_name = "utest.Assert"
    __slots__ = ()
    _hx_statics = ["results", "processResult", "isTrue", "isFalse", "isNull", "notNull", "is", "isOfType", "notEquals", "equals", "match", "floatEquals", "_floatEquals", "getTypeName", "isIterable", "isIterator", "sameAs", "q", "same", "raises", "allows", "contains", "notContains", "stringContains", "stringSequence", "pass", "fail", "warn", "createAsync", "createEvent", "typeToString"]
    results = None

    @staticmethod
    def processResult(cond,getMessage,pos = None):
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure(getMessage(),pos))
        return cond

    @staticmethod
    def isTrue(cond,msg = None,pos = None):
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else "expected true"),pos))
        return cond

    @staticmethod
    def isFalse(value,msg = None,pos = None):
        cond = (value == False)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else "expected false"),pos))
        return cond

    @staticmethod
    def isNull(value,msg = None,pos = None):
        cond = (value is None)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else ("expected null but it is " + HxOverrides.stringOrNull(utest_Assert.q(value)))),pos))
        return cond

    @staticmethod
    def notNull(value,msg = None,pos = None):
        cond = (value is not None)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else "expected not null"),pos))
        return cond

    @staticmethod
    def _hx_is(value,_hx_type,msg = None,pos = None):
        return utest_Assert.isOfType(value,_hx_type,msg,pos)

    @staticmethod
    def isOfType(value,_hx_type,msg = None,pos = None):
        cond = Std.isOfType(value,_hx_type)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else ((("expected type " + HxOverrides.stringOrNull(utest_Assert.typeToString(_hx_type))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.typeToString(value)))),pos))
        return cond

    @staticmethod
    def notEquals(expected,value,msg = None,pos = None):
        cond = not HxOverrides.eq(expected,value)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " and test value ") + HxOverrides.stringOrNull(utest_Assert.q(value))) + " should be different")),pos))
        return cond

    @staticmethod
    def equals(expected,value,msg = None,pos = None):
        cond = HxOverrides.eq(expected,value)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else ((("expected " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value)))),pos))
        return cond

    @staticmethod
    def match(pattern,value,msg = None,pos = None):
        pattern.matchObj = python_lib_Re.search(pattern.pattern,value)
        cond = (pattern.matchObj is not None)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else (("the value " + HxOverrides.stringOrNull(utest_Assert.q(value))) + " does not match the provided pattern")),pos))
        return cond

    @staticmethod
    def floatEquals(expected,value,approx = None,msg = None,pos = None):
        cond = utest_Assert._floatEquals(expected,value,approx)
        if (utest_Assert.results is None):
            raise haxe_Exception.thrown((((("Assert at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " out of context. Most likely you are trying to assert after a test timeout."))
        if cond:
            utest_Assert.results.add(utest_Assertation.Success(pos))
        else:
            utest_Assert.results.add(utest_Assertation.Failure((msg if ((msg is not None)) else ((("expected " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value)))),pos))
        return cond

    @staticmethod
    def _floatEquals(expected,value,approx = None):
        if python_lib_Math.isnan(expected):
            return python_lib_Math.isnan(value)
        elif python_lib_Math.isnan(value):
            return False
        elif ((not ((((expected != Math.POSITIVE_INFINITY) and ((expected != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(expected))))) and (not ((((value != Math.POSITIVE_INFINITY) and ((value != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(value)))))):
            return ((expected > 0) == ((value > 0)))
        if (None == approx):
            approx = 1e-5
        return (Reflect.field(Math,"fabs")((value - expected)) <= approx)

    @staticmethod
    def getTypeName(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            return "`null`"
        elif (tmp == 1):
            return "Int"
        elif (tmp == 2):
            return "Float"
        elif (tmp == 3):
            return "Bool"
        elif (tmp == 4):
            return "Object"
        elif (tmp == 5):
            return "function"
        elif (tmp == 6):
            c = _g.params[0]
            return Type.getClassName(c)
        elif (tmp == 7):
            e = _g.params[0]
            return Type.getEnumName(e)
        elif (tmp == 8):
            return "`Unknown`"
        else:
            pass

    @staticmethod
    def isIterable(v,isAnonym):
        fields = (python_Boot.fields(v) if isAnonym else python_Boot.getInstanceFields(Type.getClass(v)))
        if (not Lambda.has(fields,"iterator")):
            return False
        return Reflect.isFunction(Reflect.field(v,"iterator"))

    @staticmethod
    def isIterator(v,isAnonym):
        fields = (python_Boot.fields(v) if isAnonym else python_Boot.getInstanceFields(Type.getClass(v)))
        if ((not Lambda.has(fields,"next")) or (not Lambda.has(fields,"hasNext"))):
            return False
        if Reflect.isFunction(Reflect.field(v,"next")):
            return Reflect.isFunction(Reflect.field(v,"hasNext"))
        else:
            return False

    @staticmethod
    def sameAs(expected,value,status,approx):
        texpected = utest_Assert.getTypeName(expected)
        tvalue = utest_Assert.getTypeName(value)
        status.expectedValue = expected
        status.actualValue = value
        if ((texpected != tvalue) and (not ((((texpected == "Int") and ((tvalue == "Float"))) or (((texpected == "Float") and ((tvalue == "Int")))))))):
            status.error = (((("expected type " + ("null" if texpected is None else texpected)) + " but it is ") + ("null" if tvalue is None else tvalue)) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
            return False
        _g = Type.typeof(expected)
        tmp = _g.index
        if ((tmp == 2) or ((tmp == 1))):
            if (not utest_Assert._floatEquals(expected,value,approx)):
                status.error = (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                return False
            return True
        elif ((tmp == 3) or ((tmp == 0))):
            if not HxOverrides.eq(expected,value):
                status.error = (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                return False
            return True
        elif (tmp == 4):
            if (status.recursive or ((status.path == ""))):
                tfields = python_Boot.fields(value)
                fields = python_Boot.fields(expected)
                path = status.path
                _g1 = 0
                while (_g1 < len(fields)):
                    field = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                    _g1 = (_g1 + 1)
                    python_internal_ArrayImpl.remove(tfields,field)
                    status.path = (field if ((path == "")) else ((("null" if path is None else path) + ".") + ("null" if field is None else field)))
                    if (not python_Boot.hasField(value,field)):
                        status.error = ((("expected field " + HxOverrides.stringOrNull(status.path)) + " does not exist in ") + HxOverrides.stringOrNull(utest_Assert.q(value)))
                        return False
                    e = Reflect.field(expected,field)
                    if Reflect.isFunction(e):
                        continue
                    v = Reflect.field(value,field)
                    if (not utest_Assert.sameAs(e,v,status,approx)):
                        return False
                if (len(tfields) > 0):
                    status.error = (("the tested object has extra field(s) (" + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in tfields]))) + ") not included in the expected ones")
                    return False
            if utest_Assert.isIterator(expected,True):
                if (not utest_Assert.isIterator(value,True)):
                    status.error = ("expected Iterable but it is not " + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                    return False
                if (status.recursive or ((status.path == ""))):
                    def _hx_local_1():
                        return expected
                    evalues = Lambda.array(_hx_AnonObject({'iterator': _hx_local_1}))
                    def _hx_local_2():
                        return value
                    vvalues = Lambda.array(_hx_AnonObject({'iterator': _hx_local_2}))
                    if (len(evalues) != len(vvalues)):
                        status.error = (((("expected " + Std.string(len(evalues))) + " values in Iterator but they are ") + Std.string(len(vvalues))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                        return False
                    path = status.path
                    _g1 = 0
                    _g2 = len(evalues)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        status.path = ((("iterator[" + Std.string(i)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(i)) + "]"))
                        if (not utest_Assert.sameAs((evalues[i] if i >= 0 and i < len(evalues) else None),(vvalues[i] if i >= 0 and i < len(vvalues) else None),status,approx)):
                            status.error = (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(status.expectedValue))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(status.actualValue))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                            return False
                return True
            if utest_Assert.isIterable(expected,True):
                if (not utest_Assert.isIterable(value,True)):
                    status.error = ("expected Iterator but it is not " + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                    return False
                if (status.recursive or ((status.path == ""))):
                    evalues = Lambda.array(expected)
                    vvalues = Lambda.array(value)
                    if (len(evalues) != len(vvalues)):
                        status.error = (((("expected " + Std.string(len(evalues))) + " values in Iterable but they are ") + Std.string(len(vvalues))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                        return False
                    path = status.path
                    _g1 = 0
                    _g2 = len(evalues)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        status.path = ((("iterable[" + Std.string(i)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(i)) + "]"))
                        if (not utest_Assert.sameAs((evalues[i] if i >= 0 and i < len(evalues) else None),(vvalues[i] if i >= 0 and i < len(vvalues) else None),status,approx)):
                            return False
                return True
            return True
        elif (tmp == 5):
            if (not Reflect.compareMethods(expected,value)):
                status.error = ("expected same function reference" + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                return False
            return True
        elif (tmp == 6):
            c = _g.params[0]
            cexpected = Type.getClassName(c)
            cvalue = Type.getClassName(Type.getClass(value))
            if (cexpected != cvalue):
                status.error = (((("expected instance of " + HxOverrides.stringOrNull(utest_Assert.q(cexpected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(cvalue))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                return False
            if Std.isOfType(expected,str):
                if HxOverrides.eq(expected,value):
                    return True
                else:
                    status.error = (((("expected string '" + Std.string(expected)) + "' but it is '") + Std.string(value)) + "'")
                    return False
            if Std.isOfType(expected,list):
                if (status.recursive or ((status.path == ""))):
                    if not HxOverrides.eq(Reflect.field(expected,"length"),Reflect.field(value,"length")):
                        status.error = (((("expected " + Std.string(Reflect.field(expected,"length"))) + " elements but they are ") + Std.string(Reflect.field(value,"length"))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                        return False
                    path = status.path
                    _g1 = 0
                    _g2 = Reflect.field(expected,"length")
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        status.path = ((("array[" + Std.string(i)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(i)) + "]"))
                        if (not utest_Assert.sameAs(HxOverrides.arrayGet(expected, i),HxOverrides.arrayGet(value, i),status,approx)):
                            status.error = (((((("expected array element at [" + Std.string(i)) + "] to have ") + HxOverrides.stringOrNull(utest_Assert.q(status.expectedValue))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(status.actualValue))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                            return False
                return True
            if Std.isOfType(expected,Date):
                if not HxOverrides.eq(Reflect.field(expected,"getTime")(),Reflect.field(value,"getTime")()):
                    status.error = (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                    return False
                return True
            if Std.isOfType(expected,haxe_io_Bytes):
                if (status.recursive or ((status.path == ""))):
                    ebytes = expected
                    vbytes = value
                    if (ebytes.length != vbytes.length):
                        return False
                    _g1 = 0
                    _g2 = ebytes.length
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        if (ebytes.b[i] != vbytes.b[i]):
                            status.error = (((("expected byte " + Std.string(ebytes.b[i])) + " but it is ") + Std.string(vbytes.b[i])) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                            return False
                return True
            if Std.isOfType(expected,haxe_IMap):
                if (status.recursive or ((status.path == ""))):
                    def _hx_local_4():
                        _hx_local_3 = expected
                        if (Std.isOfType(_hx_local_3,haxe_IMap) or ((_hx_local_3 is None))):
                            _hx_local_3
                        else:
                            raise "Class cast error"
                        return _hx_local_3
                    _hx_map = _hx_local_4()
                    def _hx_local_6():
                        _hx_local_5 = value
                        if (Std.isOfType(_hx_local_5,haxe_IMap) or ((_hx_local_5 is None))):
                            _hx_local_5
                        else:
                            raise "Class cast error"
                        return _hx_local_5
                    vmap = _hx_local_6()
                    _g1 = []
                    k = _hx_map.keys()
                    while k.hasNext():
                        k1 = k.next()
                        _g1.append(k1)
                    keys = _g1
                    _g1 = []
                    k = vmap.keys()
                    while k.hasNext():
                        k1 = k.next()
                        _g1.append(k1)
                    vkeys = _g1
                    if (len(keys) != len(vkeys)):
                        status.error = (((("expected " + Std.string(len(keys))) + " keys but they are ") + Std.string(len(vkeys))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                        return False
                    path = status.path
                    _g1 = 0
                    while (_g1 < len(keys)):
                        key = (keys[_g1] if _g1 >= 0 and _g1 < len(keys) else None)
                        _g1 = (_g1 + 1)
                        status.path = ((("hash[" + Std.string(key)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(key)) + "]"))
                        if (not utest_Assert.sameAs(_hx_map.get(key),vmap.get(key),status,approx)):
                            status.error = (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(status.expectedValue))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(status.actualValue))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                            return False
                return True
            if utest_Assert.isIterator(expected,False):
                if (status.recursive or ((status.path == ""))):
                    def _hx_local_8():
                        return expected
                    evalues = Lambda.array(_hx_AnonObject({'iterator': _hx_local_8}))
                    def _hx_local_9():
                        return value
                    vvalues = Lambda.array(_hx_AnonObject({'iterator': _hx_local_9}))
                    if (len(evalues) != len(vvalues)):
                        status.error = (((("expected " + Std.string(len(evalues))) + " values in Iterator but they are ") + Std.string(len(vvalues))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                        return False
                    path = status.path
                    _g1 = 0
                    _g2 = len(evalues)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        status.path = ((("iterator[" + Std.string(i)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(i)) + "]"))
                        if (not utest_Assert.sameAs((evalues[i] if i >= 0 and i < len(evalues) else None),(vvalues[i] if i >= 0 and i < len(vvalues) else None),status,approx)):
                            status.error = (((("expected " + HxOverrides.stringOrNull(utest_Assert.q(status.expectedValue))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(status.actualValue))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                            return False
                return True
            if utest_Assert.isIterable(expected,False):
                if (status.recursive or ((status.path == ""))):
                    evalues = Lambda.array(expected)
                    vvalues = Lambda.array(value)
                    if (len(evalues) != len(vvalues)):
                        status.error = (((("expected " + Std.string(len(evalues))) + " values in Iterable but they are ") + Std.string(len(vvalues))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                        return False
                    path = status.path
                    _g1 = 0
                    _g2 = len(evalues)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        status.path = ((("iterable[" + Std.string(i)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(i)) + "]"))
                        if (not utest_Assert.sameAs((evalues[i] if i >= 0 and i < len(evalues) else None),(vvalues[i] if i >= 0 and i < len(vvalues) else None),status,approx)):
                            return False
                return True
            if (status.recursive or ((status.path == ""))):
                fields = python_Boot.getInstanceFields(Type.getClass(expected))
                path = status.path
                _g1 = 0
                while (_g1 < len(fields)):
                    field = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                    _g1 = (_g1 + 1)
                    status.path = (field if ((path == "")) else ((("null" if path is None else path) + ".") + ("null" if field is None else field)))
                    e = Reflect.field(expected,field)
                    if Reflect.isFunction(e):
                        continue
                    v = Reflect.field(value,field)
                    if (not utest_Assert.sameAs(e,v,status,approx)):
                        return False
            return True
        elif (tmp == 7):
            e = _g.params[0]
            eexpected = Type.getEnumName(e)
            evalue = Type.getEnumName(Type.getEnum(value))
            if (eexpected != evalue):
                status.error = (((("expected enumeration of " + HxOverrides.stringOrNull(utest_Assert.q(eexpected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(evalue))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                return False
            if (status.recursive or ((status.path == ""))):
                if (expected.index != value.index):
                    status.error = (((("expected enum constructor " + HxOverrides.stringOrNull(utest_Assert.q(expected.tag))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value.tag))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path))))))
                    return False
                eparams = list(expected.params)
                vparams = list(value.params)
                path = status.path
                _g = 0
                _g1 = len(eparams)
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    status.path = ((("enum[" + Std.string(i)) + "]") if ((path == "")) else (((("null" if path is None else path) + "[") + Std.string(i)) + "]"))
                    if (not utest_Assert.sameAs((eparams[i] if i >= 0 and i < len(eparams) else None),(vparams[i] if i >= 0 and i < len(vparams) else None),status,approx)):
                        status.error = (((((("expected enum param " + HxOverrides.stringOrNull(utest_Assert.q(expected))) + " but it is ") + HxOverrides.stringOrNull(utest_Assert.q(value))) + HxOverrides.stringOrNull((("" if ((status.path == "")) else (" for field " + HxOverrides.stringOrNull(status.path)))))) + " with ") + HxOverrides.stringOrNull(status.error))
                        return False
            return True
        elif (tmp == 8):
            raise haxe_Exception.thrown("Unable to compare two unknown types")
        else:
            pass

    @staticmethod
    def q(v):
        if Std.isOfType(v,str):
            return (("\"" + HxOverrides.stringOrNull(StringTools.replace(v,"\"","\\\""))) + "\"")
        else:
            return Std.string(v)

    @staticmethod
    def same(expected,value,recursive = None,msg = None,approx = None,pos = None):
        if (None == approx):
            approx = 1e-5
        status = _hx_AnonObject({'recursive': (True if ((None == recursive)) else recursive), 'path': "", 'error': None, 'expectedValue': expected, 'actualValue': value})
        if utest_Assert.sameAs(expected,value,status,approx):
            return utest_Assert._hx_pass(msg,pos)
        else:
            return utest_Assert.fail((status.error if ((msg is None)) else msg),pos)

    @staticmethod
    def raises(method,_hx_type = None,msgNotThrown = None,msgWrongType = None,pos = None):
        name = (Type.getClassName(_hx_type) if ((_hx_type is not None)) else "Dynamic")
        try:
            method()
        except BaseException as _g:
            None
            ex = haxe_Exception.caught(_g).unwrap()
            if (None == _hx_type):
                return utest_Assert._hx_pass(None,pos)
            else:
                if (None == msgWrongType):
                    msgWrongType = ((("expected throw of type " + ("null" if name is None else name)) + " but it is ") + Std.string(ex))
                return utest_Assert.isTrue(Std.isOfType(ex,_hx_type),msgWrongType,pos)
        if (None == msgNotThrown):
            msgNotThrown = (("exception of type " + ("null" if name is None else name)) + " not raised")
        return utest_Assert.fail(msgNotThrown,pos)

    @staticmethod
    def allows(possibilities,value,msg = None,pos = None):
        if Lambda.has(possibilities,value):
            return utest_Assert.isTrue(True,msg,pos)
        else:
            return utest_Assert.fail((((("value " + HxOverrides.stringOrNull(utest_Assert.q(value))) + " not found in the expected possibilities ") + Std.string(possibilities)) if ((msg is None)) else msg),pos)

    @staticmethod
    def contains(match,values,msg = None,pos = None):
        if Lambda.has(values,match):
            return utest_Assert.isTrue(True,msg,pos)
        else:
            return utest_Assert.fail((((("values " + HxOverrides.stringOrNull(utest_Assert.q(values))) + " do not contain ") + Std.string(match)) if ((msg is None)) else msg),pos)

    @staticmethod
    def notContains(match,values,msg = None,pos = None):
        if (not Lambda.has(values,match)):
            return utest_Assert.isTrue(True,msg,pos)
        else:
            return utest_Assert.fail((((("values " + HxOverrides.stringOrNull(utest_Assert.q(values))) + " do contain ") + Std.string(match)) if ((msg is None)) else msg),pos)

    @staticmethod
    def stringContains(match,value,msg = None,pos = None):
        tmp = None
        if (value is not None):
            startIndex = None
            tmp = (((value.find(match) if ((startIndex is None)) else HxString.indexOfImpl(value,match,startIndex))) >= 0)
        else:
            tmp = False
        if tmp:
            return utest_Assert.isTrue(True,msg,pos)
        else:
            return utest_Assert.fail((((("value " + HxOverrides.stringOrNull(utest_Assert.q(value))) + " does not contain ") + HxOverrides.stringOrNull(utest_Assert.q(match))) if ((msg is None)) else msg),pos)

    @staticmethod
    def stringSequence(sequence,value,msg = None,pos = None):
        if (None == value):
            return utest_Assert.fail(("null argument value" if ((msg is None)) else msg),pos)
        p = 0
        _g = 0
        while (_g < len(sequence)):
            s = (sequence[_g] if _g >= 0 and _g < len(sequence) else None)
            _g = (_g + 1)
            p2 = (value.find(s) if ((p is None)) else HxString.indexOfImpl(value,s,p))
            if (p2 < 0):
                if (msg is None):
                    msg = (("expected '" + ("null" if s is None else s)) + "' after ")
                    if (p > 0):
                        cut = HxString.substr(value,0,p)
                        if (len(cut) > 30):
                            cut = ("..." + HxOverrides.stringOrNull(HxString.substr(cut,-27,None)))
                        msg = (("null" if msg is None else msg) + HxOverrides.stringOrNull((((" '" + ("null" if cut is None else cut)) + "'"))))
                    else:
                        msg = (("null" if msg is None else msg) + " begin")
                return utest_Assert.fail(msg,pos)
            p = (p2 + len(s))
        return utest_Assert.isTrue(True,msg,pos)

    @staticmethod
    def _hx_pass(msg = None,pos = None):
        if (msg is None):
            msg = "pass expected"
        return utest_Assert.isTrue(True,msg,pos)

    @staticmethod
    def fail(msg = None,pos = None):
        if (msg is None):
            msg = "failure expected"
        return utest_Assert.isTrue(False,msg,pos)

    @staticmethod
    def warn(msg):
        utest_Assert.results.add(utest_Assertation.Warning(msg))

    @staticmethod
    def createAsync(f = None,timeout = None):
        def _hx_local_0():
            pass
        return _hx_local_0

    @staticmethod
    def createEvent(f,timeout = None):
        def _hx_local_0(e):
            pass
        return _hx_local_0

    @staticmethod
    def typeToString(t):
        try:
            _t = Type.getClass(t)
            if (_t is not None):
                t = _t
        except BaseException as _g:
            None
        try:
            return Type.getClassName(t)
        except BaseException as _g:
            None
        try:
            _t = Type.getEnum(t)
            if (_t is not None):
                t = _t
        except BaseException as _g:
            None
        try:
            return Type.getEnumName(t)
        except BaseException as _g:
            None
        try:
            return Std.string(Type.typeof(t))
        except BaseException as _g:
            None
        try:
            return Std.string(t)
        except BaseException as _g:
            None
        return "<unable to retrieve type name>"
utest_Assert._hx_class = utest_Assert

class utest_Assertation(Enum):
    __slots__ = ()
    _hx_class_name = "utest.Assertation"
    _hx_constructs = ["Success", "Failure", "Error", "SetupError", "TeardownError", "TimeoutError", "AsyncError", "Warning", "Ignore"]

    @staticmethod
    def Success(pos):
        return utest_Assertation("Success", 0, (pos,))

    @staticmethod
    def Failure(msg,pos):
        return utest_Assertation("Failure", 1, (msg,pos))

    @staticmethod
    def Error(e,stack):
        return utest_Assertation("Error", 2, (e,stack))

    @staticmethod
    def SetupError(e,stack):
        return utest_Assertation("SetupError", 3, (e,stack))

    @staticmethod
    def TeardownError(e,stack):
        return utest_Assertation("TeardownError", 4, (e,stack))

    @staticmethod
    def TimeoutError(missedAsyncs,stack):
        return utest_Assertation("TimeoutError", 5, (missedAsyncs,stack))

    @staticmethod
    def AsyncError(e,stack):
        return utest_Assertation("AsyncError", 6, (e,stack))

    @staticmethod
    def Warning(msg):
        return utest_Assertation("Warning", 7, (msg,))

    @staticmethod
    def Ignore(reason):
        return utest_Assertation("Ignore", 8, (reason,))
utest_Assertation._hx_class = utest_Assertation


class utest_Async:
    _hx_class_name = "utest.Async"
    __slots__ = ("resolved", "timedOut", "callbacks", "timeoutMs", "startTime", "timer", "branches")
    _hx_fields = ["resolved", "timedOut", "callbacks", "timeoutMs", "startTime", "timer", "branches"]
    _hx_methods = ["done", "setTimeout", "branch", "checkBranches", "then", "setTimedOutState"]
    _hx_statics = ["resolvedInstance", "getResolved"]

    def __init__(self,timeoutMs = None):
        if (timeoutMs is None):
            timeoutMs = 250
        self.timer = None
        self.branches = []
        self.callbacks = []
        self.timedOut = False
        self.resolved = False
        self.timeoutMs = timeoutMs
        self.startTime = python_lib_Timeit.default_timer()
        self.timer = haxe_Timer.delay(self.setTimedOutState,timeoutMs)

    def done(self,pos = None):
        if self.resolved:
            if self.timedOut:
                raise haxe_Exception.thrown((((("Cannot done() at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " because async is timed out."))
            else:
                raise haxe_Exception.thrown((((("Cannot done() at " + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " because async is done already."))
        self.resolved = True
        self.timer.stop()
        _g = 0
        _g1 = self.callbacks
        while (_g < len(_g1)):
            cb = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cb()

    def setTimeout(self,timeoutMs,pos = None):
        if self.resolved:
            raise haxe_Exception.thrown((((((("Cannot setTimeout(" + Std.string(timeoutMs)) + ") at ") + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " because async is done."))
        if self.timedOut:
            raise haxe_Exception.thrown((((((("Cannot setTimeout(" + Std.string(timeoutMs)) + ") at ") + HxOverrides.stringOrNull(pos.fileName)) + ":") + Std.string(pos.lineNumber)) + " because async is timed out."))
        self.timer.stop()
        self.timeoutMs = timeoutMs
        delay = (timeoutMs - Math.floor(((1000 * ((python_lib_Timeit.default_timer() - self.startTime))) + 0.5)))
        self.timer = haxe_Timer.delay(self.setTimedOutState,delay)

    def branch(self,fn = None):
        branch = utest_Async(self.timeoutMs)
        _this = self.branches
        _this.append(branch)
        branch.then(self.checkBranches)
        if (fn is not None):
            fn(branch)
        return branch

    def checkBranches(self):
        _gthis = self
        if self.resolved:
            return
        _g = 0
        _g1 = self.branches
        while (_g < len(_g1)):
            branch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not branch.resolved):
                return
            if branch.timedOut:
                self.setTimedOutState()
                return
        branchCount = len(self.branches)
        def _hx_local_1():
            if (branchCount == len(_gthis.branches)):
                _gthis.done(_hx_AnonObject({'fileName': "utest/Async.hx", 'lineNumber': 97, 'className': "utest.Async", 'methodName': "checkBranches"}))
        haxe_Timer.delay(_hx_local_1,5)

    def then(self,cb):
        if self.resolved:
            cb()
        else:
            _this = self.callbacks
            _this.append(cb)

    def setTimedOutState(self):
        if self.resolved:
            return
        self.timedOut = True
        self.done(_hx_AnonObject({'fileName': "utest/Async.hx", 'lineNumber': 115, 'className': "utest.Async", 'methodName': "setTimedOutState"}))
    resolvedInstance = None

    @staticmethod
    def getResolved():
        if (utest_Async.resolvedInstance is None):
            utest_Async.resolvedInstance = utest_Async()
            utest_Async.resolvedInstance.done(_hx_AnonObject({'fileName': "utest/Async.hx", 'lineNumber': 30, 'className': "utest.Async", 'methodName': "getResolved"}))
        return utest_Async.resolvedInstance

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resolved = None
        _hx_o.timedOut = None
        _hx_o.callbacks = None
        _hx_o.timeoutMs = None
        _hx_o.startTime = None
        _hx_o.timer = None
        _hx_o.branches = None
utest_Async._hx_class = utest_Async

class utest__Dispatcher_EventException(Enum):
    __slots__ = ()
    _hx_class_name = "utest._Dispatcher.EventException"
    _hx_constructs = ["StopPropagation"]
utest__Dispatcher_EventException.StopPropagation = utest__Dispatcher_EventException("StopPropagation", 0, ())
utest__Dispatcher_EventException._hx_class = utest__Dispatcher_EventException


class utest_Dispatcher:
    _hx_class_name = "utest.Dispatcher"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["add", "remove", "clear", "dispatch", "has"]
    _hx_statics = ["stop"]

    def __init__(self):
        self.handlers = list()

    def add(self,h):
        _this = self.handlers
        _this.append(h)
        return h

    def remove(self,h):
        _g = 0
        _g1 = len(self.handlers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if Reflect.compareMethods((self.handlers[i] if i >= 0 and i < len(self.handlers) else None),h):
                _this = self.handlers
                pos = i
                if (pos < 0):
                    pos = (len(_this) + pos)
                if (pos < 0):
                    pos = 0
                res = _this[pos:(pos + 1)]
                del _this[pos:(pos + 1)]
                return (res[0] if 0 < len(res) else None)
        return None

    def clear(self):
        self.handlers = list()

    def dispatch(self,e):
        try:
            _hx_list = list(self.handlers)
            _g = 0
            while (_g < len(_hx_list)):
                l = (_hx_list[_g] if _g >= 0 and _g < len(_hx_list) else None)
                _g = (_g + 1)
                l(e)
            return True
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),utest__Dispatcher_EventException):
                return False
            else:
                raise _g

    def has(self):
        return (len(self.handlers) > 0)

    @staticmethod
    def stop():
        raise haxe_Exception.thrown(utest__Dispatcher_EventException.StopPropagation)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handlers = None
utest_Dispatcher._hx_class = utest_Dispatcher


class utest_Notifier:
    _hx_class_name = "utest.Notifier"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["add", "remove", "clear", "dispatch", "has"]
    _hx_statics = ["stop"]

    def __init__(self):
        self.handlers = list()

    def add(self,h):
        _this = self.handlers
        _this.append(h)
        return h

    def remove(self,h):
        _g = 0
        _g1 = len(self.handlers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if Reflect.compareMethods((self.handlers[i] if i >= 0 and i < len(self.handlers) else None),h):
                _this = self.handlers
                pos = i
                if (pos < 0):
                    pos = (len(_this) + pos)
                if (pos < 0):
                    pos = 0
                res = _this[pos:(pos + 1)]
                del _this[pos:(pos + 1)]
                return (res[0] if 0 < len(res) else None)
        return None

    def clear(self):
        self.handlers = list()

    def dispatch(self):
        try:
            _hx_list = list(self.handlers)
            _g = 0
            while (_g < len(_hx_list)):
                l = (_hx_list[_g] if _g >= 0 and _g < len(_hx_list) else None)
                _g = (_g + 1)
                l()
            return True
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),utest__Dispatcher_EventException):
                return False
            else:
                raise _g

    def has(self):
        return (len(self.handlers) > 0)

    @staticmethod
    def stop():
        raise haxe_Exception.thrown(utest__Dispatcher_EventException.StopPropagation)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handlers = None
utest_Notifier._hx_class = utest_Notifier


class utest_TestHandler:
    _hx_class_name = "utest.TestHandler"
    __slots__ = ("results", "fixture", "finished", "asyncStack", "onTested", "onTimeout", "onComplete", "onPrecheck", "precheck", "wasBound", "expiration")
    _hx_fields = ["results", "fixture", "finished", "asyncStack", "onTested", "onTimeout", "onComplete", "onPrecheck", "precheck", "wasBound", "expiration"]
    _hx_methods = ["execute", "executeFixtureMethod", "executeFinally", "checkTested", "setTimeout", "bindHandler", "unbindHandler", "addAsync", "addEvent", "executeMethod", "executeAsyncMethod", "tested", "timeout", "completed", "completedFinally"]
    _hx_statics = ["POLLING_TIME", "exceptionStack"]

    def __init__(self,fixture):
        self.expiration = None
        self.precheck = None
        self.wasBound = False
        self.finished = False
        if (fixture is None):
            raise haxe_Exception.thrown("fixture argument is null")
        self.fixture = fixture
        self.results = haxe_ds_List()
        self.asyncStack = haxe_ds_List()
        self.onTested = utest_Dispatcher()
        self.onTimeout = utest_Dispatcher()
        self.onComplete = utest_Dispatcher()
        self.onPrecheck = utest_Dispatcher()
        if (fixture.ignoringInfo is not None):
            self.results.add(utest_Assertation.Ignore(fixture.ignoringInfo))

    def execute(self):
        _gthis = self
        if (self.fixture.ignoringInfo is not None):
            self.executeFinally()
            return
        isSync = True
        expectingAsync = True
        def _hx_local_0():
            nonlocal expectingAsync
            if isSync:
                expectingAsync = False
                return
            _gthis.executeFixtureMethod()
            _gthis.executeFinally()
        run = _hx_local_0
        try:
            self.executeMethod(self.fixture.setup)
            self.executeAsyncMethod(self.fixture.setupAsync,run)
            if (not expectingAsync):
                self.executeFixtureMethod()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.results.add(utest_Assertation.SetupError(e,utest_TestHandler.exceptionStack()))
        isSync = False
        if (not expectingAsync):
            self.executeFinally()

    def executeFixtureMethod(self):
        try:
            self.executeMethod(self.fixture.method)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.results.add(utest_Assertation.Error(e,utest_TestHandler.exceptionStack()))

    def executeFinally(self):
        self.onPrecheck.dispatch(self)
        self.checkTested()

    def checkTested(self):
        if ((self.expiration is None) or ((self.asyncStack.length == 0))):
            self.tested()
        elif (python_lib_Timeit.default_timer() > self.expiration):
            self.timeout()
        else:
            haxe_Timer.delay(self.checkTested,10)

    def setTimeout(self,timeout):
        newExpire = (python_lib_Timeit.default_timer() + ((timeout / 1000)))
        self.expiration = (newExpire if ((self.expiration is None)) else (newExpire if ((newExpire > self.expiration)) else self.expiration))

    def bindHandler(self):
        if self.wasBound:
            return
        utest_Assert.results = self.results
        utest_Assert.createAsync = self.addAsync
        utest_Assert.createEvent = self.addEvent
        self.wasBound = True

    def unbindHandler(self):
        if (not self.wasBound):
            return
        utest_Assert.results = None
        def _hx_local_1(f = None,t = None):
            def _hx_local_0():
                pass
            return _hx_local_0
        utest_Assert.createAsync = _hx_local_1
        def _hx_local_3(f,t = None):
            def _hx_local_2(e):
                pass
            return _hx_local_2
        utest_Assert.createEvent = _hx_local_3
        self.wasBound = False

    def addAsync(self,f = None,timeout = None):
        if (timeout is None):
            timeout = 250
        if (None == f):
            def _hx_local_0():
                pass
            f = _hx_local_0
        self.asyncStack.add(f)
        handler = self
        self.setTimeout(timeout)
        def _hx_local_1():
            if (not handler.asyncStack.remove(f)):
                handler.results.add(utest_Assertation.AsyncError("async function already executed",[]))
                return
            try:
                handler.bindHandler()
                f()
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                handler.results.add(utest_Assertation.AsyncError(e,utest_TestHandler.exceptionStack(0)))
        return _hx_local_1

    def addEvent(self,f,timeout = None):
        if (timeout is None):
            timeout = 250
        self.asyncStack.add(f)
        handler = self
        self.setTimeout(timeout)
        def _hx_local_0(e):
            if (not handler.asyncStack.remove(f)):
                handler.results.add(utest_Assertation.AsyncError("event already executed",[]))
                return
            try:
                handler.bindHandler()
                f(e)
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                handler.results.add(utest_Assertation.AsyncError(e,utest_TestHandler.exceptionStack(0)))
        return _hx_local_0

    def executeMethod(self,name):
        if (name is None):
            return
        self.bindHandler()
        Reflect.callMethod(self.fixture.target,Reflect.field(self.fixture.target,name),[])

    def executeAsyncMethod(self,name,done):
        if (name is None):
            done()
            return
        self.bindHandler()
        Reflect.callMethod(self.fixture.target,Reflect.field(self.fixture.target,name),[done])

    def tested(self):
        if (self.results.length == 0):
            self.results.add(utest_Assertation.Warning("no assertions"))
        self.onTested.dispatch(self)
        self.completed()

    def timeout(self):
        self.results.add(utest_Assertation.TimeoutError(self.asyncStack.length,[]))
        self.onTimeout.dispatch(self)
        self.completed()

    def completed(self):
        _gthis = self
        if (self.fixture.ignoringInfo is not None):
            self.completedFinally()
            return
        isSync = True
        expectingAsync = True
        def _hx_local_0():
            nonlocal expectingAsync
            if isSync:
                expectingAsync = False
                return
            _gthis.completedFinally()
        complete = _hx_local_0
        try:
            self.executeMethod(self.fixture.teardown)
            self.executeAsyncMethod(self.fixture.teardownAsync,complete)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.results.add(utest_Assertation.TeardownError(e,utest_TestHandler.exceptionStack(2)))
        isSync = False
        if (not expectingAsync):
            self.completedFinally()

    def completedFinally(self):
        self.finished = True
        self.unbindHandler()
        self.onComplete.dispatch(self)

    @staticmethod
    def exceptionStack(pops = None):
        if (pops is None):
            pops = 2
        stack = haxe__CallStack_CallStack_Impl_.exceptionStack()
        while True:
            tmp = pops
            pops = (pops - 1)
            if (not ((tmp > 0))):
                break
            if (len(stack) != 0):
                stack.pop()
        return stack

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.results = None
        _hx_o.fixture = None
        _hx_o.finished = None
        _hx_o.asyncStack = None
        _hx_o.onTested = None
        _hx_o.onTimeout = None
        _hx_o.onComplete = None
        _hx_o.onPrecheck = None
        _hx_o.precheck = None
        _hx_o.wasBound = None
        _hx_o.expiration = None
utest_TestHandler._hx_class = utest_TestHandler


class utest_ITestHandler(utest_TestHandler):
    _hx_class_name = "utest.ITestHandler"
    __slots__ = ("testCase", "test", "setupAsync", "testAsync", "teardownAsync")
    _hx_fields = ["testCase", "test", "setupAsync", "testAsync", "teardownAsync"]
    _hx_methods = ["execute", "runSetup", "checkSetup", "runTest", "checkTest", "runTeardown", "checkTeardown", "bindHandler"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = utest_TestHandler


    def __init__(self,fixture):
        self.teardownAsync = None
        self.testAsync = None
        self.setupAsync = None
        self.test = None
        self.testCase = None
        super().__init__(fixture)
        if (not fixture.isITest):
            raise haxe_Exception.thrown("Invalid fixture type for utest.ITestHandler")
        def _hx_local_1():
            _hx_local_0 = fixture.target
            if (Std.isOfType(_hx_local_0,utest_ITest) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        self.testCase = _hx_local_1()
        self.test = fixture.test
        if (self.test is None):
            raise haxe_Exception.thrown("Fixture is missing test data")

    def execute(self):
        if (self.fixture.ignoringInfo is not None):
            self.executeFinally()
            return
        self.bindHandler()
        self.runSetup()

    def runSetup(self):
        try:
            self.setupAsync = self.fixture.setupMethod()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.results.add(utest_Assertation.SetupError(e,haxe__CallStack_CallStack_Impl_.exceptionStack()))
            self.completedFinally()
            return
        self.setupAsync.then(self.checkSetup)

    def checkSetup(self):
        if self.setupAsync.timedOut:
            self.results.add(utest_Assertation.SetupError("Setup timeout",[]))
            self.completedFinally()
        else:
            self.runTest()

    def runTest(self):
        try:
            self.testAsync = self.test.execute()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.results.add(utest_Assertation.Error(e,haxe__CallStack_CallStack_Impl_.exceptionStack()))
            self.runTeardown()
            return
        self.testAsync.then(self.checkTest)

    def checkTest(self):
        self.onPrecheck.dispatch(self)
        if self.testAsync.timedOut:
            self.results.add(utest_Assertation.TimeoutError(1,[]))
            self.onTimeout.dispatch(self)
        elif self.testAsync.resolved:
            if (self.results.length == 0):
                self.results.add(utest_Assertation.Warning("no assertions"))
            self.onTested.dispatch(self)
        else:
            raise haxe_Exception.thrown("Unexpected test state")
        self.runTeardown()

    def runTeardown(self):
        try:
            self.teardownAsync = self.fixture.teardownMethod()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.results.add(utest_Assertation.TeardownError(e,haxe__CallStack_CallStack_Impl_.exceptionStack()))
            self.completedFinally()
            return
        self.teardownAsync.then(self.checkTeardown)

    def checkTeardown(self):
        if self.teardownAsync.timedOut:
            self.results.add(utest_Assertation.TeardownError("Teardown timeout",[]))
        self.completedFinally()

    def bindHandler(self):
        if self.wasBound:
            return
        utest_Assert.results = self.results
        msg = " is not allowed in tests extending utest.ITest. Add `async:utest.Async` argument to the test method instead."
        def _hx_local_0(f = None,t = None):
            raise haxe_Exception.thrown(("Assert.createAsync() " + ("null" if msg is None else msg)))
        utest_Assert.createAsync = _hx_local_0
        def _hx_local_1(f,t = None):
            raise haxe_Exception.thrown(("Assert.createEvent() " + ("null" if msg is None else msg)))
        utest_Assert.createEvent = _hx_local_1
        self.wasBound = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.testCase = None
        _hx_o.test = None
        _hx_o.setupAsync = None
        _hx_o.testAsync = None
        _hx_o.teardownAsync = None
utest_ITestHandler._hx_class = utest_ITestHandler


class utest__IgnoredFixture_IgnoredFixture_Impl_:
    _hx_class_name = "utest._IgnoredFixture.IgnoredFixture_Impl_"
    __slots__ = ()
    _hx_statics = ["NotIgnored", "Ignored", "_new", "get_isIgnored", "get_ignoreReason"]
    isIgnored = None
    ignoreReason = None

    @staticmethod
    def NotIgnored():
        this1 = None
        return this1

    @staticmethod
    def Ignored(reason = None):
        this1 = (reason if ((reason is not None)) else "")
        return this1

    @staticmethod
    def _new(reason):
        this1 = reason
        return this1

    @staticmethod
    def get_isIgnored(this1):
        return (this1 is not None)

    @staticmethod
    def get_ignoreReason(this1):
        return this1
utest__IgnoredFixture_IgnoredFixture_Impl_._hx_class = utest__IgnoredFixture_IgnoredFixture_Impl_


class utest_Runner:
    _hx_class_name = "utest.Runner"
    __slots__ = ("fixtures", "iTestFixtures", "onProgress", "onStart", "onComplete", "onPrecheck", "onTestStart", "onTestComplete", "length", "globalPattern", "complete", "pos", "executedFixtures")
    _hx_fields = ["fixtures", "iTestFixtures", "onProgress", "onStart", "onComplete", "onPrecheck", "onTestStart", "onTestComplete", "length", "globalPattern", "complete", "pos", "executedFixtures"]
    _hx_methods = ["addCase", "addITest", "addCaseOld", "isTestFixtureName", "addFixture", "getFixture", "isMethod", "run", "waitForCompletion", "runNext", "runFixture", "testComplete"]

    def __init__(self):
        self.executedFixtures = 0
        self.pos = 0
        self.complete = False
        self.globalPattern = None
        self.iTestFixtures = haxe_ds_ObjectMap()
        self.fixtures = []
        self.onProgress = utest_Dispatcher()
        self.onStart = utest_Dispatcher()
        self.onComplete = utest_Dispatcher()
        self.onPrecheck = utest_Dispatcher()
        self.onTestStart = utest_Dispatcher()
        self.onTestComplete = utest_Dispatcher()
        self.length = 0
        envPattern = None
        if (envPattern is not None):
            self.globalPattern = EReg(envPattern,"")

    def addCase(self,test,setup = None,teardown = None,prefix = None,pattern = None,setupAsync = None,teardownAsync = None):
        if (setup is None):
            setup = "setup"
        if (teardown is None):
            teardown = "teardown"
        if (prefix is None):
            prefix = "test"
        if (setupAsync is None):
            setupAsync = "setupAsync"
        if (teardownAsync is None):
            teardownAsync = "teardownAsync"
        if Std.isOfType(test,utest_ITest):
            self.addITest(test,pattern)
        else:
            self.addCaseOld(test,setup,teardown,prefix,pattern,setupAsync,teardownAsync)

    def addITest(self,testCase,pattern):
        if (testCase in self.iTestFixtures.h):
            raise haxe_Exception.thrown("Cannot add the same test twice.")
        fixtures = []
        init = testCase.__initializeUtest__()
        className = Type.getClassName(Type.getClass(testCase))
        _g = 0
        _g1 = init.tests
        while (_g < len(_g1)):
            test = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not self.isTestFixtureName(className,test.name,["test", "spec"],pattern,self.globalPattern)):
                continue
            fixture = utest_TestFixture.ofData(testCase,test,init.accessories)
            self.addFixture(fixture)
            fixtures.append(fixture)
        if (len(fixtures) > 0):
            self.iTestFixtures.set(testCase,_hx_AnonObject({'setupClass': utest_utils_AccessoriesUtils.getSetupClass(init.accessories), 'fixtures': fixtures, 'teardownClass': utest_utils_AccessoriesUtils.getTeardownClass(init.accessories)}))

    def addCaseOld(self,test,setup = None,teardown = None,prefix = None,pattern = None,setupAsync = None,teardownAsync = None):
        if (setup is None):
            setup = "setup"
        if (teardown is None):
            teardown = "teardown"
        if (prefix is None):
            prefix = "test"
        if (setupAsync is None):
            setupAsync = "setupAsync"
        if (teardownAsync is None):
            teardownAsync = "teardownAsync"
        if (not Reflect.isObject(test)):
            raise haxe_Exception.thrown("can't add a null object as a test case")
        if (not self.isMethod(test,setup)):
            setup = None
        if (not self.isMethod(test,setupAsync)):
            setupAsync = None
        if (not self.isMethod(test,teardown)):
            teardown = None
        if (not self.isMethod(test,teardownAsync)):
            teardownAsync = None
        fields = python_Boot.getInstanceFields(Type.getClass(test))
        className = Type.getClassName(Type.getClass(test))
        _g = 0
        while (_g < len(fields)):
            field = (fields[_g] if _g >= 0 and _g < len(fields) else None)
            _g = (_g + 1)
            if (not self.isMethod(test,field)):
                continue
            if (not self.isTestFixtureName(className,field,[prefix],pattern,self.globalPattern)):
                continue
            self.addFixture(utest_TestFixture(test,field,setup,teardown,setupAsync,teardownAsync))

    def isTestFixtureName(self,caseName,testName,prefixes,pattern = None,globalPattern = None):
        if ((pattern is None) and ((globalPattern is None))):
            _g = 0
            while (_g < len(prefixes)):
                prefix = (prefixes[_g] if _g >= 0 and _g < len(prefixes) else None)
                _g = (_g + 1)
                if testName.startswith(prefix):
                    return True
            return False
        if (pattern is None):
            pattern = globalPattern
        pattern.matchObj = python_lib_Re.search(pattern.pattern,((("" + ("null" if caseName is None else caseName)) + ".") + ("null" if testName is None else testName)))
        return (pattern.matchObj is not None)

    def addFixture(self,fixture):
        _this = self.fixtures
        _this.append(fixture)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def getFixture(self,index):
        return (self.fixtures[index] if index >= 0 and index < len(self.fixtures) else None)

    def isMethod(self,test,name):
        try:
            return Reflect.isFunction(Reflect.field(test,name))
        except BaseException as _g:
            None
            return False

    def run(self):
        self.onStart.dispatch(self)
        iTestRunner = utest__Runner_ITestRunner(self)
        iTestRunner.run()
        self.waitForCompletion()

    def waitForCompletion(self):
        if (not self.complete):
            haxe_Timer.delay(self.waitForCompletion,100)

    def runNext(self,finishedHandler = None):
        currentCase = None
        _g = self.pos
        _g1 = len(self.fixtures)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            fixture = python_internal_ArrayImpl._get(self.fixtures, _hx_local_2())
            if fixture.isITest:
                continue
            if (currentCase != fixture.target):
                currentCase = fixture.target
                utest_utils_Print.startCase(Type.getClassName(Type.getClass(currentCase)))
            handler = self.runFixture(fixture)
            if (not handler.finished):
                handler.onComplete.add(self.runNext)
                return
        self.complete = True
        self.onComplete.dispatch(self)

    def runFixture(self,fixture):
        handler = (utest_ITestHandler(fixture) if (fixture.isITest) else utest_TestHandler(fixture))
        handler.onComplete.add(self.testComplete)
        handler.onPrecheck.add(self.onPrecheck.dispatch)
        utest_utils_Print.startTest(fixture.method)
        self.onTestStart.dispatch(handler)
        handler.execute()
        return handler

    def testComplete(self,h):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.executedFixtures
        _hx_local_0.executedFixtures = (_hx_local_1 + 1)
        _hx_local_0.executedFixtures
        self.onTestComplete.dispatch(h)
        self.onProgress.dispatch(_hx_AnonObject({'result': utest_TestResult.ofHandler(h), 'done': self.executedFixtures, 'totals': self.length}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fixtures = None
        _hx_o.iTestFixtures = None
        _hx_o.onProgress = None
        _hx_o.onStart = None
        _hx_o.onComplete = None
        _hx_o.onPrecheck = None
        _hx_o.onTestStart = None
        _hx_o.onTestComplete = None
        _hx_o.length = None
        _hx_o.globalPattern = None
        _hx_o.complete = None
        _hx_o.pos = None
        _hx_o.executedFixtures = None
utest_Runner._hx_class = utest_Runner


class utest__Runner_ITestRunner:
    _hx_class_name = "utest._Runner.ITestRunner"
    __slots__ = ("runner", "cases", "currentCase", "currentCaseFixtures", "teardownClass", "setupAsync", "teardownAsync")
    _hx_fields = ["runner", "cases", "currentCase", "currentCaseFixtures", "teardownClass", "setupAsync", "teardownAsync"]
    _hx_methods = ["run", "runCases", "checkSetup", "setupFailed", "runFixtures", "checkTeardown", "teardownFailed"]

    def __init__(self,runner):
        self.teardownAsync = None
        self.setupAsync = None
        self.teardownClass = None
        self.currentCaseFixtures = None
        self.currentCase = None
        self.cases = None
        self.runner = runner

    def run(self):
        self.cases = self.runner.iTestFixtures.keys()
        self.runCases()

    def runCases(self):
        while self.cases.hasNext():
            self.currentCase = self.cases.next()
            utest_utils_Print.startCase(Type.getClassName(Type.getClass(self.currentCase)))
            data = self.runner.iTestFixtures.h.get(self.currentCase,None)
            self.currentCaseFixtures = data.fixtures
            self.teardownClass = data.teardownClass
            try:
                self.setupAsync = data.setupClass()
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                self.setupFailed(utest_Assertation.SetupError(("setupClass failed: " + Std.string(e)),haxe__CallStack_CallStack_Impl_.exceptionStack()))
                return
            if self.setupAsync.resolved:
                if (not self.runFixtures()):
                    return
            else:
                self.setupAsync.then(self.checkSetup)
                return
        self.runner.runNext()

    def checkSetup(self):
        if self.setupAsync.timedOut:
            self.setupFailed(utest_Assertation.SetupError("setupClass timeout",[]))
        else:
            self.runFixtures()

    def setupFailed(self,assertation):
        _hx_local_0 = self.runner
        _hx_local_1 = _hx_local_0.executedFixtures
        _hx_local_0.executedFixtures = (_hx_local_1 + len(self.currentCaseFixtures))
        _hx_local_0.executedFixtures
        self.runner.onProgress.dispatch(_hx_AnonObject({'totals': self.runner.length, 'result': utest_TestResult.ofFailedSetupClass(self.currentCase,assertation), 'done': self.runner.executedFixtures}))
        self.runCases()

    def runFixtures(self,finishedHandler = None):
        while (len(self.currentCaseFixtures) > 0):
            _this = self.currentCaseFixtures
            handler = self.runner.runFixture((None if ((len(_this) == 0)) else _this.pop()))
            if (not handler.finished):
                handler.onComplete.add(self.runFixtures)
                return False
        try:
            self.teardownAsync = self.teardownClass()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.teardownFailed(utest_Assertation.TeardownError(("teardownClass failed: " + Std.string(e)),haxe__CallStack_CallStack_Impl_.exceptionStack()))
            return True
        if (self.teardownAsync.resolved and ((finishedHandler is None))):
            return True
        self.teardownAsync.then(self.checkTeardown)
        return False

    def checkTeardown(self):
        if self.teardownAsync.timedOut:
            self.teardownFailed(utest_Assertation.TeardownError("teardownClass timeout",[]))
        self.runCases()

    def teardownFailed(self,assertation):
        self.runner.onProgress.dispatch(_hx_AnonObject({'totals': self.runner.length, 'result': utest_TestResult.ofFailedTeardownClass(self.currentCase,assertation), 'done': self.runner.executedFixtures}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.runner = None
        _hx_o.cases = None
        _hx_o.currentCase = None
        _hx_o.currentCaseFixtures = None
        _hx_o.teardownClass = None
        _hx_o.setupAsync = None
        _hx_o.teardownAsync = None
utest__Runner_ITestRunner._hx_class = utest__Runner_ITestRunner


class utest_AccessoryName:
    _hx_class_name = "utest.AccessoryName"
    __slots__ = ()
    _hx_statics = ["SETUP_NAME", "SETUP_CLASS_NAME", "TEARDOWN_NAME", "TEARDOWN_CLASS_NAME"]
utest_AccessoryName._hx_class = utest_AccessoryName


class utest_TestFixture:
    _hx_class_name = "utest.TestFixture"
    __slots__ = ("target", "method", "setup", "setupAsync", "teardown", "teardownAsync", "ignoringInfo", "isITest", "test", "setupMethod", "teardownMethod")
    _hx_fields = ["target", "method", "setup", "setupAsync", "teardown", "teardownAsync", "ignoringInfo", "isITest", "test", "setupMethod", "teardownMethod"]
    _hx_methods = ["checkMethod", "getIgnored"]
    _hx_statics = ["ofData"]

    def __init__(self,target,method,setup = None,teardown = None,setupAsync = None,teardownAsync = None):
        self.teardownMethod = None
        self.setupMethod = None
        self.test = None
        self.ignoringInfo = None
        self.isITest = False
        self.target = target
        self.method = method
        self.setup = setup
        self.setupAsync = setupAsync
        self.teardown = teardown
        self.teardownAsync = teardownAsync
        self.ignoringInfo = self.getIgnored()

    def checkMethod(self,name,arg):
        field = Reflect.field(self.target,name)
        if (field is None):
            raise haxe_Exception.thrown((((("null" if arg is None else arg) + " function ") + ("null" if name is None else name)) + " is not a field of target"))
        if (not Reflect.isFunction(field)):
            raise haxe_Exception.thrown((((("null" if arg is None else arg) + " function ") + ("null" if name is None else name)) + " is not a function"))

    def getIgnored(self):
        metas = haxe_rtti_Meta.getFields(Type.getClass(self.target))
        metasForTestMetas = Reflect.getProperty(metas,self.method)
        if ((metasForTestMetas is None) or (not python_Boot.hasField(metasForTestMetas,"Ignored"))):
            return utest__IgnoredFixture_IgnoredFixture_Impl_.NotIgnored()
        ignoredArgs = Reflect.getProperty(metasForTestMetas,"Ignored")
        if (((ignoredArgs is None) or ((len(ignoredArgs) == 0))) or (((ignoredArgs[0] if 0 < len(ignoredArgs) else None) is None))):
            return utest__IgnoredFixture_IgnoredFixture_Impl_.Ignored()
        ignoredReason = Std.string((ignoredArgs[0] if 0 < len(ignoredArgs) else None))
        return utest__IgnoredFixture_IgnoredFixture_Impl_.Ignored(ignoredReason)

    @staticmethod
    def ofData(target,test,accessories):
        fixture = utest_TestFixture(target,test.name)
        fixture.isITest = True
        fixture.test = test
        fixture.setupMethod = utest_utils_AccessoriesUtils.getSetup(accessories)
        fixture.teardownMethod = utest_utils_AccessoriesUtils.getTeardown(accessories)
        return fixture

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.target = None
        _hx_o.method = None
        _hx_o.setup = None
        _hx_o.setupAsync = None
        _hx_o.teardown = None
        _hx_o.teardownAsync = None
        _hx_o.ignoringInfo = None
        _hx_o.isITest = None
        _hx_o.test = None
        _hx_o.setupMethod = None
        _hx_o.teardownMethod = None
utest_TestFixture._hx_class = utest_TestFixture


class utest_TestResult:
    _hx_class_name = "utest.TestResult"
    __slots__ = ("pack", "cls", "method", "setup", "setupAsync", "teardown", "teardownAsync", "assertations")
    _hx_fields = ["pack", "cls", "method", "setup", "setupAsync", "teardown", "teardownAsync", "assertations"]
    _hx_methods = ["allOk"]
    _hx_statics = ["ofHandler", "ofFailedSetupClass", "ofFailedTeardownClass"]

    def __init__(self):
        self.assertations = None
        self.teardownAsync = None
        self.teardown = None
        self.setupAsync = None
        self.setup = None
        self.method = None
        self.cls = None
        self.pack = None

    def allOk(self):
        _g_head = self.assertations.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            l = val
            if (l.index == 0):
                _g = l.params[0]
                break
            else:
                return False
        return True

    @staticmethod
    def ofHandler(handler):
        r = utest_TestResult()
        _this = Type.getClassName(Type.getClass(handler.fixture.target))
        path = _this.split(".")
        r.cls = (None if ((len(path) == 0)) else path.pop())
        r.pack = ".".join([python_Boot.toString1(x1,'') for x1 in path])
        r.method = handler.fixture.method
        r.setup = handler.fixture.setup
        r.setupAsync = handler.fixture.setupAsync
        r.teardown = handler.fixture.teardown
        r.teardownAsync = handler.fixture.teardownAsync
        r.assertations = handler.results
        return r

    @staticmethod
    def ofFailedSetupClass(testCase,assertation):
        r = utest_TestResult()
        _this = Type.getClassName(Type.getClass(testCase))
        path = _this.split(".")
        r.cls = (None if ((len(path) == 0)) else path.pop())
        r.pack = ".".join([python_Boot.toString1(x1,'') for x1 in path])
        r.method = "setup"
        r.assertations = haxe_ds_List()
        r.assertations.add(assertation)
        return r

    @staticmethod
    def ofFailedTeardownClass(testCase,assertation):
        r = utest_TestResult()
        _this = Type.getClassName(Type.getClass(testCase))
        path = _this.split(".")
        r.cls = (None if ((len(path) == 0)) else path.pop())
        r.pack = ".".join([python_Boot.toString1(x1,'') for x1 in path])
        r.method = "setup"
        r.assertations = haxe_ds_List()
        r.assertations.add(assertation)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pack = None
        _hx_o.cls = None
        _hx_o.method = None
        _hx_o.setup = None
        _hx_o.setupAsync = None
        _hx_o.teardown = None
        _hx_o.teardownAsync = None
        _hx_o.assertations = None
utest_TestResult._hx_class = utest_TestResult


class utest_ui_common_ClassResult:
    _hx_class_name = "utest.ui.common.ClassResult"
    __slots__ = ("fixtures", "className", "setupName", "teardownName", "hasSetup", "hasTeardown", "methods", "stats")
    _hx_fields = ["fixtures", "className", "setupName", "teardownName", "hasSetup", "hasTeardown", "methods", "stats"]
    _hx_methods = ["add", "get", "exists", "methodNames"]

    def __init__(self,className,setupName,teardownName):
        self.fixtures = haxe_ds_StringMap()
        self.className = className
        self.setupName = setupName
        self.hasSetup = (setupName is not None)
        self.teardownName = teardownName
        self.hasTeardown = (teardownName is not None)
        self.methods = 0
        self.stats = utest_ui_common_ResultStats()

    def add(self,result):
        if (result.methodName in self.fixtures.h):
            raise haxe_Exception.thrown(((("invalid duplicated fixture: " + HxOverrides.stringOrNull(self.className)) + ".") + HxOverrides.stringOrNull(result.methodName)))
        self.stats.wire(result.stats)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.methods
        _hx_local_0.methods = (_hx_local_1 + 1)
        _hx_local_1
        self.fixtures.h[result.methodName] = result

    def get(self,method):
        return self.fixtures.h.get(method,None)

    def exists(self,method):
        return (method in self.fixtures.h)

    def methodNames(self,errorsHavePriority = None):
        if (errorsHavePriority is None):
            errorsHavePriority = True
        names = []
        name = self.fixtures.keys()
        while name.hasNext():
            name1 = name.next()
            names.append(name1)
        if errorsHavePriority:
            me = self
            def _hx_local_0(a,b):
                _hx_as = me.get(a).stats
                bs = me.get(b).stats
                if _hx_as.hasErrors:
                    if (not bs.hasErrors):
                        return -1
                    elif (_hx_as.errors == bs.errors):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.errors,bs.errors)
                elif bs.hasErrors:
                    return 1
                elif _hx_as.hasFailures:
                    if (not bs.hasFailures):
                        return -1
                    elif (_hx_as.failures == bs.failures):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.failures,bs.failures)
                elif bs.hasFailures:
                    return 1
                elif _hx_as.hasWarnings:
                    if (not bs.hasWarnings):
                        return -1
                    elif (_hx_as.warnings == bs.warnings):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.warnings,bs.warnings)
                elif bs.hasWarnings:
                    return 1
                else:
                    return Reflect.compare(a,b)
            names.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        else:
            def _hx_local_1(a,b):
                return Reflect.compare(a,b)
            names.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        return names

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fixtures = None
        _hx_o.className = None
        _hx_o.setupName = None
        _hx_o.teardownName = None
        _hx_o.hasSetup = None
        _hx_o.hasTeardown = None
        _hx_o.methods = None
        _hx_o.stats = None
utest_ui_common_ClassResult._hx_class = utest_ui_common_ClassResult


class utest_ui_common_FixtureResult:
    _hx_class_name = "utest.ui.common.FixtureResult"
    __slots__ = ("methodName", "hasTestError", "hasSetupError", "hasTeardownError", "hasTimeoutError", "hasAsyncError", "stats", "list")
    _hx_fields = ["methodName", "hasTestError", "hasSetupError", "hasTeardownError", "hasTimeoutError", "hasAsyncError", "stats", "list"]
    _hx_methods = ["iterator", "add"]

    def __init__(self,methodName):
        self.methodName = methodName
        self.list = haxe_ds_List()
        self.hasTestError = False
        self.hasSetupError = False
        self.hasTeardownError = False
        self.hasTimeoutError = False
        self.hasAsyncError = False
        self.stats = utest_ui_common_ResultStats()

    def iterator(self):
        return haxe_ds__List_ListIterator(self.list.h)

    def add(self,assertation):
        self.list.add(assertation)
        tmp = assertation.index
        if (tmp == 0):
            _g = assertation.params[0]
            self.stats.addSuccesses(1)
        elif (tmp == 1):
            _g = assertation.params[1]
            _g = assertation.params[0]
            self.stats.addFailures(1)
        elif (tmp == 2):
            _g = assertation.params[1]
            _g = assertation.params[0]
            self.stats.addErrors(1)
        elif (tmp == 3):
            _g = assertation.params[1]
            _g = assertation.params[0]
            self.stats.addErrors(1)
            self.hasSetupError = True
        elif (tmp == 4):
            _g = assertation.params[1]
            _g = assertation.params[0]
            self.stats.addErrors(1)
            self.hasTeardownError = True
        elif (tmp == 5):
            _g = assertation.params[1]
            _g = assertation.params[0]
            self.stats.addErrors(1)
            self.hasTimeoutError = True
        elif (tmp == 6):
            _g = assertation.params[1]
            _g = assertation.params[0]
            self.stats.addErrors(1)
            self.hasAsyncError = True
        elif (tmp == 7):
            _g = assertation.params[0]
            self.stats.addWarnings(1)
        elif (tmp == 8):
            _g = assertation.params[0]
            self.stats.addIgnores(1)
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.methodName = None
        _hx_o.hasTestError = None
        _hx_o.hasSetupError = None
        _hx_o.hasTeardownError = None
        _hx_o.hasTimeoutError = None
        _hx_o.hasAsyncError = None
        _hx_o.stats = None
        _hx_o.list = None
utest_ui_common_FixtureResult._hx_class = utest_ui_common_FixtureResult

class utest_ui_common_HeaderDisplayMode(Enum):
    __slots__ = ()
    _hx_class_name = "utest.ui.common.HeaderDisplayMode"
    _hx_constructs = ["AlwaysShowHeader", "NeverShowHeader", "ShowHeaderWithResults"]
utest_ui_common_HeaderDisplayMode.AlwaysShowHeader = utest_ui_common_HeaderDisplayMode("AlwaysShowHeader", 0, ())
utest_ui_common_HeaderDisplayMode.NeverShowHeader = utest_ui_common_HeaderDisplayMode("NeverShowHeader", 1, ())
utest_ui_common_HeaderDisplayMode.ShowHeaderWithResults = utest_ui_common_HeaderDisplayMode("ShowHeaderWithResults", 2, ())
utest_ui_common_HeaderDisplayMode._hx_class = utest_ui_common_HeaderDisplayMode

class utest_ui_common_SuccessResultsDisplayMode(Enum):
    __slots__ = ()
    _hx_class_name = "utest.ui.common.SuccessResultsDisplayMode"
    _hx_constructs = ["AlwaysShowSuccessResults", "NeverShowSuccessResults", "ShowSuccessResultsWithNoErrors"]
utest_ui_common_SuccessResultsDisplayMode.AlwaysShowSuccessResults = utest_ui_common_SuccessResultsDisplayMode("AlwaysShowSuccessResults", 0, ())
utest_ui_common_SuccessResultsDisplayMode.NeverShowSuccessResults = utest_ui_common_SuccessResultsDisplayMode("NeverShowSuccessResults", 1, ())
utest_ui_common_SuccessResultsDisplayMode.ShowSuccessResultsWithNoErrors = utest_ui_common_SuccessResultsDisplayMode("ShowSuccessResultsWithNoErrors", 2, ())
utest_ui_common_SuccessResultsDisplayMode._hx_class = utest_ui_common_SuccessResultsDisplayMode


class utest_ui_common_PackageResult:
    _hx_class_name = "utest.ui.common.PackageResult"
    __slots__ = ("packageName", "isEmpty", "classes", "packages", "stats")
    _hx_fields = ["packageName", "isEmpty", "classes", "packages", "stats"]
    _hx_methods = ["addResult", "addClass", "addPackage", "existsPackage", "existsClass", "getPackage", "getClass", "classNames", "packageNames", "createFixture", "getOrCreateClass", "getOrCreatePackage"]

    def __init__(self,packageName):
        self.isEmpty = True
        self.packageName = packageName
        self.classes = haxe_ds_StringMap()
        self.packages = haxe_ds_StringMap()
        self.stats = utest_ui_common_ResultStats()

    def addResult(self,result,flattenPackage):
        self.isEmpty = False
        pack = self.getOrCreatePackage(result.pack,flattenPackage,self)
        cls = self.getOrCreateClass(pack,result.cls,result.setup,result.teardown)
        fix = self.createFixture(result.method,result.assertations)
        cls.add(fix)

    def addClass(self,result):
        self.isEmpty = False
        self.classes.h[result.className] = result
        self.stats.wire(result.stats)

    def addPackage(self,result):
        self.isEmpty = False
        self.packages.h[result.packageName] = result
        self.stats.wire(result.stats)

    def existsPackage(self,name):
        return (name in self.packages.h)

    def existsClass(self,name):
        return (name in self.classes.h)

    def getPackage(self,name):
        if ((self.packageName is None) and ((name == ""))):
            return self
        return self.packages.h.get(name,None)

    def getClass(self,name):
        return self.classes.h.get(name,None)

    def classNames(self,errorsHavePriority = None):
        if (errorsHavePriority is None):
            errorsHavePriority = True
        names = []
        name = self.classes.keys()
        while name.hasNext():
            name1 = name.next()
            names.append(name1)
        if errorsHavePriority:
            me = self
            def _hx_local_0(a,b):
                _hx_as = me.getClass(a).stats
                bs = me.getClass(b).stats
                if _hx_as.hasErrors:
                    if (not bs.hasErrors):
                        return -1
                    elif (_hx_as.errors == bs.errors):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.errors,bs.errors)
                elif bs.hasErrors:
                    return 1
                elif _hx_as.hasFailures:
                    if (not bs.hasFailures):
                        return -1
                    elif (_hx_as.failures == bs.failures):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.failures,bs.failures)
                elif bs.hasFailures:
                    return 1
                elif _hx_as.hasWarnings:
                    if (not bs.hasWarnings):
                        return -1
                    elif (_hx_as.warnings == bs.warnings):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.warnings,bs.warnings)
                elif bs.hasWarnings:
                    return 1
                else:
                    return Reflect.compare(a,b)
            names.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        else:
            def _hx_local_1(a,b):
                return Reflect.compare(a,b)
            names.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        return names

    def packageNames(self,errorsHavePriority = None):
        if (errorsHavePriority is None):
            errorsHavePriority = True
        names = []
        if (self.packageName is None):
            names.append("")
        name = self.packages.keys()
        while name.hasNext():
            name1 = name.next()
            names.append(name1)
        if errorsHavePriority:
            me = self
            def _hx_local_0(a,b):
                _hx_as = me.getPackage(a).stats
                bs = me.getPackage(b).stats
                if _hx_as.hasErrors:
                    if (not bs.hasErrors):
                        return -1
                    elif (_hx_as.errors == bs.errors):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.errors,bs.errors)
                elif bs.hasErrors:
                    return 1
                elif _hx_as.hasFailures:
                    if (not bs.hasFailures):
                        return -1
                    elif (_hx_as.failures == bs.failures):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.failures,bs.failures)
                elif bs.hasFailures:
                    return 1
                elif _hx_as.hasWarnings:
                    if (not bs.hasWarnings):
                        return -1
                    elif (_hx_as.warnings == bs.warnings):
                        return Reflect.compare(a,b)
                    else:
                        return Reflect.compare(_hx_as.warnings,bs.warnings)
                elif bs.hasWarnings:
                    return 1
                else:
                    return Reflect.compare(a,b)
            names.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        else:
            def _hx_local_1(a,b):
                return Reflect.compare(a,b)
            names.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        return names

    def createFixture(self,method,assertations):
        f = utest_ui_common_FixtureResult(method)
        assertation = HxOverrides.iterator(assertations)
        while assertation.hasNext():
            assertation1 = assertation.next()
            f.add(assertation1)
        return f

    def getOrCreateClass(self,pack,cls,setup,teardown):
        if pack.existsClass(cls):
            return pack.getClass(cls)
        c = utest_ui_common_ClassResult(cls,setup,teardown)
        pack.addClass(c)
        return c

    def getOrCreatePackage(self,pack,flat,ref):
        if ((pack is None) or ((pack == ""))):
            return ref
        if flat:
            if ref.existsPackage(pack):
                return ref.getPackage(pack)
            p = utest_ui_common_PackageResult(pack)
            ref.addPackage(p)
            return p
        else:
            parts = pack.split(".")
            _g = 0
            while (_g < len(parts)):
                part = (parts[_g] if _g >= 0 and _g < len(parts) else None)
                _g = (_g + 1)
                ref = self.getOrCreatePackage(part,True,ref)
            return ref

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.packageName = None
        _hx_o.isEmpty = None
        _hx_o.classes = None
        _hx_o.packages = None
        _hx_o.stats = None
utest_ui_common_PackageResult._hx_class = utest_ui_common_PackageResult


class utest_ui_common_ReportTools:
    _hx_class_name = "utest.ui.common.ReportTools"
    __slots__ = ()
    _hx_statics = ["hasHeader", "skipResult", "hasOutput"]

    @staticmethod
    def hasHeader(report,stats):
        tmp = report.displayHeader.index
        if (tmp == 0):
            return True
        elif (tmp == 1):
            return False
        elif (tmp == 2):
            if (not stats.isOk):
                return True
            tmp = report.displaySuccessResults.index
            if (tmp == 1):
                return False
            elif ((tmp == 2) or ((tmp == 0))):
                return True
            else:
                pass
        else:
            pass

    @staticmethod
    def skipResult(report,stats,isOk):
        if (not stats.isOk):
            return False
        tmp = report.displaySuccessResults.index
        if (tmp == 0):
            return False
        elif (tmp == 1):
            return True
        elif (tmp == 2):
            return (not isOk)
        else:
            pass

    @staticmethod
    def hasOutput(report,stats):
        if (not stats.isOk):
            return True
        return utest_ui_common_ReportTools.hasHeader(report,stats)
utest_ui_common_ReportTools._hx_class = utest_ui_common_ReportTools


class utest_ui_common_ResultAggregator:
    _hx_class_name = "utest.ui.common.ResultAggregator"
    __slots__ = ("runner", "flattenPackage", "root", "onStart", "onComplete", "onProgress")
    _hx_fields = ["runner", "flattenPackage", "root", "onStart", "onComplete", "onProgress"]
    _hx_methods = ["start", "checkNonITest", "getOrCreatePackage", "getOrCreateClass", "createFixture", "progress", "complete", "createNoTestsResult"]

    def __init__(self,runner,flattenPackage = None):
        if (flattenPackage is None):
            flattenPackage = False
        self.onProgress = None
        self.onComplete = None
        self.onStart = None
        self.root = None
        if (runner is None):
            raise haxe_Exception.thrown("runner argument is null")
        self.flattenPackage = flattenPackage
        self.runner = runner
        runner.onStart.add(self.start)
        runner.onProgress.add(self.progress)
        runner.onComplete.add(self.complete)
        self.onStart = utest_Notifier()
        self.onComplete = utest_Dispatcher()
        self.onProgress = utest_Dispatcher()

    def start(self,runner):
        self.checkNonITest()
        self.root = utest_ui_common_PackageResult(None)
        self.onStart.dispatch()

    def checkNonITest(self):
        first = None
        total = 0
        _g = 0
        _g1 = self.runner.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            fixture = self.runner.getFixture(i)
            if (not fixture.isITest):
                total = (total + 1)
                if (first is None):
                    first = Type.getClassName(Type.getClass(fixture.target))
        if (total > 0):
            baseMsg = "implement utest.ITest. Non-ITest tests are deprecated. Implement utest.ITest or extend utest.Test."
            msg = None
            total1 = total
            if (total1 == 1):
                msg = ((("" + ("null" if first is None else first)) + " doesn't ") + ("null" if baseMsg is None else baseMsg))
            elif (total1 == 2):
                msg = ((("" + ("null" if first is None else first)) + " and 1 other don't ") + ("null" if baseMsg is None else baseMsg))
            else:
                msg = ((((("" + ("null" if first is None else first)) + " and ") + Std.string(total)) + " others don't ") + ("null" if baseMsg is None else baseMsg))
            haxe_Log.trace(msg,_hx_AnonObject({'fileName': "utest/ui/common/ResultAggregator.hx", 'lineNumber': 54, 'className': "utest.ui.common.ResultAggregator", 'methodName': "checkNonITest"}))

    def getOrCreatePackage(self,pack,flat,ref = None):
        if (ref is None):
            ref = self.root
        if ((pack is None) or ((pack == ""))):
            return ref
        if flat:
            if ref.existsPackage(pack):
                return ref.getPackage(pack)
            p = utest_ui_common_PackageResult(pack)
            ref.addPackage(p)
            return p
        else:
            parts = pack.split(".")
            _g = 0
            while (_g < len(parts)):
                part = (parts[_g] if _g >= 0 and _g < len(parts) else None)
                _g = (_g + 1)
                ref = self.getOrCreatePackage(part,True,ref)
            return ref

    def getOrCreateClass(self,pack,cls,setup,teardown):
        if pack.existsClass(cls):
            return pack.getClass(cls)
        c = utest_ui_common_ClassResult(cls,setup,teardown)
        pack.addClass(c)
        return c

    def createFixture(self,result):
        f = utest_ui_common_FixtureResult(result.method)
        _g_head = result.assertations.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            assertation = val
            f.add(assertation)
        return f

    def progress(self,e):
        self.root.addResult(e.result,self.flattenPackage)
        self.onProgress.dispatch(e)

    def complete(self,runner):
        if self.root.isEmpty:
            self.root.addResult(self.createNoTestsResult(),False)
        self.onComplete.dispatch(self.root)

    def createNoTestsResult(self):
        result = utest_TestResult()
        result.pack = ""
        result.cls = ""
        result.method = ""
        result.assertations = haxe_ds_List()
        pos = _hx_AnonObject({'fileName': "", 'lineNumber': 1, 'className': "utest.Runner", 'methodName': "run"})
        result.assertations.add(utest_Assertation.Failure("No tests executed.",pos))
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.runner = None
        _hx_o.flattenPackage = None
        _hx_o.root = None
        _hx_o.onStart = None
        _hx_o.onComplete = None
        _hx_o.onProgress = None
utest_ui_common_ResultAggregator._hx_class = utest_ui_common_ResultAggregator


class utest_ui_common_ResultStats:
    _hx_class_name = "utest.ui.common.ResultStats"
    __slots__ = ("assertations", "successes", "failures", "errors", "warnings", "ignores", "onAddSuccesses", "onAddFailures", "onAddErrors", "onAddWarnings", "onAddIgnores", "isOk", "hasFailures", "hasErrors", "hasWarnings", "hasIgnores")
    _hx_fields = ["assertations", "successes", "failures", "errors", "warnings", "ignores", "onAddSuccesses", "onAddFailures", "onAddErrors", "onAddWarnings", "onAddIgnores", "isOk", "hasFailures", "hasErrors", "hasWarnings", "hasIgnores"]
    _hx_methods = ["addSuccesses", "addFailures", "addErrors", "addIgnores", "addWarnings", "sum", "subtract", "wire", "unwire"]

    def __init__(self):
        self.assertations = 0
        self.successes = 0
        self.failures = 0
        self.errors = 0
        self.warnings = 0
        self.ignores = 0
        self.isOk = True
        self.hasFailures = False
        self.hasErrors = False
        self.hasWarnings = False
        self.hasIgnores = False
        self.onAddSuccesses = utest_Dispatcher()
        self.onAddFailures = utest_Dispatcher()
        self.onAddErrors = utest_Dispatcher()
        self.onAddWarnings = utest_Dispatcher()
        self.onAddIgnores = utest_Dispatcher()

    def addSuccesses(self,v):
        if (v == 0):
            return
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.assertations
        _hx_local_0.assertations = (_hx_local_1 + v)
        _hx_local_0.assertations
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.successes
        _hx_local_2.successes = (_hx_local_3 + v)
        _hx_local_2.successes
        self.onAddSuccesses.dispatch(v)

    def addFailures(self,v):
        if (v == 0):
            return
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.assertations
        _hx_local_0.assertations = (_hx_local_1 + v)
        _hx_local_0.assertations
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.failures
        _hx_local_2.failures = (_hx_local_3 + v)
        _hx_local_2.failures
        self.hasFailures = (self.failures > 0)
        self.isOk = (not (((self.hasFailures or self.hasErrors) or self.hasWarnings)))
        self.onAddFailures.dispatch(v)

    def addErrors(self,v):
        if (v == 0):
            return
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.assertations
        _hx_local_0.assertations = (_hx_local_1 + v)
        _hx_local_0.assertations
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.errors
        _hx_local_2.errors = (_hx_local_3 + v)
        _hx_local_2.errors
        self.hasErrors = (self.errors > 0)
        self.isOk = (not (((self.hasFailures or self.hasErrors) or self.hasWarnings)))
        self.onAddErrors.dispatch(v)

    def addIgnores(self,v):
        if (v == 0):
            return
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.assertations
        _hx_local_0.assertations = (_hx_local_1 + v)
        _hx_local_0.assertations
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ignores
        _hx_local_2.ignores = (_hx_local_3 + v)
        _hx_local_2.ignores
        self.hasIgnores = (self.ignores > 0)
        self.onAddIgnores.dispatch(v)

    def addWarnings(self,v):
        if (v == 0):
            return
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.assertations
        _hx_local_0.assertations = (_hx_local_1 + v)
        _hx_local_0.assertations
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.warnings
        _hx_local_2.warnings = (_hx_local_3 + v)
        _hx_local_2.warnings
        self.hasWarnings = (self.warnings > 0)
        self.isOk = (not (((self.hasFailures or self.hasErrors) or self.hasWarnings)))
        self.onAddWarnings.dispatch(v)

    def sum(self,other):
        self.addSuccesses(other.successes)
        self.addFailures(other.failures)
        self.addErrors(other.errors)
        self.addWarnings(other.warnings)
        self.addIgnores(other.ignores)

    def subtract(self,other):
        self.addSuccesses(-other.successes)
        self.addFailures(-other.failures)
        self.addErrors(-other.errors)
        self.addWarnings(-other.warnings)
        self.addIgnores(-other.ignores)

    def wire(self,dependant):
        dependant.onAddSuccesses.add(self.addSuccesses)
        dependant.onAddFailures.add(self.addFailures)
        dependant.onAddErrors.add(self.addErrors)
        dependant.onAddWarnings.add(self.addWarnings)
        dependant.onAddIgnores.add(self.addIgnores)
        self.sum(dependant)

    def unwire(self,dependant):
        dependant.onAddSuccesses.remove(self.addSuccesses)
        dependant.onAddFailures.remove(self.addFailures)
        dependant.onAddErrors.remove(self.addErrors)
        dependant.onAddWarnings.remove(self.addWarnings)
        dependant.onAddIgnores.remove(self.addIgnores)
        self.subtract(dependant)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.assertations = None
        _hx_o.successes = None
        _hx_o.failures = None
        _hx_o.errors = None
        _hx_o.warnings = None
        _hx_o.ignores = None
        _hx_o.onAddSuccesses = None
        _hx_o.onAddFailures = None
        _hx_o.onAddErrors = None
        _hx_o.onAddWarnings = None
        _hx_o.onAddIgnores = None
        _hx_o.isOk = None
        _hx_o.hasFailures = None
        _hx_o.hasErrors = None
        _hx_o.hasWarnings = None
        _hx_o.hasIgnores = None
utest_ui_common_ResultStats._hx_class = utest_ui_common_ResultStats


class utest_utils_AccessoriesUtils:
    _hx_class_name = "utest.utils.AccessoriesUtils"
    __slots__ = ()
    _hx_statics = ["getSetupClass", "getSetup", "getTeardown", "getTeardownClass"]

    @staticmethod
    def getSetupClass(accessories):
        if (Reflect.field(accessories,"setupClass") is None):
            return utest_Async.getResolved
        else:
            return Reflect.field(accessories,"setupClass")

    @staticmethod
    def getSetup(accessories):
        if (Reflect.field(accessories,"setup") is None):
            return utest_Async.getResolved
        else:
            return Reflect.field(accessories,"setup")

    @staticmethod
    def getTeardown(accessories):
        if (Reflect.field(accessories,"teardown") is None):
            return utest_Async.getResolved
        else:
            return Reflect.field(accessories,"teardown")

    @staticmethod
    def getTeardownClass(accessories):
        if (Reflect.field(accessories,"teardownClass") is None):
            return utest_Async.getResolved
        else:
            return Reflect.field(accessories,"teardownClass")
utest_utils_AccessoriesUtils._hx_class = utest_utils_AccessoriesUtils


class utest_utils_AsyncUtils:
    _hx_class_name = "utest.utils.AsyncUtils"
    __slots__ = ()
    _hx_statics = ["orResolved"]

    @staticmethod
    def orResolved(_async):
        if (_async is None):
            return utest_Async.getResolved()
        else:
            return _async
utest_utils_AsyncUtils._hx_class = utest_utils_AsyncUtils


class utest_utils_Misc:
    _hx_class_name = "utest.utils.Misc"
    __slots__ = ()
    _hx_statics = ["isOfType"]

    @staticmethod
    def isOfType(v,t):
        return Std.isOfType(v,t)
utest_utils_Misc._hx_class = utest_utils_Misc


class utest_utils_Print:
    _hx_class_name = "utest.utils.Print"
    __slots__ = ()
    _hx_statics = ["immediately", "startCase", "startTest"]

    @staticmethod
    def immediately(msg):
        python_Lib.printString(Std.string(msg))

    @staticmethod
    def startCase(caseName):
        pass

    @staticmethod
    def startTest(name):
        pass
utest_utils_Print._hx_class = utest_utils_Print


class uuid_Uuid:
    _hx_class_name = "uuid.Uuid"
    __slots__ = ()
    _hx_statics = ["DNS", "URL", "ISO_OID", "X500_DN", "NIL", "LOWERCASE_BASE26", "UPPERCASE_BASE26", "NO_LOOK_ALIKES_BASE51", "FLICKR_BASE58", "BASE_70", "COOKIE_BASE90", "NANO_ID_ALPHABET", "NUMBERS_BIN", "NUMBERS_OCT", "NUMBERS_DEC", "NUMBERS_HEX", "lastMSecs", "lastNSecs", "clockSequenceBuffer", "regexp", "rndSeed", "state0", "state1", "splitmix64_seed", "randomFromRange", "randomByte", "fromShort", "toShort", "fromNano", "toNano", "v1", "v3", "v4", "v5", "stringify", "parse", "validate", "version", "hexToUuid", "convert", "nanoId", "short"]

    @staticmethod
    def splitmix64_seed(index):
        a_high = (index >> 31)
        a_low = index
        b_high = -1640531527
        b_low = 2135587861
        high = (((a_high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a_low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a_low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        result = this1
        b = 30
        b = (b & 63)
        b1 = None
        if (b == 0):
            this1 = haxe__Int64____Int64(result.high,result.low)
            b1 = this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(((((result.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((result.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(result.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        else:
            this1 = haxe__Int64____Int64(((((result.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        a_high = ((((result.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low = ((((result.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b_high = -1084733587
        b_low = 484763065
        mask = 65535
        al = (a_low & mask)
        ah = HxOverrides.rshift(a_low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a_low,b_high) + haxe__Int32_Int32_Impl_.mul(a_high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        result = this1
        b = 27
        b = (b & 63)
        b1 = None
        if (b == 0):
            this1 = haxe__Int64____Int64(result.high,result.low)
            b1 = this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(((((result.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((result.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(result.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        else:
            this1 = haxe__Int64____Int64(((((result.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        a_high = ((((result.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low = ((((result.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b_high = -1798288965
        b_low = 321982955
        mask = 65535
        al = (a_low & mask)
        ah = HxOverrides.rshift(a_low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a_low,b_high) + haxe__Int32_Int32_Impl_.mul(a_high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        result = this1
        b = 31
        b = (b & 63)
        b1 = None
        if (b == 0):
            this1 = haxe__Int64____Int64(result.high,result.low)
            b1 = this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(((((result.high >> b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((((((result.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(result.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        else:
            this1 = haxe__Int64____Int64(((((result.high >> 31)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.high >> ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        this1 = haxe__Int64____Int64(((((result.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((result.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        return this1

    @staticmethod
    def randomFromRange(_hx_min,_hx_max):
        s1 = uuid_Uuid.state0
        s0 = uuid_Uuid.state1
        uuid_Uuid.state0 = s0
        b = 23
        b = (b & 63)
        b1 = None
        if (b == 0):
            this1 = haxe__Int64____Int64(s1.high,s1.low)
            b1 = this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(((((((((s1.high << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(s1.low, ((32 - b))))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((s1.low << b)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        else:
            this1 = haxe__Int64____Int64(((((s1.low << ((b - 32)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),0)
            b1 = this1
        this1 = haxe__Int64____Int64(((((s1.high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((s1.low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        s1 = this1
        a_high = ((((s1.high ^ s0.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low = ((((s1.low ^ s0.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b = 18
        b = (b & 63)
        b1 = None
        if (b == 0):
            this1 = haxe__Int64____Int64(s1.high,s1.low)
            b1 = this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(HxOverrides.rshift(s1.high, b),((((((((s1.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(s1.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        else:
            this1 = haxe__Int64____Int64(0,HxOverrides.rshift(s1.high, ((b - 32))))
            b1 = this1
        a_high1 = ((((a_high ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_low1 = ((((a_low ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        b = 5
        b = (b & 63)
        b1 = None
        if (b == 0):
            this1 = haxe__Int64____Int64(s0.high,s0.low)
            b1 = this1
        elif (b < 32):
            this1 = haxe__Int64____Int64(HxOverrides.rshift(s0.high, b),((((((((s0.high << ((32 - b)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) | HxOverrides.rshift(s0.low, b))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
            b1 = this1
        else:
            this1 = haxe__Int64____Int64(0,HxOverrides.rshift(s0.high, ((b - 32))))
            b1 = this1
        this1 = haxe__Int64____Int64(((((a_high1 ^ b1.high)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)),((((a_low1 ^ b1.low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))
        uuid_Uuid.state1 = this1
        a = uuid_Uuid.state1
        high = (((a.high + s0.high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a.low + s0.low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a.low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        x = ((_hx_max - _hx_min) + 1)
        this2 = haxe__Int64____Int64((x >> 31),x)
        result = haxe__Int64_Int64_Impl_.divMod(this1,this2).modulus.low
        if (result < 0):
            result = -result
        return (result + _hx_min)

    @staticmethod
    def randomByte():
        return uuid_Uuid.randomFromRange(0,255)

    @staticmethod
    def fromShort(shortUuid,separator = None,fromAlphabet = None):
        if (separator is None):
            separator = "-"
        if (fromAlphabet is None):
            fromAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        uuid = uuid_Uuid.convert(shortUuid,fromAlphabet,"0123456789abcdef")
        return uuid_Uuid.hexToUuid(uuid,separator)

    @staticmethod
    def toShort(uuid,separator = None,toAlphabet = None):
        if (separator is None):
            separator = "-"
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        uuid = StringTools.replace(uuid,separator,"").lower()
        return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet)

    @staticmethod
    def fromNano(nanoUuid,separator = None,fromAlphabet = None):
        if (separator is None):
            separator = "-"
        if (fromAlphabet is None):
            fromAlphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        uuid = uuid_Uuid.convert(nanoUuid,fromAlphabet,"0123456789abcdef")
        return uuid_Uuid.hexToUuid(uuid,separator)

    @staticmethod
    def toNano(uuid,separator = None,toAlphabet = None):
        if (separator is None):
            separator = "-"
        if (toAlphabet is None):
            toAlphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        uuid = StringTools.replace(uuid,separator,"").lower()
        return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet)

    @staticmethod
    def v1(node = None,optClockSequence = None,msecs = None,optNsecs = None,randomFunc = None,separator = None,shortUuid = None,toAlphabet = None):
        if (optClockSequence is None):
            optClockSequence = -1
        if (msecs is None):
            msecs = -1
        if (optNsecs is None):
            optNsecs = -1
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        if (randomFunc is None):
            randomFunc = uuid_Uuid.randomByte
        buffer = haxe_io_Bytes.alloc(16)
        if (node is None):
            node = haxe_io_Bytes.alloc(6)
            v = randomFunc()
            node.b[0] = (v & 255)
            v = randomFunc()
            node.b[1] = (v & 255)
            v = randomFunc()
            node.b[2] = (v & 255)
            v = randomFunc()
            node.b[3] = (v & 255)
            v = randomFunc()
            node.b[4] = (v & 255)
            v = randomFunc()
            node.b[5] = (v & 255)
            v = (node.b[0] | 1)
            node.b[0] = (v & 255)
        if (uuid_Uuid.clockSequenceBuffer == -1):
            uuid_Uuid.clockSequenceBuffer = ((((randomFunc() << 8) | randomFunc())) & 16383)
        clockSeq = optClockSequence
        if (optClockSequence == -1):
            clockSeq = uuid_Uuid.clockSequenceBuffer
        if (msecs == -1):
            msecs = python_lib_Timeit.default_timer()
        nsecs = optNsecs
        if (optNsecs == -1):
            nsecs = (uuid_Uuid.lastNSecs + 1)
        dt = ((msecs - uuid_Uuid.lastMSecs) + ((((nsecs - uuid_Uuid.lastNSecs)) / 10000)))
        if ((dt < 0) and ((optClockSequence == -1))):
            clockSeq = ((clockSeq + 1) & 16383)
        if ((((dt < 0) or ((msecs > uuid_Uuid.lastMSecs)))) and ((optNsecs == -1))):
            nsecs = 0
        if (nsecs >= 10000):
            raise haxe_Exception.thrown("Can't create more than 10M uuids/sec")
        uuid_Uuid.lastMSecs = msecs
        uuid_Uuid.lastNSecs = nsecs
        uuid_Uuid.clockSequenceBuffer = clockSeq
        msecs = (msecs + 12219292800000)
        this1 = haxe__Int64____Int64(1,0)
        dvs = this1
        a = haxe_Int64Helper.fromFloat(msecs)
        b_high = 0
        b_low = 268435455
        a_high = (a.high & b_high)
        a_low = (a.low & b_low)
        b_high = 0
        b_low = 10000
        mask = 65535
        al = (a_low & mask)
        ah = HxOverrides.rshift(a_low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a_low,b_high) + haxe__Int32_Int32_Impl_.mul(a_high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_high = high
        a_low = low
        b_high = (nsecs >> 31)
        b_low = nsecs
        high = (((a_high + b_high) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((a_low + b_low) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,a_low) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        this1 = haxe__Int64____Int64(high,low)
        tl = haxe__Int64_Int64_Impl_.divMod(this1,dvs).modulus.low
        buffer.b[0] = ((HxOverrides.rshift(tl, 24) & 255) & 255)
        buffer.b[1] = ((HxOverrides.rshift(tl, 16) & 255) & 255)
        buffer.b[2] = ((HxOverrides.rshift(tl, 8) & 255) & 255)
        buffer.b[3] = ((tl & 255) & 255)
        a = haxe__Int64_Int64_Impl_.divMod(haxe_Int64Helper.fromFloat(msecs),dvs).quotient
        b_high = 0
        b_low = 10000
        mask = 65535
        al = (a.low & mask)
        ah = HxOverrides.rshift(a.low, 16)
        bl = (b_low & mask)
        bh = HxOverrides.rshift(b_low, 16)
        p00 = haxe__Int32_Int32_Impl_.mul(al,bl)
        p10 = haxe__Int32_Int32_Impl_.mul(ah,bl)
        p01 = haxe__Int32_Int32_Impl_.mul(al,bh)
        p11 = haxe__Int32_Int32_Impl_.mul(ah,bh)
        low = p00
        high = ((((((p11 + (HxOverrides.rshift(p01, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (HxOverrides.rshift(p10, 16))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p01 = ((((p01 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p01) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p01) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        p10 = ((((p10 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        low = (((low + p10) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        if (haxe__Int32_Int32_Impl_.ucompare(low,p10) < 0):
            ret = high
            high = (high + 1)
            high = ((high + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        high = (((high + ((((haxe__Int32_Int32_Impl_.mul(a.low,b_high) + haxe__Int32_Int32_Impl_.mul(a.high,b_low)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
        a_high = high
        a_low = low
        b_high = 0
        b_low = 268435455
        this_high = (a_high & b_high)
        this_low = (a_low & b_low)
        tmh = this_low
        buffer.b[4] = ((HxOverrides.rshift(tmh, 8) & 255) & 255)
        buffer.b[5] = ((tmh & 255) & 255)
        buffer.b[6] = ((((HxOverrides.rshift(tmh, 24) & 15) | 16)) & 255)
        buffer.b[7] = ((HxOverrides.rshift(tmh, 16) & 255) & 255)
        buffer.b[8] = (((HxOverrides.rshift(clockSeq, 8) | 128)) & 255)
        buffer.b[9] = ((clockSeq & 255) & 255)
        v = node.b[0]
        buffer.b[10] = (v & 255)
        v = node.b[1]
        buffer.b[11] = (v & 255)
        v = node.b[2]
        buffer.b[12] = (v & 255)
        v = node.b[3]
        buffer.b[13] = (v & 255)
        v = node.b[4]
        buffer.b[14] = (v & 255)
        v = node.b[5]
        buffer.b[15] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def v3(name,namespace = None,separator = None,shortUuid = None,toAlphabet = None):
        if (namespace is None):
            namespace = ""
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        namespace = StringTools.replace(namespace,"-","")
        buffer = haxe_crypto_Md5.make(haxe_io_Bytes.ofHex((("null" if namespace is None else namespace) + HxOverrides.stringOrNull(haxe_io_Bytes.ofString(name).toHex()))))
        v = ((buffer.b[6] & 15) | 48)
        buffer.b[6] = (v & 255)
        v = ((buffer.b[8] & 63) | 128)
        buffer.b[8] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def v4(randBytes = None,randomFunc = None,separator = None,shortUuid = None,toAlphabet = None):
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        if (randomFunc is None):
            randomFunc = uuid_Uuid.randomByte
        buffer = randBytes
        if (buffer is None):
            buffer = haxe_io_Bytes.alloc(16)
            v = randomFunc()
            buffer.b[0] = (v & 255)
            v = randomFunc()
            buffer.b[1] = (v & 255)
            v = randomFunc()
            buffer.b[2] = (v & 255)
            v = randomFunc()
            buffer.b[3] = (v & 255)
            v = randomFunc()
            buffer.b[4] = (v & 255)
            v = randomFunc()
            buffer.b[5] = (v & 255)
            v = randomFunc()
            buffer.b[6] = (v & 255)
            v = randomFunc()
            buffer.b[7] = (v & 255)
            v = randomFunc()
            buffer.b[8] = (v & 255)
            v = randomFunc()
            buffer.b[9] = (v & 255)
            v = randomFunc()
            buffer.b[10] = (v & 255)
            v = randomFunc()
            buffer.b[11] = (v & 255)
            v = randomFunc()
            buffer.b[12] = (v & 255)
            v = randomFunc()
            buffer.b[13] = (v & 255)
            v = randomFunc()
            buffer.b[14] = (v & 255)
            v = randomFunc()
            buffer.b[15] = (v & 255)
        elif (buffer.length < 16):
            raise haxe_Exception.thrown("Random bytes should be at least 16 bytes")
        v = ((buffer.b[6] & 15) | 64)
        buffer.b[6] = (v & 255)
        v = ((buffer.b[8] & 63) | 128)
        buffer.b[8] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def v5(name,namespace = None,separator = None,shortUuid = None,toAlphabet = None):
        if (namespace is None):
            namespace = ""
        if (separator is None):
            separator = "-"
        if (shortUuid is None):
            shortUuid = False
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        namespace = StringTools.replace(namespace,"-","")
        buffer = haxe_crypto_Sha1.make(haxe_io_Bytes.ofHex((("null" if namespace is None else namespace) + HxOverrides.stringOrNull(haxe_io_Bytes.ofString(name).toHex()))))
        v = ((buffer.b[6] & 15) | 80)
        buffer.b[6] = (v & 255)
        v = ((buffer.b[8] & 63) | 128)
        buffer.b[8] = (v & 255)
        uuid = uuid_Uuid.stringify(buffer,separator)
        if shortUuid:
            uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet)
        return uuid

    @staticmethod
    def stringify(data,separator = None):
        if (separator is None):
            separator = "-"
        return uuid_Uuid.hexToUuid(data.toHex(),separator)

    @staticmethod
    def parse(uuid,separator = None):
        if (separator is None):
            separator = "-"
        return haxe_io_Bytes.ofHex(StringTools.replace(uuid,separator,""))

    @staticmethod
    def validate(uuid,separator = None):
        if (separator is None):
            separator = "-"
        if (separator == ""):
            uuid = ((((((((HxOverrides.stringOrNull(HxString.substr(uuid,0,8)) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,8,4))) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,12,4))) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,16,4))) + "-") + HxOverrides.stringOrNull(HxString.substr(uuid,20,12)))
        elif (separator != "-"):
            uuid = StringTools.replace(uuid,separator,"-")
        _this = uuid_Uuid.regexp
        _this.matchObj = python_lib_Re.search(_this.pattern,uuid)
        return (_this.matchObj is not None)

    @staticmethod
    def version(uuid,separator = None):
        if (separator is None):
            separator = "-"
        uuid = StringTools.replace(uuid,separator,"")
        return Std.parseInt(("0x" + HxOverrides.stringOrNull(HxString.substr(uuid,12,1))))

    @staticmethod
    def hexToUuid(hex,separator):
        return ((((((((HxOverrides.stringOrNull(HxString.substr(hex,0,8)) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,8,4))) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,12,4))) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,16,4))) + ("null" if separator is None else separator)) + HxOverrides.stringOrNull(HxString.substr(hex,20,12)))

    @staticmethod
    def convert(number,fromAlphabet,toAlphabet):
        fromBase = len(fromAlphabet)
        toBase = len(toAlphabet)
        _hx_len = len(number)
        buf = ""
        this1 = [None]*_hx_len
        numberMap = this1
        divide = 0
        newlen = 0
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_str = ("" if (((i < 0) or ((i >= len(number))))) else number[i])
            startIndex = None
            val = (fromAlphabet.find(_hx_str) if ((startIndex is None)) else HxString.indexOfImpl(fromAlphabet,_hx_str,startIndex))
            numberMap[i] = val
        while True:
            divide = 0
            newlen = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                divide = ((divide * fromBase) + numberMap[i])
                if (divide >= toBase):
                    index = newlen
                    newlen = (newlen + 1)
                    val = Math.floor((divide / toBase))
                    numberMap[index] = val
                    divide = HxOverrides.mod(divide, toBase)
                elif (newlen > 0):
                    index1 = newlen
                    newlen = (newlen + 1)
                    numberMap[index1] = 0
            _hx_len = newlen
            buf = (HxOverrides.stringOrNull((("" if (((divide < 0) or ((divide >= len(toAlphabet))))) else toAlphabet[divide]))) + ("null" if buf is None else buf))
            if (not ((newlen != 0))):
                break
        return buf

    @staticmethod
    def nanoId(_hx_len = None,alphabet = None,randomFunc = None):
        if (_hx_len is None):
            _hx_len = 21
        if (alphabet is None):
            alphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        if (randomFunc is None):
            randomFunc = uuid_Uuid.randomByte
        if (alphabet is None):
            raise haxe_Exception.thrown("Alphabet cannot be null")
        if ((len(alphabet) == 0) or ((len(alphabet) >= 256))):
            raise haxe_Exception.thrown("Alphabet must contain between 1 and 255 symbols")
        if (_hx_len <= 0):
            raise haxe_Exception.thrown("Length must be greater than zero")
        v = (len(alphabet) - 1)
        mask = (((2 << Math.floor((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(2))))) - 1)
        step = Math.ceil((((1.6 * mask) * _hx_len) / len(alphabet)))
        sb = StringBuf()
        while (sb.get_length() != _hx_len):
            _g = 0
            _g1 = step
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                rnd = randomFunc()
                aIndex = (rnd & mask)
                if (aIndex < len(alphabet)):
                    s = Std.string(("" if (((aIndex < 0) or ((aIndex >= len(alphabet))))) else alphabet[aIndex]))
                    sb.b.write(s)
                    if (sb.get_length() == _hx_len):
                        break
        return sb.b.getvalue()

    @staticmethod
    def short(toAlphabet = None,randomFunc = None):
        if (toAlphabet is None):
            toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        return uuid_Uuid.v4(None,randomFunc,None,True,toAlphabet)
uuid_Uuid._hx_class = uuid_Uuid

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
hiss_HStream._dummyCount = 0
hiss_HStream._WHITESPACE = [" ", "\n", "\t"]
hiss_HissTestCase.functionsTested = haxe_ds_StringMap()
hiss_HissTestCase.printTestCommands = True
hiss_HissTestCase.reallyTrace = None
hiss_HissTestCase.tempTrace = None
hiss_SpecialForms._ccNum = 0
hiss_StaticFiles.files = haxe_ds_StringMap()
hiss_StaticFiles.groups = haxe_ds_StringMap()
hiss_Stdlib._recursivePrintDepth = 100
hiss_Stdlib.toPrint_doc = "Convert values to strings for REPL printing"
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
def _hx_init_hiss_VariadicFunctions_lesser_cc():
    def _hx_local_0():
        _hx_type = hiss_Comparison.Lesser
        def _hx_local_1(interp,args,env,cc):
            hiss_VariadicFunctions._numCompare(_hx_type,interp,args,env,cc)
        return _hx_local_1
    return _hx_local_0()
hiss_VariadicFunctions.lesser_cc = _hx_init_hiss_VariadicFunctions_lesser_cc()
def _hx_init_hiss_VariadicFunctions_lesserEqual_cc():
    def _hx_local_0():
        _hx_type = hiss_Comparison.LesserEqual
        def _hx_local_1(interp,args,env,cc):
            hiss_VariadicFunctions._numCompare(_hx_type,interp,args,env,cc)
        return _hx_local_1
    return _hx_local_0()
hiss_VariadicFunctions.lesserEqual_cc = _hx_init_hiss_VariadicFunctions_lesserEqual_cc()
def _hx_init_hiss_VariadicFunctions_greater_cc():
    def _hx_local_0():
        _hx_type = hiss_Comparison.Greater
        def _hx_local_1(interp,args,env,cc):
            hiss_VariadicFunctions._numCompare(_hx_type,interp,args,env,cc)
        return _hx_local_1
    return _hx_local_0()
hiss_VariadicFunctions.greater_cc = _hx_init_hiss_VariadicFunctions_greater_cc()
def _hx_init_hiss_VariadicFunctions_greaterEqual_cc():
    def _hx_local_0():
        _hx_type = hiss_Comparison.GreaterEqual
        def _hx_local_1(interp,args,env,cc):
            hiss_VariadicFunctions._numCompare(_hx_type,interp,args,env,cc)
        return _hx_local_1
    return _hx_local_0()
hiss_VariadicFunctions.greaterEqual_cc = _hx_init_hiss_VariadicFunctions_greaterEqual_cc()
def _hx_init_hiss_VariadicFunctions_equal_cc():
    def _hx_local_0():
        _hx_type = hiss_Comparison.Equal
        def _hx_local_1(interp,args,env,cc):
            hiss_VariadicFunctions._numCompare(_hx_type,interp,args,env,cc)
        return _hx_local_1
    return _hx_local_0()
hiss_VariadicFunctions.equal_cc = _hx_init_hiss_VariadicFunctions_equal_cc()
hiss_wrappers_HStringTools.startsWith = StringTools.startsWith
hiss_wrappers_HStringTools.endsWith = StringTools.endsWith
hiss_wrappers_HStringTools.lpad = StringTools.lpad
hiss_wrappers_HStringTools.rpad = StringTools.rpad
hiss_wrappers_HStringTools.trim = StringTools.trim
hiss_wrappers_HStringTools.ltrim = StringTools.ltrim
hiss_wrappers_HStringTools.rtrim = StringTools.rtrim
hiss_wrappers_HStringTools.replace = StringTools.replace
hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER = hx_strings__Char_CharCaseMapper()
hx_strings__Char_Char_Impl_.BACKSPACE = 8
hx_strings__Char_Char_Impl_.TAB = 9
hx_strings__Char_Char_Impl_.LF = 10
hx_strings__Char_Char_Impl_.CR = 13
hx_strings__Char_Char_Impl_.ESC = 27
hx_strings__Char_Char_Impl_.SPACE = 32
hx_strings__Char_Char_Impl_.EXCLAMATION_MARK = 33
hx_strings__Char_Char_Impl_.DOUBLE_QUOTE = 34
hx_strings__Char_Char_Impl_.HASH = 35
hx_strings__Char_Char_Impl_.DOLLAR = 36
hx_strings__Char_Char_Impl_.AMPERSAND = 38
hx_strings__Char_Char_Impl_.SINGLE_QUOTE = 39
hx_strings__Char_Char_Impl_.BRACKET_ROUND_LEFT = 40
hx_strings__Char_Char_Impl_.BRACKET_ROUND_RIGHT = 41
hx_strings__Char_Char_Impl_.ASTERISK = 42
hx_strings__Char_Char_Impl_.PLUS = 43
hx_strings__Char_Char_Impl_.COMMA = 44
hx_strings__Char_Char_Impl_.MINUS = 45
hx_strings__Char_Char_Impl_.DOT = 46
hx_strings__Char_Char_Impl_.SLASH = 47
hx_strings__Char_Char_Impl_.ZERO = 48
hx_strings__Char_Char_Impl_.ONE = 49
hx_strings__Char_Char_Impl_.TWO = 50
hx_strings__Char_Char_Impl_.TRHEE = 51
hx_strings__Char_Char_Impl_.FOUR = 52
hx_strings__Char_Char_Impl_.FIVE = 53
hx_strings__Char_Char_Impl_.SIX = 54
hx_strings__Char_Char_Impl_.SEVEN = 55
hx_strings__Char_Char_Impl_.EIGHT = 56
hx_strings__Char_Char_Impl_.NINE = 57
hx_strings__Char_Char_Impl_.COLON = 58
hx_strings__Char_Char_Impl_.SEMICOLON = 59
hx_strings__Char_Char_Impl_.LOWER_THAN = 60
hx_strings__Char_Char_Impl_.EQUALS = 61
hx_strings__Char_Char_Impl_.GREATER_THAN = 62
hx_strings__Char_Char_Impl_.QUESTION_MARK = 63
hx_strings__Char_Char_Impl_.BRACKET_SQUARE_LEFT = 91
hx_strings__Char_Char_Impl_.BACKSLASH = 92
hx_strings__Char_Char_Impl_.BRACKET_SQUARE_RIGHT = 93
hx_strings__Char_Char_Impl_.CARET = 94
hx_strings__Char_Char_Impl_.UNDERSCORE = 95
hx_strings__Char_Char_Impl_.BRACKET_CURLY_LEFT = 123
hx_strings__Char_Char_Impl_.PIPE = 124
hx_strings__Char_Char_Impl_.BRACKET_CURLY_RIGHT = 125
hx_strings__CharIterator_NullCharIterator.INSTANCE = hx_strings__CharIterator_NullCharIterator()
hx_strings_Pattern.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'immutable': None, 'threadSafe': None})})
hx_strings_Matcher.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'notThreadSafe': None})})
def _hx_init_hx_strings_internal_OS_isWindows():
    def _hx_local_0():
        os = Sys.systemName()
        _this = EReg("win","i")
        _this.matchObj = python_lib_Re.search(_this.pattern,os)
        return (_this.matchObj is not None)
    return _hx_local_0()
hx_strings_internal_OS.isWindows = _hx_init_hx_strings_internal_OS_isWindows()
def _hx_init_hx_strings_Strings_REGEX_ANSI_ESC():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile((HxOverrides.stringOrNull("".join(map(chr,[27]))) + "\\[[;\\d]*m"),this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_ANSI_ESC = _hx_init_hx_strings_Strings_REGEX_ANSI_ESC()
def _hx_init_hx_strings_Strings_REGEX_HTML_UNESCAPE():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile("&(#\\d+|amp|nbsp|apos|lt|gt|quot);",this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_HTML_UNESCAPE = _hx_init_hx_strings_Strings_REGEX_HTML_UNESCAPE()
def _hx_init_hx_strings_Strings_REGEX_SPLIT_LINES():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile("\\r?\\n",this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_SPLIT_LINES = _hx_init_hx_strings_Strings_REGEX_SPLIT_LINES()
def _hx_init_hx_strings_Strings_REGEX_REMOVE_XML_TAGS():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile("<[!a-zA-Z\\/][^>]*>",this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_REMOVE_XML_TAGS = _hx_init_hx_strings_Strings_REGEX_REMOVE_XML_TAGS()
hx_strings_Strings.POS_NOT_FOUND = -1
hx_strings_Strings.NEW_LINE_NIX = "\n"
hx_strings_Strings.NEW_LINE_WIN = "\r\n"
hx_strings_Strings.NEW_LINE = ("\r\n" if (hx_strings_internal_OS.isWindows) else "\n")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
sys_Http.PROXY = None
utest_TestHandler.POLLING_TIME = 10
utest_AccessoryName.SETUP_NAME = "setup"
utest_AccessoryName.SETUP_CLASS_NAME = "setupClass"
utest_AccessoryName.TEARDOWN_NAME = "teardown"
utest_AccessoryName.TEARDOWN_CLASS_NAME = "teardownClass"
uuid_Uuid.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.ISO_OID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.X500_DN = "6ba7b814-9dad-11d1-80b4-00c04fd430c8"
uuid_Uuid.NIL = "00000000-0000-0000-0000-000000000000"
uuid_Uuid.LOWERCASE_BASE26 = "abcdefghijklmnopqrstuvwxyz"
uuid_Uuid.UPPERCASE_BASE26 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
uuid_Uuid.NO_LOOK_ALIKES_BASE51 = "2346789ABCDEFGHJKLMNPQRTUVWXYZabcdefghijkmnpqrtwxyz"
uuid_Uuid.FLICKR_BASE58 = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
uuid_Uuid.BASE_70 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+!@#$^"
uuid_Uuid.COOKIE_BASE90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~"
uuid_Uuid.NANO_ID_ALPHABET = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
uuid_Uuid.NUMBERS_BIN = "01"
uuid_Uuid.NUMBERS_OCT = "01234567"
uuid_Uuid.NUMBERS_DEC = "0123456789"
uuid_Uuid.NUMBERS_HEX = "0123456789abcdef"
uuid_Uuid.lastMSecs = 0
uuid_Uuid.lastNSecs = 0
uuid_Uuid.clockSequenceBuffer = -1
uuid_Uuid.regexp = EReg("^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$","i")
def _hx_init_uuid_Uuid_rndSeed():
    def _hx_local_0():
        x = (python_lib_Timeit.default_timer() * 1000)
        def _hx_local_4():
            def _hx_local_2():
                _hx_local_1 = None
                def _hx_local_3():
                    None
                    return None
                try:
                    _hx_local_1 = int(x)
                except BaseException as _g:
                    _hx_local_1 = _hx_local_3()
                return _hx_local_1
            return _hx_local_2()
        return _hx_local_4()
    return _hx_local_0()
uuid_Uuid.rndSeed = _hx_init_uuid_Uuid_rndSeed()
uuid_Uuid.state0 = uuid_Uuid.splitmix64_seed(uuid_Uuid.rndSeed)
uuid_Uuid.state1 = uuid_Uuid.splitmix64_seed((uuid_Uuid.rndSeed + 1))

Main.main()
haxe_EntryPoint.run()
