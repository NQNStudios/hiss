(defun load-intcode (input-num)
    (let ((file (+ "aoc/input" input-num ".txt"))
        (codes (map (split (getContent file) ",") parseInt)))
        (setq program codes)))

(defun execute (input-num &optional noun verb)
    (load-intcode input-num)
    (setq counter 0)
    (setq running t)
    (if noun (set-nth program 1 noun))
    (if verb (set-nth program 2 verb))
    (while running (step)))

(setq instructions '(
    ; (code num-args body...)
    ; body can reference args by index with (get-arg (nth args n)) or (set-arg (nth args n) value) forms
    '(99 0 (
        ;(print (+ "Intcode program exited with code " (nth program 0)))
        (setq running nil)))
    '(1 3 ((set-arg (nth args 2) (+ (get-arg (nth args 0)) (get-arg (nth args 1))))))
    '(2 3 ((set-arg (nth args 2) (* (get-arg (nth args 0)) (get-arg (nth args 1))))))
    '(3 1 ((set-arg (nth args 0) (parseInt (read-line "Enter an integer: ")))))
    '(4 1 ((print (get-arg (nth args 0)))))
    '(5 2 ((if (not (= (get-arg (nth args 0)) 0)) 
        (progn (setq counter (get-arg (nth args 1)))
                ;(print "jumping on true")
                )
        ;(print "not jumping -- was false")
        )))
    '(6 2 ((if (= (get-arg (nth args 0)) 0) 
        (progn (setq counter (get-arg (nth args 1)))
                ;(print "jumping on false")
                )
        ;(print "not jumping -- was true")
        )))
    '(7 3 ((set-arg (nth args 2) 
        (if (< 
                (get-arg (nth args 0))
                (get-arg (nth args 1)))
            1 0))))
    '(8 3 ((set-arg (nth args 2) 
        (if (= 
                (get-arg (nth args 0))
                (get-arg (nth args 1)))
            1 0))))
    ))

(defun step () (intcode-process (nth program counter)))

(defun address (addr) `(& ,addr))

(defun get-arg (arg)
    (if (list? arg)
        (nth program (nth arg 1))
        arg))

(defun set-arg (arg value)
    (if (list? arg)
        (set-nth program (nth arg 1) value)))

(defun intcode-process (instruction)
    (let ((inst-str (string instruction))
            (len (length inst-str))
            (current-opcode (parseInt (substr inst-str (- len 2) 2)))
            (arg-modes (for i (range (- len 2)) (parseInt (charAt inst-str (- (- len 2) 1 i))))))
        ;(print arg-modes)
        (for definition instructions
            (let ((opcode (nth definition 0))
                    (num-args (nth definition 1))
                    (body (nth definition 2)))
                (if (= opcode current-opcode)
                    (progn 
                        ; (print (+ "running opcode " opcode))
                        ; pad arg modes with default 0
                        (for i (range (- num-args (length arg-modes)))
                            (push arg-modes 0))
                        ; (print arg-modes)
                        (let
                                ((args (for i (range num-args)
                                    ; (print i)
                                    (if (= 1 (nth arg-modes i)) 
                                        (nth program (+ counter 1 i))
                                        (address (nth program (+ counter 1 i)))))))
                            ;(print opcode)
                            ;(print "args are")
                            ;(print args)
                            (setq old-counter counter) ; track if we jumped
                            (eval
                                ;(print
                                    (cons 'progn body)
                                    ;)
                                )
                            (if (= old-counter counter) 
                                (setq counter (+ counter 1 num-args))
                                ;(print "not stepping -- a jump happened")
                                ))))))
        nil)) ; don't return a list of the opcode tests
