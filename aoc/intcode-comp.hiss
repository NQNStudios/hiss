(defun load-intcode (input-num)
    (let (file (+ "aoc/input" input-num ".txt")
            codes (map (split (get-content file) ",") parse-int))
        (setq program codes)))

(defun execute (input-num &optional noun verb prompt-for-step)
    (load-intcode input-num)
    (setq counter 0)
    (setq running t)
    (if noun (set-nth program 1 noun))
    (if verb (set-nth program 2 verb))
    (while running 
        (when prompt-for-step 
            (print program)
            (read-line))
        (step))
    (if (= input-num 2) (print (nth program 0))))

(defun number-first-binop (list)
    (if (int? (nth list 1))
        list
        (swap-nth list 1 2)))

(defun combine-like-operators (equation)
    ;(print equation)
    ;(print (list? equation))
    (if (and (list? equation) (list? (nth equation 2)))
        (let (inner-equation (nth equation 2)
                function1 (nth equation 0)
                function2 (nth inner-equation 0)
                operand1 (nth equation 1)
                operand2 (nth inner-equation 1))
            ;(print function1)
            ;(print function2)
            ;(print operand1)
            ;(print operand2)
            (if (and (eq function1 function2) (int? operand1) (int? operand2))
                (combine-like-operators (progn
                    (set-nth equation 1 (eval `(,function1 ,operand1 ,operand2)))
                    (set-nth equation 2 (combine-like-operators (nth inner-equation 2)))))
                `(,function1 ,(combine-like-operators operand1) ,(combine-like-operators inner-equation))
                ;(print equation)
                ))
        (if (list? equation)
            `(,(first equation) ,(combine-like-operators (nth equation 1)) ,(combine-like-operators (nth equation 2)))
            equation)
        ))

(defun distribute-multiplication (equation)
    (print equation)
    (if (and 
            (list? equation)
            (= (length equation) 3)
            (eq (nth equation 0) '*) 
            (list? (nth equation 2)) 
            (eq (nth (nth equation 2) 0) '+)
            (int? (nth equation 1)))
        (let (inner-equation (nth equation 2)
                scale (nth equation 1)
                operand1 (nth inner-equation 1)
                operand2 (nth inner-equation 2))
            `(+ 
                ,(if (int? operand1)
                    (eval '(* scale operand1))
                    operand1)
                ,(if (or (list? operand2) (symbol? operand2))
                    `(* ,scale ,operand2)
                    (eval '(* scale operand2)))))
        equation))

(setq instructions '(
    ; (code num-args body...)
    ; body can reference args by index with (get-arg (nth args n)) or (set-arg (nth args n) value) forms
    (99 0 (
        ;(print (+ "Intcode program exited with code " (nth program 0)))
        (setq running nil)))
    (1 3 ((set-arg (nth args 2) 
        (if (and (int? (get-arg (nth args 0))) (int? (get-arg (nth args 1))))
            ; Non-symbolic eval for all other puzzles
            (+ (get-arg (nth args 0)) (get-arg (nth args 1)))
            ; Symbolic eval for puzzle 2.2
            (distribute-multiplication (number-first-binop `(+ ,(get-arg (nth args 0)) ,(get-arg (nth args 1)))))))))
    (2 3 ((set-arg (nth args 2) 
        (if (and (int? (get-arg (nth args 0))) (int? (get-arg (nth args 1))))
            ; Non-symbolic eval for all other puzzles
            (* (get-arg (nth args 0)) (get-arg (nth args 1)))
            ; Symbolic eval for puzzle 2.2
            (distribute-multiplication (number-first-binop `(* ,(get-arg (nth args 0)) ,(get-arg (nth args 1)))))))))
    (3 1 ((set-arg (nth args 0) 
        (let (input (read-line "Enter an integer: "))
                (or (parse-int input) (intern input))))))
    (4 1 ((print (get-arg (nth args 0)))))
    (5 2 ((if (not (= (get-arg (nth args 0)) 0)) 
        (progn (setq counter (get-arg (nth args 1)))
                ;(print "jumping on true")
                )
        ;(print "not jumping -- was false")
        )))
    (6 2 ((if (= (get-arg (nth args 0)) 0) 
        (progn (setq counter (get-arg (nth args 1)))
                ;(print "jumping on false")
                )
        ;(print "not jumping -- was true")
        )))
    (7 3 ((set-arg (nth args 2) 
        (if (< 
                (get-arg (nth args 0))
                (get-arg (nth args 1)))
            1 0))))
    (8 3 ((set-arg (nth args 2) 
        (if (= 
                (get-arg (nth args 0))
                (get-arg (nth args 1)))
            1 0))))))

(defun step () (intcode-process (nth program counter)))

(defun address (addr) `(& ,addr))

(defun get-arg (arg)
    ;(print "get-arg called")
    (if (list? arg)
        (if (symbol? (nth arg 1))
            arg
            (nth program (nth arg 1)))
        arg))

(defun set-arg (arg value)
    ;(print "setting")
    ;(print arg)
    ;(pring value)
    (if (list? arg)
        (set-nth program (nth arg 1) value)))

(defun intcode-process (instruction)
    (let (inst-str (string instruction)
            len (length inst-str)
            current-opcode (parse-int (substr inst-str (- len 2) 2))
            arg-modes (for i (range (- len 2)) (parse-int (char-at inst-str (- (- len 2) 1 i)))))
        ;(print arg-modes)
        (do-for definition instructions
            (let (opcode (nth definition 0)
                    num-args (nth definition 1)
                    body (nth definition 2))
                (if (= opcode current-opcode)
                    (progn 
                        ; (print (+ "running opcode " opcode))
                        ; pad arg modes with default 0
                        (for i (range (- num-args (length arg-modes)))
                            (push arg-modes 0))
                        ; (print arg-modes)
                        (let
                                (args (for i (range num-args)
                                    ; (print i)
                                    (if (= 1 (nth arg-modes i)) 
                                        (nth program (+ counter 1 i))
                                        (address (nth program (+ counter 1 i))))))
                            ;(print opcode)
                            ;(print "args are")
                            ;(print args)
                            (setq old-counter counter) ; track if we jumped
                            (eval
                                ;(print
                                    (cons 'progn body)
                                    ;)
                                )
                            (if (= old-counter counter) 
                                (setq counter (+ counter 1 num-args))
                                ;(print "not stepping -- a jump happened")
                                ))))))))
