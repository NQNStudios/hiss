(message "Testing Hiss standard library for version $(version)")

(test or
    // Test with booleans:
    (eq nil (or))
    (eq t (or t))
    (eq t (or nil t))
    (eq nil (or nil nil))

    // Test with other values:
    (eq 5 (or nil 5))
    (eq nil (or nil (> 5 6)))
    (or (> 6 5) (> 5 6))
    (or (> 5 6) (> 6 5))

    // Test short-circuiting:
    (setlocal short-circuit t)
    (eq t (or t (setlocal short-circuit nil)))
    short-circuit

    // Test against stack overflows:
    (eq t (or nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil t)))

(test and
    // Test with booleans:
    (eq t (and))
    (eq t (and t))
    (eq nil (and nil t))
    (eq nil (and t nil))

    // Test with other values:
    (eq 5 (and 6 5))
    (eq nil (and t (> 5 6)))
    (eq nil (and (> 6 5) (> 5 6)))
    (eq nil (and (> 5 6) (> 6 5)))
    (eq t (and (> 6 5) (> 7 5)))

    // Test short-circuiting:
    (setlocal short-circuit t)
    (eq nil (and nil (setlocal short-circuit nil)))
    short-circuit

    // Test against stack overflows:
    (eq t (and t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t)))

(test pop
    (eq 4 (pop (list 1 2 3 4)))
    (eq nil (pop (list))) // TODO is this desirable?
    (setlocal l (list 1 2 3 4))
    (eq 4 (pop l))
    (eq (list 1 2 3) l)
    (eq 3 (pop l)))

(test for
    (eq (list 7 8 9) (for i (list 1 2 3) (+ i 6))))

(test do-for
    (not (do-for i (list 1 2 3) i))
    (prints "1\n2\n3\n" (do-for i (list 1 2 3) (print i))))

(test map
    (eq (list 7 8 9) (map (list 1 2 3) (lambda (i) (+ i 6)))))

(test do-map
    (not (do-map (list 1 2 3) (lambda (i) i)))
    (prints "1\n2\n3\n" (do-map (list 1 2 3) print)))

(test bind
    (setlocal my-print (bind print "hello"))
    (prints "hello\n" (my-print))
    (setlocal offset (bind + 6))
    (= 11 (offset 5))
    ; test binding macro/special form
    (setlocal false (bind and nil))
    (not (false t)))

// For now, Python-style generators are not fully supported.
// yield just returns a value and sets the global `continue`
// to the continuation.
(test yield
    (defun range (max)
        (setlocal count 0)
        (while (< count max)
            (yield count)
            (setlocal count (+ 1 count))))
    (= 0 (range 2))
    (= 1 (continue))
    (eq nil (continue))
    (= 0 (range 3))
    (= 1 (continue))
    (= 2 (continue)))