(message "Testing Hiss standard library for version $(version)")

(test or
    // Test with booleans:
    (eq nil (or))
    (eq t (or t))
    (eq t (or nil t))
    (eq nil (or nil nil))

    // Test with other values:
    (eq 5 (or nil 5))
    (eq nil (or nil (> 5 6)))
    (or (> 6 5) (> 5 6))
    (or (> 5 6) (> 6 5))

    // Test short-circuiting:
    (setlocal short-circuit t)
    (eq t (or t (setlocal short-circuit nil)))
    short-circuit

    // Test against stack overflows:
    (eq t (or nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil t)))

(test and
    // Test with booleans:
    (eq t (and))
    (eq t (and t))
    (eq nil (and nil t))
    (eq nil (and t nil))

    // Test with other values:
    (eq 5 (and 6 5))
    (eq nil (and t (> 5 6)))
    (eq nil (and (> 6 5) (> 5 6)))
    (eq nil (and (> 5 6) (> 6 5)))
    (eq t (and (> 6 5) (> 7 5)))

    // Test short-circuiting:
    (setlocal short-circuit t)
    (eq nil (and nil (setlocal short-circuit nil)))
    short-circuit

    // Test against stack overflows:
    (eq t (and t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t)))

(test pop
    (eq 4 (pop (list 1 2 3 4)))
    (eq nil (pop (list))) // TODO is this desirable?
    (setlocal l (list 1 2 3 4))
    (eq 4 (pop l))
    (eq (list 1 2 3) l)
    (eq 3 (pop l)))

(test for
    (eq (list 7 8 9) (for i (list 1 2 3) (+ i 6))))

(test do-for
    (not (do-for i (list 1 2 3) i))
    (prints "1\n2\n3" (do-for i (list 1 2 3) (print i))))

(test map
    (eq (list 7 8 9) (map (list 1 2 3) (lambda (i) (+ i 6)))))

(test do-map
    (not (do-map (list 1 2 3) (lambda (i) i)))
    (prints "1\n2\n3" (do-map (list 1 2 3) print)))

(test eval
    ; Test evaluating globals
    (eq eval (eval 'eval))
    ; Test evaluating locals
    (setlocal test-var 5)
    (= 5 (eval 'test-var)))

(test bind
    (prints "\"hello\"" (let (my-print (bind print "hello")) (my-print)))
    (setlocal offset (bind + 6))
    (= 11 (offset 5))
    ; test binding macro/special form
    (setlocal false (bind and nil))
    (not (false t))
    ; test binding with gaps
    (defun printn (&rest args)
        (do-map args print))
    (prints "\"a\"\n\"c\"\n\"b\"" (let (print-out-of-order (bind printn "a" _ "b")) (print-out-of-order "c")))
    ; test that bind args are evaluated
    (setlocal arg 5)
    (setlocal offset (bind + arg))
    (= 5 (offset 0)))

(test rbind
    (setlocal fifth-of (rbind / 5))
    (= 1 (fifth-of 5))
    (setlocal list-burrito (rbind list 'tortilla _ 'tortilla))
    (eq '(sauce tortilla meat tortilla) (list-burrito 'sauce 'meat)))

(test (nth first second third fourth fifth sixth seventh eight ninth tenth)
    (setlocal l (list 1 2 3 4 5 6 7 8 9 10))
    (= 1 (nth l 0))
    (= 10 (nth l 9))
    (= 1 (first l))
    (= 2 (second l))
    (= 3 (third l))
    (= 4 (fourth l))
    (= 5 (fifth l))
    (= 6 (sixth l))
    (= 7 (seventh l))
    (= 8 (eighth l))
    (= 9 (ninth l))
    (= 10 (tenth l)))

(test variable-capture
    (let (value 5)
        (defun return-value () value))
    (= 5 (return-value)))

// For now, Python-style generators are not fully supported.
// yield just returns a value and sets the global `continue`
// to the continuation.
'(test yield
    (defun range (max)
        (setlocal count 0)
        (while (< count max)
            (yield count)
            (setlocal count (+ 1 count))))
    (= 0 (range 2))
    (= 1 (continue))
    (eq nil (continue))
    (= 0 (range 3))
    (= 1 (continue))
    (= 2 (continue)))