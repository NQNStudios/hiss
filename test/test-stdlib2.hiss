(message "Testing Hiss standard library for version $(version)")

(defun eq-with-input (input expected expression)
    (let (version (version)
            hiss-shell-command
                (cond
                    ((contains version "(target: python)") "$(python) bin/py/hiss-repl.py")
                    ((contains version "(target: nodejs)") "node bin/js/hiss-node-repl.js")
                    ((contains version "(target: cpp)") 
                        (File:save-content "temp.sh" "#!/bin/bash\nbin/cpp/CCInterp \$@")
                        "bash temp.sh") ; TODO for some reason, this causes read-line to hang!
                    ((contains version "(target: eval)") "haxe build-scripts/all-script-args.hxml build-scripts/repl/all-repl-args.hxml --run hiss.CCInterp")
                    (t nil)))
        (if hiss-shell-command
                (let (shell-output
                            (begin
                                (File:save-content "temp.hiss" "${expression}")
                                (File:save-content "temp.txt" input)
                                (shell-command "cat temp.txt | $hiss-shell-command temp.hiss")))
                    (eq expected (read shell-output)))

            // If testing a target without a command-line interpreter, automatically pass this check. 
            t)))

(test read-line
    (eq-with-input "sup" "sup" '(print (read-line))))

(test or
    // Test with booleans:
    (eq nil (or))
    (eq t (or t))
    (eq t (or nil t))
    (eq nil (or nil nil))

    // Test with other values:
    (eq 5 (or nil 5))
    (eq nil (or nil (> 5 6)))
    (or (> 6 5) (> 5 6))
    (or (> 5 6) (> 6 5))

    // Test short-circuiting:
    (setlocal short-circuit t)
    (eq t (or t (setlocal short-circuit nil)))
    short-circuit

    // Test against stack overflows:
    (eq t (or nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil t)))

(test and
    // Test with booleans:
    (eq t (and))
    (eq t (and t))
    (eq nil (and nil t))
    (eq nil (and t nil))

    // Test with other values:
    (eq 5 (and 6 5))
    (eq nil (and t (> 5 6)))
    (eq nil (and (> 6 5) (> 5 6)))
    (eq nil (and (> 5 6) (> 6 5)))
    (eq t (and (> 6 5) (> 7 5)))

    // Test short-circuiting:
    (setlocal short-circuit t)
    (eq nil (and nil (setlocal short-circuit nil)))
    short-circuit

    // Test against stack overflows:
    (eq t (and t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t)))

(test pop!
    ; Allow popping from a list literal
    (eq 4 (pop! (list 1 2 3 4)))
    (eq nil (pop! (list))) // TODO is this desirable?
    ; Popping from a variable should modify in place
    (setlocal l (list 1 2 3 4))
    (eq 4 (pop! l))
    (eq (list 1 2 3) l)
    (eq 3 (pop! l)))

(test shift!
    (eq 1 (shift! (list 1 2 3 4)))
    (eq nil (shift! (list)))
    (setlocal l (list 1 2 3 4))
    (eq 1 (shift! l))
    (eq (list 2 3 4) l)
    (eq 2 (shift! l)))

(test take!
    (setlocal l (list 1 2 3 4 5))
    (eq (list 1 2 3) (take! l 3))
    (eq (list 4 5) l))

(test drop!
    (setlocal l (list 1 2 3 4 5))
    (eq (list 3 4 5) (drop! l 2)))

(test for
    (eq (list 7 8 9) (for i (list 1 2 3) (+ i 6)))
    (eq (list 0 2 4 6) (for i (range 7) (if (= 1 (% i 2)) (continue) i)))
    (eq (list 0 1 2 3 4) (for i (range 7) (if (= 5 i) (break) i))))

(test do-for
    (not (do-for i (list 1 2 3) i))
    (prints "1\n2\n3" (do-for i (list 1 2 3) (print i))))

(test map
    (eq (list 7 8 9) (map (list 1 2 3) (lambda (i) (+ i 6)))))

(test do-map
    (not (do-map (list 1 2 3) (lambda (i) i)))
    (prints "1\n2\n3" (do-map (list 1 2 3) print)))

(test continuation-iteration
    (defun one-three-five () (for i (range 8) (cond ((= 1 (% i 2)) i) ((= 6 i) (break)) (t (continue)))))
    (eq (list 1 3 5) (one-three-five))
    (nil? (enable-continuations))
    (eq (list 1 3 5) (one-three-five))
    (nil? (disable-continuations))
    (eq (list 1 3 5) (one-three-five)))

(test eval
    ; Test evaluating globals
    (eq eval (eval 'eval))
    ; Test evaluating locals
    (setlocal test-var 5)
    (= 5 (eval 'test-var)))

(test bind
    (prints "\"hello\"" (let (my-print (bind print "hello")) (my-print)))
    (setlocal offset (bind + 6))
    (= 11 (offset 5))
    ; test binding macro/special form
    (setlocal false (bind and nil))
    (not (false t))
    ; test binding with gaps
    (defun printn (&rest args)
        (do-map args print))
    (prints "\"a\"\n\"c\"\n\"b\"" (let (print-out-of-order (bind printn "a" _ "b")) (print-out-of-order "c")))
    ; test that bind args are evaluated
    (setlocal arg 5)
    (setlocal offset (bind + arg))
    (= 5 (offset 0)))

(test rbind
    (setlocal fifth-of (rbind / 5))
    (= 1 (fifth-of 5))
    (setlocal list-burrito (rbind list 'tortilla _ 'tortilla))
    (eq '(sauce tortilla meat tortilla) (list-burrito 'sauce 'meat)))

(test (nth first second third fourth fifth sixth seventh eighth ninth tenth)
    (setlocal l (list 1 2 3 4 5 6 7 8 9 10))
    (= 1 (nth l 0))
    (= 10 (nth l 9))
    (= 1 (first l))
    (= 2 (second l))
    (= 3 (third l))
    (= 4 (fourth l))
    (= 5 (fifth l))
    (= 6 (sixth l))
    (= 7 (seventh l))
    (= 8 (eighth l))
    (= 9 (ninth l))
    (= 10 (tenth l)))

(test message
    (prints "Hello world" (message "Hello world")))

(test symbol
    (setlocal you "me")
    (eq 'hey-me (symbol "hey-$you"))
    (not (eq (symbol) (symbol))))

(test symbol-name
    (eq "hey" (symbol-name 'hey)))

(test variable-capture
    (let (value 5)
        (defun return-value () value))
    (= 5 (return-value)))

(test read-strings
    (eq #"\"# "\\")
    (eq #"""# "\"")
    (eq #"$"# "\$"))

(test return
    (defun cut-off-early () (return 5) 6)
    (= (cut-off-early) 5)
    (nil? (enable-continuations))
    (= (cut-off-early) 5)
    (nil? (disable-continuations)))

(test string-interpolation
    // TODO test interpolating all types of primitives
    (setlocal i 5)
    (setlocal f 5.5)
    (setlocal sy 'hey-symbol)
    (setlocal st "hey")
    (setlocal l (list 5 5.5 'hey-symbol "hey"))
    (eq "5. hey-symbol" "${i}. $sy")
    (eq "10.5" "$(+ i f)")
    (eq #"(5 5.5 hey-symbol "hey")"# "$l")
    (eq "hey!" "${st}!")
    (eq "hey you" "$st you"))

(test (dict dict-get dict-set! dict-contains dict-erase!)
    (setlocal d (dict "StringKey" "StringValue" 
                        0 5 
                        (list "ListKey") 9))
    
    (dict-contains d "StringKey")
    (dict-contains d 0)
    (dict-contains d (list "ListKey"))
    
    (eq "StringValue" (dict-get d "StringKey"))
    (eq 5 (dict-get d 0))
    (eq 9 (dict-get d (list "ListKey")))

    (or (dict-set! d "StringKey" "DifferentStringValue") t)
    (dict-contains d "StringKey")
    (eq "DifferentStringValue" (dict-get d "StringKey"))

    (or (dict-erase! d "StringKey") t)
    (not (dict-contains d "StringKey")))

(test dict-iteration
    (setlocal d (dict "StringKey" "StringValue"
                        0 5
                        (list "ListKey") 9))
    (eq 6 (length (apply append (for (key value) d (list key value))))))

(test +
    (= 5 (+ 2 3))
    (= 5 (+ 1 2 2))
    (= 5 (+ 10 -5))
    (= -5 (+ -5)))

(test -
    (= -1 (- 1))
    (= 1 (- -1))
    (= 1 (- 3 2)))

(test /
    (= 0.2 (/ 5))
    (= 2.5 (/ 5 2))
    (= .5 (/ 5 2 5)))

(test *
    (= 25 (* 5 5))
    (= -25 (* -5 5)))

(test list-arithmetic
    ; Hiss supports special list and string arithmetic like Python
    (eq (list 1 2 3 4) (+ (list 1 2) (list 3) (list 4)))
    (eq (list 1 1 1 1) (* (list 1) 4))
    (eq (list 1 1 1 1) (* 4 (list 1)))
    (eq (list 1 1 1 1) (* (list 1) 2 2))
    (eq (list 1 1 1 1) (* 2 2 (list 1))))

(test string-arithmetic    
    (eq "1234" (+ "12" "3" "4"))
    (eq "heyheyheyhey" (* "hey" 4))
    (eq "heyheyheyhey" (* 4 "hey"))
    (eq "heyheyheyhey" (* 2 2 "hey"))
    (eq "heyheyheyhey" (* "hey" 2 2)))

(if (bound? defgen)
    (test defgen
        (defgen counter (max) (do-for i (range max) (yield i)))
        (setlocal c (counter 5))
        (eq (list 0 1 2 3 4) (collect c))
        (setlocal c (counter 5))
        (has-next c)
        (has-next c)
        (= 0 (next c))
        (= 1 (next c))
        (has-next c)
        (eq (list 2 3 4) (collect c))))

(test let
    (eq "onetwo" (let (a "one" b "two") (+ a b)))
    (eq "onetwo" (let ((a "one") (b "two")) (+ a b)))
    ; All lets should be sequential:
    (eq (list 1 1 2) (let (a 1 b a c (+ a b)) (list a b c))))

(test index-of
    (= 2 (index-of "heyy" "y"))
    (= 2 (index-of "heyy" "y" 2))
    (= 3 (index-of "heyy" "y" 3))
    (= 2 (index-of '(h e y y) 'y))
    (= 2 (index-of '(h e y y) 'y 2))
    (= 3 (index-of '(h e y y) 'y 3)))

(test contains
    (contains "heyy" "y")
    (not (contains "hey" "hello"))
    (contains (list 1 2 3) 1))

(test tree-replace
    (eq '(hey (whats up)) (tree-replace '(hey (shut up)) 'shut 'whats)))

(test tree-contains
    (tree-contains '(4 5 6 (7 8 9)) 7) 
    (tree-contains '(4 5 6 (7 8 9)) 4)
    (not (tree-contains '(4 5 6 (7 8 9)) 10)))

(test groups
    (eq '((6 5)) (groups '(6 5 3) 2))
    (eq '((6 5) (3)) (groups '(6 5 3) 2 t)))

(test case
    (eq 'good (case (length '(one two three))
        (0 (error! "bad"))
        (3 'good)
        (default (error! "bad"))))
    (eq 'good (case (length '(one two three))
        (2 (error! "bad"))
        (default 'good))))