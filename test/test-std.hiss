t
true
(not nil)
(not false)
(not null)

(= 6 6)
(not (= 6 5))
(= 6 6 6)
(= 6 6 6 6 6 6 6 6 6)
(not (= 6 6 6 6 5))

(< 5 6 7)
(not (< 5 5))
(> 10 9 8)
(not (> 6 6))
(not (> 7 8))
(not (> 7 6 6))

; String tools
(eq "5" (string 5))
(eq "5, 6, 7" (join (list 5 6 7) ", "))
(eq '("5" "6" "7") (split "5,6,7" ","))
(eq "fork me" (replace-at "flankme" 1 "ork "))
(eq "You-All-Everybody" (to-upper-hyphen "youAllEverybody"))
(eq 5 (parse-int "5"))
(eq 5.0 (parse-float "5.0"))
(eq 5 (parse-int "5.0"))

(error? (/))

// Functions should honor return statements
(defun fork (knife-of-choice) 
    (return "fork")
    knife-of-choice)

(eq "fork" (fork "butIWantMyReallyShinyKnife"))

// Loops should honor break and continue statements
(eq '(2 4 6) 
    (for i (range 1 100)
        (cond
            ((> i 6)
                (break))
            ((= 1 (% i 2))
                (continue))
            (t
                i))))

// TODO test while loops, do-fors, etcs

(setq unsorted-int-list '(1 7 4 3 6 2 5))
(setq unsorted-string-list '("baby" "Dont" "hurt" "me"))

; sort function should default to use Reflect.compare
(eq '(1 2 3 4 5 6 7) (sort unsorted-int-list))
(eq '("Dont" "baby" "hurt" "me") (sort unsorted-string-list))
; sort function should have no side effects
(eq unsorted-int-list '(1 7 4 3 6 2 5))
(eq unsorted-string-list '("baby" "Dont" "hurt" "me"))

; sort function should allow custom Hiss compare functions
(defun compare-by-even-odd (a b)
    (- (% a 2) (% b 2)))
(setq sorted-by-even-odd (sort unsorted-int-list compare-by-even-odd))
(defun all-true (list)
    (= (length list) (length (filter list))))
(all-true (for val (take sorted-by-even-odd 3) (= (% val 2) 0)))
(all-true (for val (slice sorted-by-even-odd 3) (= (% val 2) 1)))

; reverse short should invert whatever compare function is used
(eq '(7 6 5 4 3 2 1) (reverse-sort unsorted-int-list))
(setq reverse-sorted-by-even-odd (reverse-sort unsorted-int-list compare-by-even-odd))
(all-true (for val (take reverse-sorted-by-even-odd 4) (= (% val 2) 1)))
(all-true (for val (slice reverse-sorted-by-even-odd 4) (= (% val 2) 0)))

; sort-by should be able to sort data structures conveniently
(setq list-of-lists '(
    (5 4 3)
    (6 7 8)
    (1 2 3)))
(setq sorted-list-of-lists '(
    (1 2 3)
    (5 4 3)
    (6 7 8)))
(eq sorted-list-of-lists (sort-by list-of-lists first))

; Partial functions (currying)
(setq add-a-bunch (apply-partially + 5 6 7))
(= (add-a-bunch 3 6) 27)

; eq semantics with nested HValues
(let (fork "norts")
    (eq '`(fork ,fork) '`(fork ,fork)))

; haxe-strings
(eq "fork-you" (to-lower-hyphen "forkYou"))
(eq "forkYou" (to-lower-camel "fork-you"))
(eq "ForkYou" (to-upper-camel "fork_you"))
(eq "forkyou" (to-lower-case "FORKyoU"))

; haxe objects
(import "String")
(eq "8" (call String from-char-code 56))
(eq 1 (call (new String "hey") index-of "e"))
(eq 3 (get (new String "hey") length))

; Stuff with dictionaries

(setq fork (dict))
(dict-set fork "hey" 'babe)
(dict-set fork "fake" 'something)
(eq 'something (dict-get fork "fake"))
(dict-erase fork "fake")

; Scope in on an HDict
(nil? hey)
(with fork
    (eq 'babe hey)
    (not (bound? 'fake)))

; Test unquoting lists
(setq inner-list (list 5 6 7))
(eq `(1 2 3 4 ,@inner-list) (list 1 2 3 4 5 6 7))
(eq (eval `(+ 1 2 3 4 ,@inner-list)) 28)
(defun adhoc-list (l) `(1 2 3 4 ,@l))
(eq `(,@(adhoc-list inner-list)) '(1 2 3 4 5 6 7))

(eq '((1 4 7) (2 5 8) (3 6 9)) (zip '(1 2 3) '(4 5 6) '(7 8 9)))

(eq '(2 1 3) (swap-nth '(1 2 3) 0 1))

(eq '(hey (whats up)) (subst 'whats 'shut '(hey (shut up))))

; Funcall was acting weird
(eq 3 (funcall length '((5 6 7))))

(eq "hey fork knife" (replace "hey spoon knife" "spoon" "fork"))

(not (setq stuff '()))
(defun what (val) (setq stuff (cons val stuff)))
(nil? (do-list '(5 6 7) what))
(eq 3 (length stuff))

(setq str "    fork   ")
(eq "fork" (trim str))
(eq "fork   " (ltrim str))
(eq "    fork" (rtrim str))
(setq str "fork")
(eq "      fork" (lpad str " " 10))
(eq "fork      " (rpad str " " 10))

; test (when)
(nil? (when nil 
    nil t))
(nil? (when t 
    t nil))
(when t 
    nil t)

; test (unless)
(nil? (unless t
    t t))
(nil? (unless nil
    t nil))
(unless nil
    nil t)

; test (uuid)
(not (eq (uuid) (uuid)))
(not (eq (gensym) (gensym)))

; test (unique)
(eq '(1 2 3 4) (unique '(4 2 2 1 4 3)))

; test hooks
(setq hook-func-counter 0)
(not (setq hook '()))
(add-hook hook (lambda (value) (setq hook-func-counter (+ hook-func-counter value))))
(add-hook hook (lambda (value) (setq hook-func-counter (* hook-func-counter value))))
(nil? (run-hook hook 3))
(eq 9 hook-func-counter)

(eq '(hey hey hey) (list-of 3 'hey))

(eq '(2 3 5) (for l '((1 2) (3 4 5) (6 7 8 9 10)) (length l)))
(eq '(5 6 7) (for i (range 3) (+ i 5)))

(eq 3 (min 5 3 9 10 5))
(eq 10 (max 5 3 9 10 5))
(eq 5 (round 4.5))
(eq 4 (round 4.4))
(eq 4 (floor 4.5))
(eq 5 (ceil 4.4))
(eq 5 (abs -5))
(eq 5 (abs 5))

(between-inclusive 5 5 5)
(between-exclusive 6 5 7)
(between-exclusive 6 7 5)

(setq fizz '(5 6 7))
(setq fizz2 (copy fizz))
(push fizz2 8)
(not (eq fizz fizz2))

(contains '(4 5 6) 5)
(not (contains '(4 5 6) 7))

(eq 8 (last '(5 6 7 8)))

(not (try (call RandomFile doesntExist)))

(= 3 (length (split (get-content "test/expressions.hiss") "\n")))
(nil? (get-content "doesntexists"))

(eq 'working (load "module.hiss"))

(eq '((6 5)) (groups '(6 5 3) 2))
(eq '((6 5) (3)) (groups '(6 5 3) 2 t))

(eq '("hey" 5 sym) (create-enum H-Value "List" (list (list "hey" 5 'sym))))

// Test the switch macro
(eq 3 (switch 'Fork 
    (List (l) 1)
    (Signal (s) 2)
    (Symbol (s) 3)
    (default 'default)))

(eq 'default (switch 'Fork
    (List (l) l)
    (default 'default)))

(eq 4 (switch '(4 5 6)
    (Symbol (s) s)
    (List (l) (first l))
    (Signal (s) s)
    (default 'default)))

(error? (switch 'fork (Symbol (s) s)))

(error? (first '()))

; Test custom reader macros
(set-macro-string "#" (lambda (a b c) (list 'sharp (read-string a b))))
(eq '(sharp "fork") (read "#fork\""))
(set-macro-string "^" (lambda (a b c) (cons 'sharp (read-delimited-list "]" '("|") a b nil))))
(eq '(sharp fork 5 "shit") (read "^fork|5|\"shit\"]"))