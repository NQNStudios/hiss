
(defmacro let (bindings &rest body)
    ;(print bindings)
    `(progn
        (scope-in)
        ,(cons 'setlocal ,bindings)
        (setlocal let-result ,(cons 'progn body))
        (scope-return let-result)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first                                      
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                ,(cons 'progn (rest case-first))
                ,(cons 'case (cons form case-rest)))
            nil)))

(defmacro and (&rest --and-args)
    (case (length --and-args)
        (0 't)
        (1 (first --and-args))
        (2 (if (eval (first --and-args)) (eval (first (rest --and-args)))))
        (t (funcall and (cons (and (funcall and (take --and-args 2))) (slice --and-args 2))))))

(defmacro default (var value)
    `(setlocal ,var
        (if (and (bound? (quote ,var)) (quote ,var))
            ,var
            ,value)))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (default zero-case 0)
    (default one-case 'val)
    (default two-case '(fun val1 val2))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 (let (val (first args)) ,one-case))
            (2 (let (val1 (nth args 0)
                    val2 (nth args 1)
                    fun ,base-function)
                ,two-case))
            (t (funcall ,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= haxe<= (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= haxe>= (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))


(defun between-exclusive (a b c)
    (or (< a b c) (> a b c)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))
; TODO add advice to this function to coerce to t or nil to avoid errors, although technically it *does* return truthy when it should(combine-like-operators '(+ 2 (+ 5 3)))

; (variadic-binop and haxe&& t val (if val1 val2 nil))


(defmacro when (cond &rest body)
    `(if ,cond ,(cons 'progn body)))

(defmacro unless (cond &rest body)
`(if (not ,cond) ,(cons 'progn body)))

; Useful for AOC 2019 day 2 ;)
(defun swap-nth (list n1 n2)
    (setlocal temp (nth list n1))
    (set-nth list n1 (nth list n2))
    (set-nth list n2 temp))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(defun sum (args)
    (let (total 0)
        (for arg args (setlocal total (+ total arg)))
        total
        ))

(defmacro push (l elt)
    `(setlocal ,l (append ,l (list ,elt))))

(defun filter (l &optional criterion)
    (default criterion (lambda (val) val))
    ;(print result)
    ;(print l)
    (let (result '())
        ;(setlocal result '())
        ;(print "in the let")
        ;(print result)
        (for val l
            ;(print result)
            (if (funcall criterion `(,val))
                (push result val)))
        result))

(defun unique (list)
    (let (result '())
        (for v (sort list) (if (not (contains result v)) (push result v)))
        result))

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "src/stdlib.hiss"))
(defun lp (num) (load (+ "aoc/p" num ".hiss")))