(defmacro let (bindings &rest body)
    ;(print bindings)
    `(progn
        (scope-in)
        ,(cons 'setlocal ,bindings)
        (setlocal let-result ,(cons 'progn body))
        (scope-return let-result)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first                                      
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                ,(cons 'progn (rest case-first))
                ,(cons 'case (cons form case-rest)))
            nil)))

(defmacro default (var value)
    `(setlocal ,var
        (if (and (bound? (quote ,var)) ,var)
            ,var
            ,value)))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (default zero-case 0)
    (default one-case 'val)
    (default two-case '(fun val1 val2))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 (let (val (first args)) ,one-case))
            (2 (let (val1 (nth args 0)
                    val2 (nth args 1)
                    fun ,base-function)
                ,two-case))
            (t (funcall ,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= haxe<= (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= haxe>= (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))


(defun between-exclusive (a b c)
    (or (< b a c) (> c a b)))
(defun between-inclusive (a b c)
    (or (<= b a c) (>= c a b)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))
; TODO add advice to this function to coerce to t or nil to avoid errors, although technically it *does* return truthy when it should(combine-like-operators '(+ 2 (+ 5 3)))

; (variadic-binop and haxe&& t val (if val1 val2 nil))


(defmacro when (cond &rest body)
    `(if ,cond ,(cons 'progn body)))

(defmacro unless (cond &rest body)
`(if (not ,cond) ,(cons 'progn body)))

; Useful for AOC 2019 day 2 ;)
(defun swap-nth (list n1 n2)
    (setlocal temp (nth list n1))
    (set-nth list n1 (nth list n2))
    (set-nth list n2 temp))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(defun sum (args)
    (let (total 0)
        (for arg args (setlocal total (+ total arg)))
        total
        ))

(defmacro push (l elt)
    `(setlocal ,l (append ,l (list ,elt))))

(defun filter (l &optional criterion)
    (default criterion (lambda (val) val))
    ;(print result)
    ;(print l)
    (let (result '())
        ;(setlocal result '())
        ;(print "in the let")
        ;(print result)
        (for val l
            ;(print result)
            (if (funcall criterion `(,val))
                (push result val)))
        result))

(defun unique (list)
    (let (result '())
        (for v (sort list) (if (not (contains result v)) (push result v)))
        result))

(defun reverse-sort (list &optional compare-function)
    (reverse (sort list compare-function)))

(defun sort-by (list function)
    "Sort a list by applying a function that returns a comparable to each element"
    (sort list (lambda (a b) (- (funcall function `(,a) nil) (funcall function `(,b) nil)))))

(defmacro apply-partially (function &rest args)
    (setlocal evaled-args (for arg args (eval arg)))
    `(lambda (&rest missing-args)
        (funcall ,function (append ',evaled-args missing-args) nil)))

(defun list-of (size element)
    (for i (range size) element))

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (let (final-length (funcall min (map lists length))
            result (list-of final-length '()))
        (for i (range final-length)
            (map lists (lambda (l) (nth l i))))))

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "src/stdlib.hiss"))
(defun lp (num) (load (+ "aoc/p" num ".hiss")))