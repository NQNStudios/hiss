(defmacro register-function (class function name &optional keep-args-wrapped)
    `(defun ,name (&rest args)
        (call-haxe ,class ,function args nil ,keep-args-wrapped)))
(defmacro register-method (method name &optional call-on-reference keep-args-wrapped)
    `(defun ,name (instance &rest args)
        (call-haxe instance ,method args call-on-reference keep-args-wrapped)))
(register-function Hiss-Tools "print" print t)
(register-function Hiss-Tools "length" length t)
(register-function Hiss-Tools "first" first t)
(register-function Hiss-Tools "rest" rest t)
(register-function Hiss-Tools "eq" eq t)
(register-function Hiss-Tools "nth" nth t)
(register-function Hiss-Tools "cons" cons t)
(register-method "concat" concat nil nil) ; TODO instead of this, have variadic (append) function
(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))

(defun not (arg)
    (if arg nil t))
(defmacro or (&rest args)
    `(if (not ',args) nil
        (if (not ,(first args)) (or ,@(rest args)) ,(first args))))
(defmacro and (&rest args)
    `(if (not ',args) t
        (if (not ',(rest args))
            ,(first args)
            (if (not ,(first args)) nil
                (and ,@(rest args))))))

(register-function Type "resolveClass" resolve-class)
(register-function Type "resolveEnum" resolve-enum)
(defmacro import (type-path name)
    `(defvar ,name (or (resolve-class ,type-path) (resolve-enum ,type-path))))

(import "Sys" Sys)
(register-function Sys "exit" exit)
(defun quit () (exit 0))

(defun list (&rest args) args)

(defun alternates (start l)
    (if (not l)
            '()
        (if start
                (cons (first l) (alternates t (slice l 2)))
            (alternates t (rest l)))))

(defmacro let (bindings &rest body)
    `(funcall-inline
        (lambda ,(alternates t bindings)
            ,@body)
        ,@(alternates nil bindings)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                (begin ,@(rest case-first))
                (case ,form ,@case-rest))
            nil)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'begin (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defmacro apply (f args)
    (cons f (eval args)))

/*
(defmacro bind (f &rest args)
    `(lambda (&rest missing-args) (apply ,f (concat ',args missing-args))))

(defmacro rbind (f &rest args)
    `(lambda (&rest missing-args) (apply ,f (concat missing-args ',args))))

/*
(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))
*/