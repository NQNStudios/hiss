(defmacro register-function (class function name &optional keep-args-wrapped)
    `(defun ,name (&rest args)
        (call-haxe ,class ,function args nil ,keep-args-wrapped)))
(defmacro register-method (method name &optional call-on-reference keep-args-wrapped)
    `(defun ,name (instance &rest args)
        (call-haxe instance ,method args call-on-reference keep-args-wrapped)))
(register-function Hiss-Tools "print" print t)
(register-function Hiss-Tools "length" length t)
(register-function Hiss-Tools "first" first t)
(register-function Hiss-Tools "rest" rest t)
(register-function Hiss-Tools "eq" eq t)
(register-function Hiss-Tools "nth" nth t)
(register-function Hiss-Tools "cons" cons t)
(register-method "concat" concat nil nil) ; TODO instead of this, have variadic (append) function

(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))
(defun take (l num)
    (slice l 0 num))

(defmacro quote (arg) `',arg)

(defun not (arg)
    (if arg nil t))
(defmacro or (&rest args)
    `(if (not ',args) nil
        (if (not ,(first args)) (or ,@(rest args)) ,(first args))))
(defmacro and (&rest args)
    `(if (not ',args) t
        (if (not ',(rest args))
            ,(first args)
            (if (not ,(first args)) nil
                (and ,@(rest args))))))

(register-function Type "resolveClass" resolve-class)
(register-function Type "resolveEnum" resolve-enum)
(defmacro import (type-path name)
    `(defvar ,name (or (resolve-class ,type-path) (resolve-enum ,type-path))))

(import "Sys" Sys)
(register-function Sys "exit" exit)
(defun quit () (exit 0))

(defun list (&rest args) args)

(defun alternates (start l)
    (if (not l)
            '()
        (if start
                (cons (first l) (alternates t (slice l 2)))
            (alternates t (rest l)))))

(defmacro let (bindings &rest body)
    `(funcall-inline
        (lambda ,(alternates t bindings)
            ,@body)
        ,@(alternates nil bindings)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                (begin ,@(rest case-first))
                (case ,form ,@case-rest))
            nil)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'begin (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defmacro when (cond &rest body)
    `(if ,cond (begin ,@body)))

(defun map (l function)
    (if l
            (cons (function (first l)) (map (rest l) function))
        (list)))

(defun dolist (l function)
    (when l
        (function (first l))
        (dolist (rest l) function)))

(defmacro for (var l &rest body)
    `(map ,l (lambda (,var) ,@body)))

(defmacro while (cond &rest body)
    (print `(call/cc (lambda (break)
        (when ,cond
            (call/cc (lambda (continue)
                ,@body))
            (while ,cond ,@body))))))

(defun apply (f args)
    (eval `(,f ',@args)))

(import "hiss.HaxeBinops" Haxe-Binops)
(defmacro variadic-binop (symbol op-name &optional zero-case one-case two-case)
    (let (c0 (or zero-case 0)
            c1 (or one-case 'val)
            c2 (or two-case '(fun val1 val2)))

        `(defun ,symbol (&rest args)
            (let (fun (lambda (a b) (call-haxe Haxe-Binops ,op-name (list a b))))
                (case (length args)
                    (0 ,c0)
                    (1 (let (val (first args)) ,c1))
                    (2 (let (val1 (nth args 0)
                            val2 (nth args 1))
                        ,c2))
                    (t
                        (apply ,symbol
                            (cons (apply ,symbol (take args 2))
                                (slice args 2)))))))))

(variadic-binop - "subtract" 0 (fun 0 val))
(variadic-binop + "add")
(variadic-binop / "divide" (error "can't divide without an operand") (fun 1 val))
(variadic-binop * "multiply" 1)

(variadic-binop < "lesser" (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= "lesserEqual" (error "cannot evaluate less-than-equal without operands") t (if (fun val1 val2) val2))
(variadic-binop > "greater" (error "cannot evaluate greater-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= "greaterEqual" (error "cannot evaluate greater-than-equal without operands") t (if (fun val1 val2) val2))


(variadic-binop min "lesser" (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max "greater" (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = "equals" (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))

(defmacro bind (f &rest args)
    `(lambda (&rest missing-args) (apply ,f (concat ',args missing-args))))

(defmacro rbind (f &rest args)
    `(lambda (&rest missing-args) (apply ,f (concat missing-args ',args))))

(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))