(defmacro register-function (class function name &optional keep-args-wrapped)
    `(defun ,name (&rest args)
        (call-haxe ,class ,function args nil ,keep-args-wrapped)))
(defmacro register-method (method name &optional call-on-reference keep-args-wrapped return-instance)
    `(defun ,name (instance &rest args)
        (setlocal result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))
        (if ,return-instance instance result)))

(register-method "concat" concat nil nil) ; TODO instead of this, have variadic (append) function
(register-method "push" push t t t)
(register-method "shift" shift t)
(register-method "pop" pop t)

(defun drop (l num)
    (call-haxe l "splice" (list 0 num) t)
    l)
(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))
(defun take (l num)
    (slice l 0 num))

(defmacro or (&rest args)
    `(if (not ',args) nil
        (if (not ,(first args)) (or ,@(rest args)) ,(first args))))
(defmacro and (&rest args)
    `(if (not ',args) t
        (if (not ',(rest args))
            ,(first args)
            (if (not ,(first args)) nil
                (and ,@(rest args))))))

(register-function Type "resolveClass" resolve-class)
(register-function Type "resolveEnum" resolve-enum)
(defmacro import (type-path name)
    `(defvar ,name (or (resolve-class ,type-path) (resolve-enum ,type-path))))

(import "Sys" Sys)
(register-function Sys "exit" exit)
(defun quit () (exit 0))

(defun list (&rest args) args)

(defmacro let (bindings &rest body)
    `(funcall-inline
        (lambda ,(even-alternates bindings)
            ,@body)
        ,@(odd-alternates bindings)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                (begin ,@(rest case-first))
                (case ,form ,@case-rest))
            nil)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'begin (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defmacro when (cond &rest body)
    `(if ,cond (begin ,@body)))

(defmacro unless (cond &rest body)
    `(when (not ,cond) ,@body))

(defmacro while (cond &rest body)
    `(call/cc (lambda (break)
        (loop ()
            (when ,cond
                (call/cc (lambda (continue)
                    ,@body))
                (if ,cond (recur)))))))

(defun map (l function)
    (setlocal collection (list))
    (while l
        (push collection (funcall-inline function (shift l))))
    collection)

(defmacro for (var l &rest body)
    `(funcall-inline map ,l (lambda (,var) ,@body)))

(defun apply (f args)
    (eval `(,f ',@args)))

(defmacro bind (f &rest bind-args)
    `(lambda (&rest call-args) 
        (setlocal args (for arg ',bind-args (if (eq '_ arg) (shift call-args) arg)))
        (apply ,f (concat args call-args))))

(defmacro rbind (f &rest bind-args)
    `(lambda (&rest call-args) 
        (setlocal args (for arg ',bind-args (if (eq '_ arg) (pop call-args) arg)))
        (apply ,f (concat call-args args))))

(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))