(defmacro register-function (class function name &optional keep-args-wrapped)
    `(defun ,name (&rest args)
        (call-haxe ,class ,function args nil ,keep-args-wrapped)))
(defmacro register-method (method name &optional call-on-reference keep-args-wrapped return-instance)
    `(defun ,name (instance &rest args)
        (setlocal result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))
        (if ,return-instance instance result)))
(defun new (class &rest args)
    (create-instance class args))

(register-method "push" push! t t t)
(register-method "shift" shift! t)

(register-method "pop" pop! t)

(defun take! (l num)
    (call-haxe l "splice" (list 0 num) t))
(defun drop! (l num)
    (call-haxe l "splice" (list 0 num) t)
    l)
(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))
(defun peek (l num)
    (slice l 0 num))

(defun list (&rest args) args)

(defmacro let (bindings &rest body)
    `(funcall-inline
        (lambda ,(even-alternates bindings)
            ,@body)
        ,@(odd-alternates bindings)))

(defmacro when (cond &rest body)
    `(if ,cond (begin ,@body)))

(defmacro unless (cond &rest body)
    `(when (not ,cond) ,@body))

(defmacro while (cond &rest body)
    `(call/cc (lambda (break)
        (loop ()
            (when ,cond
                (call/cc (lambda (continue)
                    ,@body))
                (if ,cond (recur)))))))

(defun apply (f args)
    (eval `(,f ',@args)))

(defmacro bind (f &rest bind-args)
    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))
        `(lambda (&rest call-args)
            (setlocal args (for arg ',bind-args (if (eq '_ arg) (shift! call-args) arg)))
            (apply ,f (append args call-args)))))

(defmacro rbind (f &rest bind-args)
    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))
        `(lambda (&rest call-args)
            (setlocal args (for arg ',bind-args (if (eq '_ arg) (pop! call-args) arg)))
            (apply ,f (append call-args args)))))

(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (let (final-length (first (sort (for l lists (length l)))))
        (for i (range final-length)
            (for l lists (nth l i)))))

(defun current-continuation ()
    (call/cc (lambda (cc) 
        (cc cc))))

(defmacro yield (value)
    `(let (ret return cc (current-continuation))
        (defvar continue cc)
        (ret ,value)))