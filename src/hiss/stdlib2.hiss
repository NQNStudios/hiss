(defmacro register-method (method name &optional call-on-reference keep-args-wrapped return-instance)
    "Register a method call as an unqualified global function. Unlike CCInterp.importClass, there won't be a Class: prefix"
    `(defun ,name (instance &rest args)
        (setlocal result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))
        (if ,return-instance instance result)))

(register-method "push" push! t t t)
(register-method "shift" shift! t)

(register-method "pop" pop! t)

(defun take! (l num)
    (call-haxe l "splice" (list 0 num) t))
(defun drop! (l num)
    (call-haxe l "splice" (list 0 num) t)
    l)
(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))
(defun rslice (l start &optional end)
    (let (len (length l))
        (slice l (- len (or end len)) (- len start))))
(defun peek (l num)
    (slice l 0 num))

(defun nil? (v) (eq nil v))

// String functions:
(register-method "split" split)
(register-method "substr" substring)
(defun char-at (str idx) (substring str idx 1))

(defun list (&rest args) args)
(defun empty? (list-or-string) (or (nil? list-or-string) (= 0 (length list-or-string))))

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (setlocal final-length (first (sort (for l lists (length l)))))
    (for i (range final-length)
        (for l lists (nth l i))))

(defmacro cond (&rest forms)
    `(if (not ',forms)
            (error! "cond ran out of options. add a default case")
        (and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'begin (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms)))))))

(defmacro let (bindings &rest body)
    (setlocal setlocal-exps 
        (cond
            ; New-fangled, single-list let bindings like (name1 val1 name2 val2)
            ((symbol? (first bindings))
                (setlocal names (odd-alternates bindings))
                (setlocal values (even-alternates bindings))
                (for pair (zip names values) `(setlocal ,(first pair) ,(nth pair 1))))

            ; Old-school, many-list let bindings like ((name1 val1) (name2 val2))
            ((list? (first bindings))
                (for pair bindings `(setlocal ,@pair)))))
    `(begin
        ,@setlocal-exps
        ,@body))

(defmacro when (cond &rest body)
    `(if ,cond (begin ,@body)))

(defmacro unless (cond &rest body)
    `(when (not ,cond) ,@body))

(defmacro while (cond &rest body)
    `(call/cc (lambda (break)
        (loop ()
            (when ,cond
                (call/cc (lambda (continue)
                    ,@body))
                (if ,cond (recur)))))))

(defun apply (f args)
    (eval `(,f ',@args)))

(defmacro bind (f &rest bind-args)
    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))
        `(lambda (&rest call-args)
            (setlocal args (for arg ',bind-args (if (eq '_ arg) (shift! call-args) arg)))
            (apply ,f (append args call-args)))))

(defmacro rbind (f &rest bind-args)
    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))
        `(lambda (&rest call-args)
            (setlocal args (for arg ',bind-args (if (eq '_ arg) (pop! call-args) arg)))
            (apply ,f (append call-args args)))))

(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))

(defun collect (iterable)
    (for elem iterable elem))

(defun enumerate (l)
    (zip (collect (range (length l))) l))

(defun filter (l &optional pred)
    (let (pred (or pred (lambda (x) x))
            result (list))
        (do-for elem l (when (pred elem) (push! result elem)))
        result))

(defun current-continuation ()
    (call/cc (lambda (cc) 
        (cc cc))))

(defmacro _case (value &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ',(first case-first) 'default) (eq ,(first case-first) ,value))
                (begin ,@(rest case-first))
                (case ,value ,@case-rest))
            nil)))
(defmacro case (form &rest case-list)
    `(let (value ,form) (_case value ,@case-list)))

(defun input-string (&optional prompt)
    (when prompt (message prompt))
    (read-line))

(defun input-int (&optional prompt)
    (int (input-string prompt)))

(defun input-float (&optional prompt)
    (float (input-string prompt)))

(defun input-symbol (&optional prompt)
    (let (name 
                (input-string prompt))
        // don't return a gensym if the input is blank
        (if (empty? name) nil (symbol name))))


// Very dangerous function:
(defun input-expression (&optional prompt)
    (eval (read (input-string prompt))))

(defun input-choice (choices &optional prompt)
    (when prompt (message prompt))
    (do-for (idx choice) (enumerate choices)
        (message "${idx}. $(to-print choice)"))
    (nth choices (input-int "> ")))

(defmacro default! (var value)
    `(if (or (not (bound? ,var)) (nil? ,var)) (set! ,var ,value)))

// (next) and (has-next) should work on Iterables AND Iterators, for convenience
(defun iterator (iterable-or-iterator)
    (if (get-property iterable-or-iterator "iterator")
        (call-haxe iterable-or-iterator "iterator") iterator-or-iterable))

(defun next (iterable-or-iterator)
    (call-haxe (iterator iterable-or-iterator) "next"))

(defun has-next (iterable-or-iterator)
    (call-haxe (iterator iterable-or-iterator) "hasNext"))

(if (bound? Thread)
    (defmacro defgen (name args &rest body)
        `(defun ,name ,args
            (let (__lock__ (new Lock)
                    __deque__ (new Deque)
                    __thread__ nil
                    __next__ nil // When has-next is called, the next value must be stored
                    __done__ nil
                    __done-signal__ (symbol)
                    yield (lambda (value)
                                (Deque:add __deque__ value)
                                (Lock:wait __lock__))
                    next (lambda ()
                            (if __done__ nil
                                (begin
                                    (if __next__
                                        (return (let (ret __next__)
                                            (set! __next__ nil)
                                            ret)))
                                    (if (not __thread__)
                                        (set! __thread__ (Thread:create
                                                                (lambda ()
                                                                    ,@body
                                                                    (Deque:add __deque__ __done-signal__)))))
                                    (Lock:release __lock__)
                                    (let (value (Deque:pop __deque__ t))
                                        (case value
                                            (__done-signal__ (set! __done__ t) nil)
                                            (default value))))))
                    has-next (lambda ()
                                (if __done__ nil
                                    (if __next__ t
                                        (let (could-be-next (next))
                                            (case could-be-next
                                                (nil (not __done__))
                                                (default (set! __next__ could-be-next) t)))))))
                (iterable next has-next)))))

(defun memoize (f)
    "Return a version of the given function that caches return values for different argument lists"
    (let (prior-args (dict))
        (lambda (&rest args)
            (or (dict-get prior-args args)
                (let (result (apply f args))
                    (dict-set! prior-args args result)
                    result)))))

; TODO if it's neither a list nor string, throw an error
; In cases where a function name could reasonably be expected to work the same on EITHER a string or a list, Hiss should support both:
(defun replace (string-or-list old new)
    (cond
        ((list? string-or-list)
            (for elem string-or-list (if (eq old elem) new elem)))
        ((string? string-or-list)
            (call-haxe StringTools "replace" (list string-or-list old new)))
        (t (error! "replace can't be called on $string-or-list"))))

(defun index-of (string-or-list part &optional start-index)
    (default! start-index 0)
    (cond
        ((list? string-or-list)
            (setlocal found-idx -1)
            (do-for (idx elem) (enumerate string-or-list)
                (when (and (<= start-index idx) (eq part elem))
                    (set! found-idx idx)
                    (break)))
            found-idx)
        ((string? string-or-list)
            (call-haxe string-or-list "indexOf" (list part start-index)))
        (t (error! "index-of can't be called on $string-or-list"))))

(defun last-index-of (string-or-list part &optional start-index)
    (default! start-index (- (length (string-or-list)) 1))
    (cond
        ((list? string-or-list)
            (do-for (idx elem) (reverse (enumerate string-or-list))
                (if (and (>= start-index idx) (eq part elem))
                    (return idx)))
            -1)
        ((string? string-or-list)
            (call-haxe string-or-list "lastIndexOf" (list part start-index)))
        (t (error! "last-index-of can't be called on $string-or-list"))))


(defun contains (string-or-list part)
    (<= 0 (index-of string-or-list part)))

; It also might make sense to have recursive versions of some of these:

(defun tree-replace (tree old new)
    (cond
        ((list? tree)
            (for subtree tree (tree-replace subtree old new)))
        (t (if (eq tree old) new tree))))

(defun tree-contains (tree elem)
    (cond
        ((list? tree)
            (setlocal found nil)
            (do-for subtree tree
                (when (tree-contains subtree elem)
                    (set! found t)
                    (break)))
            found)
        (t (eq tree elem))))

(defun groups (l size &optional take-remainder)
    (cond
        ((< (length l) size)
            (if take-remainder
                    (list l)
                (list)))
        ((= (length l) size)
            (list l))
        (t (cons (peek l size) (groups (slice l size) size take-remainder)))))

(defvar *types* (dict))

(defmacro deftype (name &rest predicates)
    (let (predicate-values
                (for predicate predicates (eval predicate))
            combined-predicate
                (lambda (val)
                    (set! ret t)
                    (do-for predicate predicate-values
                        (when (not (predicate val))
                            (set! ret nil)
                            (break)))
                    ret)
            predicate-name (symbol "$(symbol-name name)?"))
        `(begin
            (dict-set! *types* ',name ,combined-predicate)
            (default! ,predicate-name ,combined-predicate)  ; If a predicate with the given name is already defined, it will be kept as the global predicate
            t)))

(defmacro the (type var)
    "Throw an error if the given variable is not the given type, else return the variable"
    `(if ((dict-get *types* ',type) ,var)
            ,var
        (error! ,"$var is not expected type $type")))

(deftype int int?)
(deftype float float?)
(deftype number number?)
(deftype symbol symbol?)
(deftype string string?)
(deftype list list?)
(deftype pair list? (lambda (l) (= 2 (length l))))
(deftype dict dict?)
(deftype function function?)
(deftype macro macro?)
(deftype callable callable?)
(deftype object object?)
(deftype any (lambda (v) t))

(defmacro defstruct (name &rest fields)
    (let (make-function-name
                (symbol "make-$name")
            type-predicate-name
                (symbol "${name}?")
            field-names-and-types
                (for field fields
                    (cond
                        ((pair? field) field)
                        ((symbol? field) (list field 'any))
                        (t (error! "struct fields must either be a symbol (for any type) or a pair (for a specific type)"))))
            field-indices
                (collect (range 1 (+ 1 (length fields))))
            field-info
                (zip field-indices field-names-and-types)
            field-getters
                (for (index (field-name _)) field-info
                    `(defun ,(symbol "${name}-${field-name}") (instance) (nth instance ,index)))
            all-fields-typecheck
                (for (index (field-name field-type)) field-info
                    `(the ,field-type (nth instance ,index)))
            field-setters
                (for (index (field-name field-type)) field-info
                    `(defun ,(symbol "${name}-set-${field-name}!") (instance value) (set-nth! instance ,index (the ,field-type value)))))

    `(begin
        (defun ,make-function-name (&rest make-args) (the ,name (cons ',name make-args)))
        (defun ,type-predicate-name (instance)
            (and (eq ',name (first instance))
                (not (error? (begin ,@all-fields-typecheck)))))

        ,@field-getters
        ,@field-setters
        (deftype ,name ,type-predicate-name))))

(defmacro def-reader-macro (str arg-names &rest body)
    `(_set-macro-string ,str (lambda (,(first arg-names) ,(second arg-names)) ,@body)))

(def-reader-macro "[" (start stream) (cons 'list (read-delimited-list "]" '() start stream)))