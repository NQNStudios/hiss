(defmacro register-method (method name &optional call-on-reference keep-args-wrapped return-instance)
    "Register a method call as an unqualified global function. Unlike CCInterp.importClass, there won't be a Class: prefix"
    `(defun ,name (instance &rest args)
        (setlocal result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))
        (if ,return-instance instance result)))

(register-method "push" push! t t t)
(register-method "shift" shift! t)

(register-method "pop" pop! t)

(defun take! (l num)
    (call-haxe l "splice" (list 0 num) t))
(defun drop! (l num)
    (call-haxe l "splice" (list 0 num) t)
    l)
(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))
(defun peek (l num)
    (slice l 0 num))

// String functions:
(register-method "split" split)
(register-method "substr" substr)

(defun list (&rest args) args)

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (setlocal final-length (first (sort (for l lists (length l)))))
    (for i (range final-length)
        (for l lists (nth l i))))

(defmacro let (bindings &rest body)
    (setlocal names (odd-alternates bindings))
    (setlocal values (even-alternates bindings))
    (setlocal setlocal-exps (for pair (zip names values) `(setlocal ,(first pair) ,(nth pair 1))))
    `(begin
        ,@setlocal-exps
        ,@body))

(defmacro when (cond &rest body)
    `(if ,cond (begin ,@body)))

(defmacro unless (cond &rest body)
    `(when (not ,cond) ,@body))

(defmacro while (cond &rest body)
    `(call/cc (lambda (break)
        (loop ()
            (when ,cond
                (call/cc (lambda (continue)
                    ,@body))
                (if ,cond (recur)))))))

(defun apply (f args)
    (eval `(,f ',@args)))

(defmacro bind (f &rest bind-args)
    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))
        `(lambda (&rest call-args)
            (setlocal args (for arg ',bind-args (if (eq '_ arg) (shift! call-args) arg)))
            (apply ,f (append args call-args)))))

(defmacro rbind (f &rest bind-args)
    (let (bind-args (for __arg__ bind-args (if (not (eq '_ __arg__)) (eval __arg__) __arg__)))
        `(lambda (&rest call-args)
            (setlocal args (for arg ',bind-args (if (eq '_ arg) (pop! call-args) arg)))
            (apply ,f (append call-args args)))))

(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))

(defun collect (iterable)
    (for elem iterable elem))

(defun enumerate (l)
    (zip (collect (range (length l))) l))

(defun filter (l &optional pred)
    (let (pred (or pred (lambda (x) x))
            result (list))
        (do-for elem l (when (pred elem) (push! result elem)))
        result))

(defun current-continuation ()
    (call/cc (lambda (cc) 
        (cc cc))))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                (begin ,@(rest case-first))
                (case ,form ,@case-rest))
            nil)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'begin (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defun input-expression (&optional prompt)
    (when prompt (message prompt))
    (eval (read (read-line))))

(defun input-string (&optional prompt)
    (when prompt (message prompt))
    (read-line))

// (next) and (has-next) should work on Iterables AND Iterators, for convenience
(defun iterator (iterable-or-iterator)
    (if (get-property iterable-or-iterator "iterator")
        (call-haxe iterable-or-iterator "iterator") iterator-or-iterable))

(defun next (iterable-or-iterator)
    (call-haxe (iterator iterable-or-iterator) "next"))

(defun has-next (iterable-or-iterator)
    (call-haxe (iterator iterable-or-iterator) "hasNext"))

(if Thread
    (defmacro defgen (name args &rest body)
        `(defun ,name ,args
            (let (__lock__ (new Lock)
                    __deque__ (new Deque)
                    __thread__ (list)
                    __next__ (list) // When has-next is called, the next value must be stored
                    __done__ (list)
                    __done-signal__ (symbol)
                    yield (lambda (value)
                                (Deque:add __deque__ value)
                                (Lock:wait __lock__))
                    next (lambda ()
                            (if __done__ nil
                                (begin
                                    (if __next__
                                        (return (let (ret (first __next__))
                                            (clear! __next__)
                                            ret)))
                                    (if (not __thread__)
                                        (push! __thread__ (Thread:create
                                                                (lambda ()
                                                                    ,@body
                                                                    (Deque:add __deque__ __done-signal__)))))
                                    (Lock:release __lock__)
                                    (let (value (Deque:pop __deque__ t))
                                        (case value
                                            (__done-signal__ (push! __done__ t) nil)
                                            (t value))))))
                    has-next (lambda ()
                                (if __done__ nil
                                    (if __next__ t
                                        (let (could-be-next (next))
                                            (case could-be-next
                                                (nil (not __done__))
                                                (t (push! __next__ could-be-next) t)))))))
                (iterable next has-next)))))

(defun memoize (f)
    "Return a version of the given function that caches return values for different argument lists"
    (let (prior-args (dict))
        (lambda (&rest args)
            (or (dict-get prior-args args)
                (let (result (apply f args))
                    (dict-set! prior-args args result)
                    result)))))
