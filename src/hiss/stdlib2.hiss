(defmacro register-function (class function name &optional keep-args-wrapped)
    `(defun ,name (&rest args)
        (call-haxe ,class ,function args nil ,keep-args-wrapped)))
(defmacro register-method (method name &optional call-on-reference keep-args-wrapped return-instance)
    `(defun ,name (instance &rest args)
        (setlocal result (call-haxe instance ,method args ,call-on-reference ,keep-args-wrapped))
        (if ,return-instance instance result)))

(register-method "concat" concat nil nil) ; TODO instead of this, have variadic (append) function
(register-method "push" push t t t)
(register-method "shift" shift t)

(defun drop (l num)
    (call-haxe l "splice" (list 0 num) t)
    l)
(defun slice (l start &optional end)
    (call-haxe l "slice" (list start (or end (length l)))))
(defun take (l num)
    (slice l 0 num))

(defmacro or (&rest args)
    `(if (not ',args) nil
        (if (not ,(first args)) (or ,@(rest args)) ,(first args))))
(defmacro and (&rest args)
    `(if (not ',args) t
        (if (not ',(rest args))
            ,(first args)
            (if (not ,(first args)) nil
                (and ,@(rest args))))))

(register-function Type "resolveClass" resolve-class)
(register-function Type "resolveEnum" resolve-enum)
(defmacro import (type-path name)
    `(defvar ,name (or (resolve-class ,type-path) (resolve-enum ,type-path))))

(import "Sys" Sys)
(register-function Sys "exit" exit)
(defun quit () (exit 0))

(defun list (&rest args) args)

(defmacro let (bindings &rest body)
    `(funcall-inline
        (lambda ,(even-alternates bindings)
            ,@body)
        ,@(odd-alternates bindings)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                (begin ,@(rest case-first))
                (case ,form ,@case-rest))
            nil)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'begin (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defmacro when (cond &rest body)
    `(if ,cond (begin ,@body)))

(defun map (l function)
    (if l
            (cons (function (first l)) (map (rest l) function))
        (list)))

(defun dolist (l function)
    (when l
        (function (first l))
        (dolist (rest l) function)))

(defmacro for (var l &rest body)
    `(map ,l (lambda (,var) ,@body)))

(defmacro while (cond &rest body)
    `(call/cc (lambda (break)
        (loop ()
            (when ,cond
                (call/cc (lambda (continue)
                    ,@body))
                (if ,cond (recur)))))))

(defun apply (f args)
    (eval `(,f ',@args)))

(defmacro bind (f &rest args)
    `(lambda (&rest missing-args) (apply ,f (concat ',args missing-args))))

(defmacro rbind (f &rest args)
    `(lambda (&rest missing-args) (apply ,f (concat missing-args ',args))))

(defvar second (rbind nth 1))
(defvar third (rbind nth 2))
(defvar fourth (rbind nth 3))
(defvar fifth (rbind nth 4))
(defvar sixth (rbind nth 5))
(defvar seventh (rbind nth 6))
(defvar eighth (rbind nth 7))
(defvar ninth (rbind nth 8))
(defvar tenth (rbind nth 9))