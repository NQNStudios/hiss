(defmacro let (bindings &rest body)
    ;(print bindings)
    `(progn
        (scope-in)
        ,(cons 'setlocal ,bindings)
        (setlocal let-result ,(cons 'progn body))
        (scope-return let-result)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first                                      
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                ,(cons 'progn (rest case-first))
                ,(cons 'case (cons form case-rest)))
            nil)))

(defmacro default (var value)
    `(setlocal ,var
        (if (and (bound? (quote ,var)) ,var)
            ,var
            ,value)))

(defun length (str-or-list)
    (get-property str-or-list "length"))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (default zero-case 0)
    (default one-case 'val)
    (default two-case '(fun val1 val2))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 (let (val (first args)) ,one-case))
            (2 (let (val1 (nth args 0)
                    val2 (nth args 1)
                    fun ,base-function)
                ,two-case))
            (t (funcall ,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= haxe<= (error "cannot evaluate less-than-equal without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate greater-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= haxe>= (error "cannot evaluate greater-than-equal without operands") t (if (fun val1 val2) val2))

(variadic-binop append (lambda (l1 l2) (call-method l1 "concat" (list l2))) (error "cannot append without argument lists"))


(defun between-exclusive (a b c)
    (or (< b a c) (> c a b)))
(defun between-inclusive (a b c)
    (or (<= b a c) (>= c a b)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))

; and/or are not variadic binops because they rely on truthy() for now 

; Haxe interop
(defmacro register-method (method &optional name)
    (default name
        (intern (call-method Strings "toLowerHyphen" (list (symbol-name method)))))
    `(defun ,name (instance &rest args)
        (call-method instance (symbol-name ',method) args)))

(register-method substr)
(register-method join)
(register-method split)
(register-method replace)
(register-method toUpperCase)
(register-method toLowerCase)
(register-method indexOf)
(register-method lastIndexOf)
(register-method charAt)

(defmacro when (cond &rest body)
    `(if ,cond ,(cons 'progn body)))

(defmacro try (expression catch-expression)
    `(let (val ,expression)
        (if (error? val)
                ,catch-expression
            val)))

(defmacro register-function (class function &optional name)
    (default name 
        (intern (call-method Strings "toLowerHyphen" (list (symbol-name function)))))
    `(defun ,name (&rest args)
        (call-method ,class (symbol-name ',function) args)))

(register-function Type createInstance)

(register-function Strings toLowerHyphen)
(register-function Strings toUpperCamel)
(register-function Strings toLowerCamel)

(defun replace-at (str index new-value)
    (if (>= (length (substr str index)) (length new-value))
        (+ (substr str 0 index) new-value (substr str (+ index (length new-value))))
        (error (+ "Not enough characters to replace at " index " in " str))))
(defun to-upper-hyphen (str)
    (join (for token (split (to-lower-hyphen str) "-") (replace-at token 0 (to-upper-case (char-at token 0)))) "-"))

(defmacro import (class-or-enum-path &optional fully-qualified)
    (let 
            (type-name 
                (to-upper-hyphen (if (and (not fully-qualified) (<= 0 (index-of class-or-enum-path ".")))
                        (substr class-or-enum-path (+ 1 (last-index-of class-or-enum-path ".")))
                    class-or-enum-path))
            type
                (try (call-method Type "resolveClass" (list class-or-enum-path))
                    (call-method Type "resolveEnum" (list class-or-enum-path))))
        `(setq ,(intern type-name) ,type)))

(import "Std")

(register-function Std string)
(register-function Std parseInt)
(register-function Std parseFloat)

(import "Math")
(register-function Math round)
(register-function Math floor)
(register-function Math ceil)
(register-function Math abs)

(import "uuid.Uuid")
(register-function Uuid v4 uuid)
(defun gensym ()
    (intern (+ "_g_" (uuid))))

(defun subst (new old tree)
    (cond 
        ((list? tree)
            (for element tree (subst new old element))
            )
        (t
            (if (eq tree old) new tree))))

(defun remove (value tree)
    ; TODO because lambdas don't capture values, this safer implementation won't work:
    /*(let (remove-this (gensym))
        (filter (subst remove-this value tree) (lambda (v) (not (eq v (print remove-this)))))))*/
    // This unsafe implementation works well enough:
    (filter (subst '--hiss-remove-this value tree) (lambda (v) (not (eq v '--hiss-remove-this)))))

;; Sleek interfaces to work with Haxe objects with lisp format:
(defmacro new (class &rest args)
    `(create-instance ,class (for arg ',args (eval arg))))

(defmacro get (obj field)
    `(get-property ,obj (to-lower-camel (symbol-name ',field))))

(defmacro call (obj function &rest args)
    `(call-method ,obj (to-lower-camel (symbol-name ',function)) (for arg ',args (eval arg))))

(defmacro unless (cond &rest body)
`(if (not ,cond) ,(cons 'progn body)))

; Useful for AOC 2019 day 2 ;)
(defun swap-nth (list n1 n2)
    (setlocal temp (nth list n1))
    (set-nth list n1 (nth list n2))
    (set-nth list n2 temp))

(defun map (l func)
    (for val l (funcall func (list val))))

(defun do-list (l func)
    (do-for val l (funcall func (list val))))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(defun sum (args)
    (let (total 0)
        (do-for arg args (setlocal total (+ total arg)))
        total))

(defmacro push (l elt)
    `(setlocal ,l (append ,l (list ,elt))))

(defun filter (l &optional criterion)
    (default criterion (lambda (val) val))
    ;(print result)
    ;(print l)
    (let (result '())
        ;(setlocal result '())
        ;(print "in the let")
        ;(print result)
        (for val l
            ;(print result)
            (if (funcall criterion `(,val))
                (push result val)))
        result))

(defun unique (list)
    (let (result '())
        (for v (sort list) (if (not (contains result v)) (push result v)))
        result))

(defun reverse-sort (list &optional compare-function)
    (reverse (sort list compare-function)))

(defun sort-by (list function)
    "Sort a list by applying a function that returns a comparable to each element"
    (sort list (lambda (a b) (- (funcall function `(,a) nil) (funcall function `(,b) nil)))))

(defmacro apply-partially (function &rest args)
    (setlocal evaled-args (for arg args (eval arg)))
    `(lambda (&rest missing-args)
        (funcall ,function (append ',evaled-args missing-args) nil)))

(defun list-of (size element)
    (for i (range size) element))

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (let (final-length (funcall min (map lists length))
            result (list-of final-length '()))
        (for i (range final-length)
            (map lists (lambda (l) (nth l i))))))

(defmacro add-hook (hook-name hook-function)
    `(push ,hook-name ,hook-function))

(defun run-hook (hook &rest args)
    (do-for fun hook (funcall fun args)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'progn (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "src/hiss/stdlib.hiss"))
(defun test-std () 
    (load "test/test-std.hiss" 
        "(do-for 
            statement 
            '(*) 
            (try (let (value (eval statement))
                ;(print value)
                (when (not value)
                    (print `(,statement : ,value))))
                (print `(caused by ,statement))))")
    "Tests finished.")
(defun lp (num) (load (+ "aoc/p" num ".hiss")))