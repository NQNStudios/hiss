(defun print (v) (call-method *interp* "print" (list v) t t) v)
(defun error (m) (create-enum H-Value "Error" (list m)))
(defun continue () (create-enum H-Value "Continue" (list)))
(defun break () (create-enum H-Value "Break" (list)))

(defun eq (a b)
    (call-method Hiss-Tools "eq" (list a b) nil t))

// In the new continuation-based regime, managing scope might this way might not even make sense: 
; These are macros because they need to be called inline
(defmacro scope-in (&optional d) `(call-method *interp* "scopeIn" (list d) t t))
(defmacro scope-out () `(call-method *interp* "scopeOut" '()))
(defmacro scope-return (val) `(call-method *interp* "scopeReturn" (list ,val) t))

(defun nth (l n) (call-method Hiss-Tools "nth" (list l n) nil t))
(defun cons (elem l) (call-method Hiss-Tools "cons" (list elem l) nil t))
(defun copy (v) (call-method v "copy"))

; Register the Binops - haxe== is already registered
(defmacro register-binop (name func)
    `(defun ,func (a b) (call-method Haxe-Binops ,name (list a b))))
(register-binop "add" haxe+)
(register-binop "subtract" haxe-)
(register-binop "divide" haxe/)
(register-binop "multiply" haxe*)
(register-binop "greater" haxe>)
(register-binop "greaterEqual" haxe>=)
(register-binop "lesser" haxe<)
(register-binop "lesserEqual" haxe<=)
(register-binop "modulo" %)
(register-binop "equals" haxe==)
(register-binop "range" haxe...)

(defun list (&rest args) args)
(defun first (l)
    (nth l 0))
(defun rest (l)
    (call-method l "slice" '(1)))
(defun slice (l start &optional end)
    (call-method l "slice" (list start (or end (length l)))))

(defun load (file)
    (eval `(progn ,@(read-all (get-content file)))))

(defun length (str-or-list)
    (get-property str-or-list "length"))


(defmacro quote (arg) `',arg)

(defun list? (arg) (and (length arg) (error? (+ arg arg))))
(defun string? (arg) (and (length arg) (not (error? (+ arg arg)))))

(defun not (b)
    (if b nil t))

(defun nil? (v) (eq nil v))

(defun symbol-name (sym)
    (if (haxe== "Symbol" (call-method Type "enumConstructor" (list sym)))
            (first (call-method Type "enumParameters" (list sym)))
        (error "Tried to get symbol-name of non-symbol")))

(defmacro or (&rest args)
    `(if (haxe== ,(length args) 0)
        nil
        (if (haxe== ,(length args) 1)
            ,(first args)
            (if ,(first args)
                ,(first args)
                (or ,@(rest args))))))

(defmacro and (&rest args)
    `(if (haxe== ,(length args) 0)
        t
        (if (haxe== ,(length args) 1)
            ,(first args)
            (if ,(first args)
                (and ,@(rest args))
                nil))))

(defun last (l)
    (nth l (haxe- (length l) 1)))

(defun alternates (start l)
    (if (not l)
            '()
        (if start
                (cons (first l) (alternates t (slice l 2)))
            (alternates t (rest l)))))

(defun push (l elem) 
    (call-method l "push" (list elem) t t)
    l)

(defmacro let (bindings &rest body)
    `(funcall-inline
        (lambda ,(alternates t bindings)
            ,@body)
        (list ,@(alternates nil bindings))))

(defmacro let* (bindings &rest body)
    `(progn
        (scope-in)
        (setlocal ,@bindings)
        (setlocal let-result (progn ,@body))
        (scope-return let-result)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first                                      
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                (progn ,@(rest case-first))
                (case ,form ,@case-rest))
            nil)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'progn (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defun compare (a b) (call-method Reflect "compare" (list a b)))

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (let (final-length (first (sort (for l lists (length l)))))
        (for i (haxe... 0 final-length)
            (for l lists (nth l i)))))

(defun groups (l size &optional take-remainder)
    (cond
        ((< (length l) size)
            (if take-remainder
                    (list l)
                (list)))
        ((= (length l) size)
            (list l))
        (t (cons (take l size) (groups (slice l size) size take-remainder)))))

(defun dict-set (d k v) (call-method d "set" (list k v) t '(1)) d)

(defmacro setq (&rest args)
    (let (s (first args)
            value (nth args 1)
            num (length args))
        `(progn 
            (dict-set *variables* (symbol-name ',s) ,value)
            (case ,num
                (2 ,value)
                (t (eval (cons 'setq ',(slice args 2))))))))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (let (c0 (or zero-case 0)
            c1 (or one-case 'val)
            c2 (or two-case '(fun val1 val2)))
        
        `(defun ,symbol (&rest args)
            (case (length args)
                (0 ,c0)
                (1 (let (val (first args)) ,c1))
                (2 (let (val1 (nth args 0)
                        val2 (nth args 1)
                        fun ,base-function)
                    ,c2))
                (t 
                    (funcall ,symbol (cons
                        (funcall ,symbol (take args 2))
                        (slice args 2))))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= haxe<= (error "cannot evaluate less-than-equal without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate greater-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= haxe>= (error "cannot evaluate greater-than-equal without operands") t (if (fun val1 val2) val2))

(variadic-binop append (lambda (l1 l2) (call-method l1 "concat" (list l2))) (error "cannot append without argument lists"))
*/
(defun between-exclusive (a b c)
    (or (< b a c) (< c a b)))
(defun between-inclusive (a b c)
    (or (<= b a c) (<= c a b)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))

(defmacro with (scope &rest body)
    `(progn
        (scope-in ,scope)
        (scope-return (progn ,@body))))

(defun intern (name)
    (call-method Type "createEnum" (list H-Value "Symbol" (list name))))

; Haxe interop
(defmacro register-method (method &optional name call-on-reference keep-args-wrapped return-instance)
    `(defun ,(or name (intern (call-method Strings "toLowerHyphen" (list method)))) (instance &rest args)
        (let (result (call-method instance ,method args ,call-on-reference ,keep-args-wrapped))
            (if ,return-instance instance result))))


(register-method "substr")
(register-method "join")
(register-method "split")
(register-method "toUpperCase")
(register-method "toLowerCase")
(register-method "indexOf")
(register-method "lastIndexOf")
(register-method "charAt")

(register-method "insert" insert t '(1) t)

(defun take (l num)
    (slice l 0 num))
(defun reverse (l)
    (setlocal c (- (length l) 1))
    (setlocal r (list))
    (while (>= c 0)
        (push r (nth l c))
        (setlocal c (- c 1)))
    r)
(defun reverse-sort (l &optional fun)
    (reverse (sort l fun)))

(defun dict (&rest pairs)
    (let (new-dict (empty-dict))
        (do-for pair (groups pairs 2) (dict-set new-dict (first pair) (nth pair 1)))
        new-dict))
(register-method "get" dict-get)
(register-method "remove" dict-erase t '(1) t)

(defmacro when (cond &rest body)
    `(if ,cond ,(cons 'progn body)))

(defmacro try (expression catch-expression)
    `(let (val ,expression)
        (if (error? val)
                ,catch-expression
            val)))

// TODO registering functions in this way may introduce unnecessary slowdown.
// Instead, we could just set the name to (get-property [the function]) and
// it would be just as fast as functions installed with importFunction().
// Right? idk
(defmacro register-function (class function &optional name keep-args-wrapped)
    `(defun ,(or name (intern (call-method Strings "toLowerHyphen" (list function)))) (&rest args)
        (call-method ,class ,function args nil ,keep-args-wrapped)))

(register-function *interp* "uglyPrint" ugly-print t)

(register-function Hiss-Tools "emptyDict")
(register-function Hiss-Tools "setNth" set-nth t)

(register-function Type "createInstance")
(register-function Type "createEnum")

(register-function Strings "toLowerHyphen")
(register-function Strings "toUpperCamel")
(register-function Strings "toLowerCamel")

(defun replace-at (str index new-value)
    (if (>= (length (substr str index)) (length new-value))
        (+ (substr str 0 index) new-value (substr str (+ index (length new-value))))
        (error (+ "Not enough characters to replace at " index " in " str))))
(defun to-upper-hyphen (str)
    (join (for token (split (to-lower-hyphen str) "-") (replace-at token 0 (to-upper-case (char-at token 0)))) "-"))

(defmacro import (class-or-enum-path &optional fully-qualified)
    (let 
            (type-name 
                (to-upper-hyphen (if (and (not fully-qualified) (<= 0 (index-of class-or-enum-path ".")))
                        (substr class-or-enum-path (+ 1 (last-index-of class-or-enum-path ".")))
                    class-or-enum-path))
            type
                (try (call-method Type "resolveClass" (list class-or-enum-path))
                    (call-method Type "resolveEnum" (list class-or-enum-path))))
        `(if (nil? (setq ,(intern type-name) ,type))
                (error (+ "Import failed for " ,class-or-enum-path))
            ,type)))

(import "hiss.HissReader")
(register-function Hiss-Reader "read" read t)
(register-function Hiss-Reader "readAll" read-all t)
(register-function Hiss-Reader "readString" read-string t)
(register-function Hiss-Reader "readNumber" read-number t)
(register-function Hiss-Reader "readSymbol" read-symbol t)
(register-function Hiss-Reader "readDelimitedList" read-delimited-list t)
(register-function Hiss-Reader "setMacroString" set-macro-string t)
(register-function Hiss-Reader "setDefaultReadFunction" set-default-read-function t)

(import "Std")
(register-function Std "string")
(register-function Std "parseInt")
(register-function Std "parseFloat")

(import "Math")
(register-function Math "round")
(register-function Math "floor")
(register-function Math "ceil")
(register-function Math "abs")

(import "StringTools")
(register-function String-Tools "replace")
(register-function String-Tools "ltrim")
(register-function String-Tools "rtrim")
(register-function String-Tools "trim")
; For some reason these don't work with reflection:
;(register-function String-Tools "lpad")
;(register-function String-Tools "rpad")
(defun lpad (s c l)
    (while (< (length s) l)
        (setlocal s (+ c s)))
    s)
(defun rpad (s c l)
    (while (< (length s) l)
        (setlocal s (+ s c)))
    s)


(import "uuid.Uuid")
(register-function Uuid "v4" uuid)
(defun gensym ()
    (intern (+ "_g_" (uuid))))

(defun subst (new old tree)
    (cond 
        ((list? tree)
            (for element tree (subst new old element))
            )
        (t
            (if (eq tree old) new tree))))

(register-function Type "enumConstructor" enum-constructor t)
(register-function Type "enumParameters" enum-parameters t)

// WIP: Maybe someday this macro will be capable of everything Haxe switch is.
// For now it just compares enum constructor names and captures variables.
(defmacro switch (arg &rest cases)
    (case (length cases)
        (1 (if (and (list? (first cases)) (eq 'default (first (first cases)))) ; Default case
                    `(progn ,@(rest (first cases)))
                (error "switch fell through without a default case")))
        (t (let* (c (first cases)
                    constructor (first c)
                    params (nth c 1)
                    case-body (slice c 2))
            `(if (= (enum-constructor ,arg) (symbol-name ',constructor))
                    (funcall (lambda ,params ,@case-body) (enum-parameters ,arg))
                (switch ,arg ,@(rest cases)))))))

(defun int? (v)
    (switch v
        (Int (i) t)
        (default nil)))

(defun symbol? (v)
    (switch v
        (Symbol (s) t)
        (default nil)))

;; Sleek interfaces to work with Haxe objects with lisp format:
(defmacro new (class &rest args)
    `(create-instance ,class (for arg ',args (eval arg))))

(defmacro get (obj field)
    `(get-property ,obj (to-lower-camel (symbol-name ',field))))

(defmacro call (obj function &rest args)
    `(call-method ,obj (to-lower-camel (symbol-name ',function)) (for arg ',args (eval arg))))

(import "haxe.Resource")
(import "sys.io.File")
(import "hiss.StaticFiles")
(defun get-content (file)
    (or
        (call Resource getString file)
        (try (call File getContent file))
        (call Static-Files getContent file)))

(defmacro unless (cond &rest body)
    `(if (not ,cond) ,(cons 'progn body)))

; Useful for AOC 2019 day 2 ;)
(defun swap-nth (l n1 n2)
    (setlocal temp (nth l n1))
    (set-nth l n1 (nth l n2))
    (set-nth l n2 temp))

(defun map (l func)
    (for val l (funcall func (list val))))

(defun do-list (l func)
    (do-for val l (funcall func (list val))))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(defun filter (l &optional criterion)
    (let (result (list))
        (do-for val l
            (if (funcall (or criterion (lambda (val) val)) `(,val))
                (push result val)))
        result))

(defun unique (l)
    (let (result (list))
        (do-for v (sort l) (if (not (contains result v)) (push result v)))
        result))

(defun contains (l value)
    (< 0 (length (filter l (apply-partially eq value)))))

(defun reverse-sort (l &optional compare-function)
    (reverse (sort l compare-function)))

(defun sort-by (l function)
    "Sort a list by applying a function that returns a comparable to each element"
    (sort l (lambda (a b) (- (funcall function (list a)) (funcall function (list b))))))

(defmacro apply-partially (function &rest args)
    (setlocal evaled-args (for arg args (eval arg)))
    `(lambda (&rest missing-args)
        (funcall ,function (append ',evaled-args missing-args))))

(defun list-of (size element)
    (for i (range size) element))

(defmacro add-hook (hook-name hook-function)
    `(push ,hook-name ,hook-function))

(defun run-hook (hook &rest args)
    (do-for fun hook (funcall fun args)))

(import "Sys")
(import "hiss.HaxeTools")
(defun read-line (&optional prompt)
    (when prompt (call Haxe-Tools print prompt))
    (call (call Sys stdin) read-line))

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "stdlib.hiss"))
(defun lp (num) (load (+ "aoc/p" num ".hiss")))