(defun first (l)
    (nth l 0))
(defun rest (l)
    (call-method l "slice" '(1)))

(defun load (file)
    (eval `(progn ,@(read-all (get-content file)))))

(defun length (str-or-list)
    (get-property str-or-list "length"))

(defun list (&rest args) args)
(defmacro quote (arg) `',arg)

(defun list? (arg) (and (length arg) (error? (+ arg arg))))
(defun string? (arg) (and (length arg) (not (error? (+ arg arg)))))

(defun not (b)
    (if b nil t))

(defun nil? (v) (eq nil v))

(defmacro or (&rest args)
    `(if (haxe== ,(length args) 0)
        nil
        (if (haxe== ,(length args) 1)
            ,(first args)
            (if ,(first args)
                ,(first args)
                (or ,@(rest args))))))

(defmacro and (&rest args)
    `(if (haxe== ,(length args) 0)
        t
        (if (haxe== ,(length args) 1)
            ,(first args)
            (if ,(first args)
                (and ,@(rest args))
                nil))))

(defun last (l)
    (nth l (- (length l) 1)))

(defmacro let (bindings &rest body)
    `(progn
        (scope-in)
        ,(cons 'setlocal ,bindings)
        (setlocal let-result ,(cons 'progn body))
        (scope-return let-result)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first                                      
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                ,(cons 'progn (rest case-first))
                ,(cons 'case (cons form case-rest)))
            nil)))

(defmacro default (var value)
    `(setlocal ,var
        (if (and (bound? (quote ,var)) ,var)
            ,var
            ,value)))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (default zero-case 0)
    (default one-case 'val)
    (default two-case '(fun val1 val2))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 (let (val (first args)) ,one-case))
            (2 (let (val1 (nth args 0)
                    val2 (nth args 1)
                    fun ,base-function)
                ,two-case))
            (t (funcall ,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= haxe<= (error "cannot evaluate less-than-equal without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate greater-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= haxe>= (error "cannot evaluate greater-than-equal without operands") t (if (fun val1 val2) val2))

(variadic-binop append (lambda (l1 l2) (call-method l1 "concat" (list l2))) (error "cannot append without argument lists"))

(defun between-exclusive (a b c)
    (or (< b a c) (< c a b)))
(defun between-inclusive (a b c)
    (or (<= b a c) (<= c a b)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))

(defmacro with (scope &rest body)
    `(progn
        (scope-in ,scope)
        (scope-return (progn ,@body))))

(defun intern (name)
    (call-method Type "createEnum" (list H-Value "Symbol" (list name))))

; Haxe interop
(defmacro register-method (method &optional name call-on-reference keep-args-wrapped return-instance)
    (default name
        (intern (call-method Strings "toLowerHyphen" (list (symbol-name method)))))
    `(defun ,name (instance &rest args)
        (let (result (call-method instance (symbol-name ',method) args ,call-on-reference ,keep-args-wrapped))
            (if ,return-instance instance result))))

(register-method substr)
(register-method join)
(register-method split)
(register-method toUpperCase)
(register-method toLowerCase)
(register-method indexOf)
(register-method lastIndexOf)
(register-method charAt)

(register-method copy)
(register-method slice)
(defun take (l num)
    (slice l 0 num))
(defun reverse (l)
    (setlocal c (- (length l) 1))
    (setlocal r (list))
    (while (>= c 0)
        (push r (nth l c))
        (setlocal c (- c 1)))
    r)
(defun reverse-sort (l &optional fun)
    (reverse (sort l fun)))

(defmacro cond (&rest forms)
    `(and ',forms (if (eval (first (first ',forms)))
            (eval (cons 'progn (rest (first ',forms))))
        (eval (cons 'cond (rest ',forms))))))

(defun groups (l size &optional take-remainder)
    (cond
        ((< (length l) size)
            (if take-remainder
                    (list l)
                (list)))
        ((= (length l) size)
            (list l))
        (t (cons (take l size) (groups (slice l size) size take-remainder)))))

(defun dict (&rest pairs)
    (let (new-dict (empty-dict))
        (do-for pair (groups pairs 2) (dict-set new-dict (first pair) (nth pair 1)))
        new-dict))
(register-method get dict-get)
(register-method set dict-set t '(1) t)
(register-method remove dict-erase t '(1) t)

(defmacro setq (&rest args)
    (let (s (first args)
            value (nth args 1)
            num (length args))
        `(progn 
            (dict-set *variables* (symbol-name ',s) ,value)
            (case ,num
                (2 ,value)
                (t (eval (cons 'setq ',(slice args 2))))))))

(defmacro when (cond &rest body)
    `(if ,cond ,(cons 'progn body)))

(defmacro try (expression catch-expression)
    `(let (val ,expression)
        (if (error? val)
                ,catch-expression
            val)))

(defmacro register-function (class function &optional name keep-args-wrapped)
    (default name 
        (intern (call-method Strings "toLowerHyphen" (list (symbol-name function)))))
    `(defun ,name (&rest args)
        (call-method ,class (symbol-name ',function) args nil ,keep-args-wrapped)))

(register-function Type createInstance)
(register-function Type createEnum)

(register-function Strings toLowerHyphen)
(register-function Strings toUpperCamel)
(register-function Strings toLowerCamel)

(defun replace-at (str index new-value)
    (if (>= (length (substr str index)) (length new-value))
        (+ (substr str 0 index) new-value (substr str (+ index (length new-value))))
        (error (+ "Not enough characters to replace at " index " in " str))))
(defun to-upper-hyphen (str)
    (join (for token (split (to-lower-hyphen str) "-") (replace-at token 0 (to-upper-case (char-at token 0)))) "-"))

(defmacro import (class-or-enum-path &optional fully-qualified)
    (let 
            (type-name 
                (to-upper-hyphen (if (and (not fully-qualified) (<= 0 (index-of class-or-enum-path ".")))
                        (substr class-or-enum-path (+ 1 (last-index-of class-or-enum-path ".")))
                    class-or-enum-path))
            type
                (try (call-method Type "resolveClass" (list class-or-enum-path))
                    (call-method Type "resolveEnum" (list class-or-enum-path))))
        `(setq ,(intern type-name) ,type)))

(import "Reflect")
(register-function Reflect compare)

(import "Std")
(register-function Std string)
(register-function Std parseInt)
(register-function Std parseFloat)

(import "Math")
(register-function Math round)
(register-function Math floor)
(register-function Math ceil)
(register-function Math abs)

(import "StringTools")
(register-function String-Tools replace)
(register-function String-Tools ltrim)
(register-function String-Tools rtrim)
(register-function String-Tools trim)
; For some reason these don't work with reflection:
;(register-function String-Tools lpad)
;(register-function String-Tools rpad)
(defun lpad (s c l)
    (while (< (length s) l)
        (setlocal s (+ c s)))
    s)
(defun rpad (s c l)
    (while (< (length s) l)
        (setlocal s (+ s c)))
    s)


(import "uuid.Uuid")
(register-function Uuid v4 uuid)
(defun gensym ()
    (intern (+ "_g_" (uuid))))

(defun subst (new old tree)
    (cond 
        ((list? tree)
            (for element tree (subst new old element))
            )
        (t
            (if (eq tree old) new tree))))

;; Sleek interfaces to work with Haxe objects with lisp format:
(defmacro new (class &rest args)
    `(create-instance ,class (for arg ',args (eval arg))))

(defmacro get (obj field)
    `(get-property ,obj (to-lower-camel (symbol-name ',field))))

(defmacro call (obj function &rest args)
    `(call-method ,obj (to-lower-camel (symbol-name ',function)) (for arg ',args (eval arg))))

(register-function Type enumConstructor enum-constructor t)
(register-function Type enumParameters enum-parameters t)
// WIP: Maybe someday this macro will be capable of everything Haxe switch is.
// For now it just compares enum constructor names and captures variables.
(defmacro switch (arg &rest cases)
    (case (length cases)
        (1 (if (and (list? (first cases)) (eq 'default (first (first cases)))) ; Default case
                    `(progn ,@(rest (first cases)))
                (error "switch fell through without a default case")))
        (t (let (c (first cases)
                    constructor (first c)
                    params (nth c 1)
                    case-body (slice c 2))
            `(if (= (enum-constructor ,arg) (symbol-name ',constructor))
                    (funcall (lambda ,params ,@case-body) (enum-parameters ,arg))
                (switch ,arg ,@(rest cases)))))))

(import "haxe.Resource")
(import "sys.io.File")
(import "hiss.StaticFiles")
(defun get-content (file)
    (or
        (call Resource getString file)
        (try (call File getContent file))
        (call Static-Files getContent file)))

(defmacro unless (cond &rest body)
    `(if (not ,cond) ,(cons 'progn body)))

; Useful for AOC 2019 day 2 ;)
(defun swap-nth (l n1 n2)
    (setlocal temp (nth l n1))
    (set-nth l n1 (nth l n2))
    (set-nth l n2 temp))

(defun map (l func)
    (for val l (funcall func (list val))))

(defun do-list (l func)
    (do-for val l (funcall func (list val))))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(register-method push push t t t)

(defun filter (l &optional criterion)
    (default criterion (lambda (val) val))
    (let (result (list))
        (do-for val l
            (if (funcall criterion `(,val))
                (push result val)))
        result))

(defun unique (l)
    (let (result (list))
        (do-for v (sort l) (if (not (contains result v)) (push result v)))
        result))

(defun contains (l value)
    (< 0 (length (filter l (apply-partially eq value)))))

(defun reverse-sort (l &optional compare-function)
    (reverse (sort l compare-function)))

(defun sort-by (l function)
    "Sort a list by applying a function that returns a comparable to each element"
    (sort l (lambda (a b) (- (funcall function `(,a)) (funcall function `(,b))))))

(defmacro apply-partially (function &rest args)
    (setlocal evaled-args (for arg args (eval arg)))
    `(lambda (&rest missing-args)
        (funcall ,function (append ',evaled-args missing-args))))

(defun list-of (size element)
    (for i (range size) element))

(defun zip (&rest lists)
    "Create a list of tuples by grouping all same-nth elements in the given lists. Discards elements with no corresponding element in all other lists"
    (let (final-length (funcall min (map lists length)))
        (for i (range final-length)
            (for l lists (nth l i)))))

(defmacro add-hook (hook-name hook-function)
    `(push ,hook-name ,hook-function))

(defun run-hook (hook &rest args)
    (do-for fun hook (funcall fun args)))

(import "Sys")
(import "hiss.HaxeTools")
(defun read-line (&optional prompt)
    (when prompt (call Haxe-Tools print prompt))
    (call (call Sys stdin) read-line))

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "stdlib.hiss"))
(defun lp (num) (load (+ "aoc/p" num ".hiss")))