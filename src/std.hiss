(defmacro default (var value)
    `(setlocal ,var
        (if ,var
            ,var
            ,value)))

(defmacro case (form &rest case-list)
    (setq case--first (first case-list))
    (setq case--rest (rest case-list))
    (if case--first
        `(if (haxe|| (haxe== ,(first case--first) t) (haxe== ,(first case--first) ,form))
            ,(cons 'progn (rest case--first))
            ,(cons 'case (cons form case--rest)))
        nil))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (default zero-case 0)
    (default one-case 'val)
    (default two-case '(fun val1 val2))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 (let ((val (first args))) ,one-case))
            (2 (let ((val1 (nth args 0)) (val2 (nth args 1)) (fun ,base-function)) ,two-case))
            (t (funcall ,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(defun between-exclusive (a b c)
    (or (< a b c) (> a b c)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))
; TODO add advice to this function to coerce to t or nil to avoid errors, although technically it *does* return truthy when it should

(variadic-binop and haxe&& t)

(defmacro bind (pair)
    `(setlocal ,(first pair) ,(first (rest pair))))

(defmacro let (bindings &rest body)
    `(progn
        (scope-in)
        (dolist ',bindings bind)
        (setlocal result ,(cons 'progn body))
        (scope-return result)))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(defun sum (args)
    (setq sum--total 0)
    (dolist args (lambda (arg) (setq sum--total (+ sum--total arg))))
    sum--total)

(defun filter (list &optional criterion)
    (default criterion (lambda (val) val))
    (setq filter--criterion criterion)
    (setq filter--result '())
    (dolist list (lambda (val)
        ;(print val)
        (if (funcall filter--criterion '(val))
            (push filter--result val))))
    filter--result)

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "src/std.hiss"))
(defun lp (num) (load (+ "aoc/p" num ".hiss")))