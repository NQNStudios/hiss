(defmacro default (var value)
    `(setq ,var
        (if ,var
            ,var
            ,value)))

(defmacro case (form &rest case-list)
    (setq case--first (first case-list))
    (setq case--rest (rest case-list))
    (if case--first
        `(if (haxe|| (haxe== ,(first case--first) t) (haxe== ,(first case--first) ,form))
            ,(cons 'progn (rest case--first))
            ,(cons 'case (cons form case--rest)))
        nil))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case)
    (default zero-case 0)
    (default one-case '(first args))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 ,one-case)
            (2 (,base-function (nth args 0) (nth args 1)))
            (t (,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 (first args)))

(defun + (&rest args)
    (if (haxe== (length args) 1)
        (first args)
        (if (haxe== (length args) 0)
            0
            (if (haxe== (length args) 2)
                (haxe+ (first args) (first (rest args)))
                (+ (+ (first args) (first (rest args))) (funcall + (rest (rest args))))))))

(defmacro bind (pair)
    `(setlocal ,(first pair) ,(first (rest pair))))

(defmacro let (bindings &rest body)
    `(progn 
        (scope-in)
        (dolist ',bindings bind)
        (dolist ',body eval)
        (scope-out)))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))