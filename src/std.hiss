(defmacro default (var value)
    `(setlocal ,var
        (if ,var
            ,var
            ,value)))

(defmacro case (form &rest case-list)
    (let (case-first (first case-list)
            case-rest (rest case-list))
        (if case-first
            `(if (or (eq ,(first case-first) t) (eq ,(first case-first) ,form))
                ,(cons 'progn (rest case-first))
                ,(cons 'case (cons form case-rest)))
            nil)))

(defmacro variadic-binop (symbol base-function &optional zero-case one-case two-case)
    (default zero-case 0)
    (default one-case 'val)
    (default two-case '(fun val1 val2))
    `(defun ,symbol (&rest args)
        (case (length args)
            (0 ,zero-case)
            (1 (let (val (first args)) ,one-case))
            (2 (let (val1 (nth args 0)
                    val2 (nth args 1)
                    fun ,base-function)
                ,two-case))
            (t (funcall ,symbol (cons (funcall ,symbol (take args 2)) (slice args 2)))))))

(variadic-binop - haxe- 0 (haxe- 0 val))
(variadic-binop + haxe+)
(variadic-binop / haxe/ (error "can't divide without an operand") (/ 1 val))
(variadic-binop * haxe* 1)

(variadic-binop < haxe< (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop <= haxe<= (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop > haxe> (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))
(variadic-binop >= haxe>= (error "cannot evaluate less-than without operands") t (if (fun val1 val2) val2))


(defun between-exclusive (a b c)
    (or (< a b c) (> a b c)))

(variadic-binop min < (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))
(variadic-binop max > (error "cannot find min of 0 elements") val (if (fun val1 val2) val1 val2))

(variadic-binop = haxe== (error "can't check equality without an operand") t (if (fun val1 val2) val1 nil))
; TODO add advice to this function to coerce to t or nil to avoid errors, although technically it *does* return truthy when it should(combine-like-operators '(+ 2 (+ 5 3)))

; (variadic-binop and haxe&& t val (if val1 val2 nil))
(defmacro and (&rest args)
    (case (length args)
        (0 't)
        (1 (first args))
        (2 (if (eval (first args)) (eval (first (rest args)))))
        (t (funcall and (cons (and (funcall and (take args 2))) (slice args 2))))))

; Useful for AOC 2019 day 2 ;)
(defun swap-nth (list n1 n2)
    (setlocal temp (nth list n1))
    (set-nth list n1 (nth list n2))
    (set-nth list n2 temp))

(defmacro let (bindings &rest body)
    ;(print bindings)
    `(progn
        (scope-in)
        ,(cons 'setlocal ,bindings)
        (setlocal let-result ,(cons 'progn body))
        (scope-return let-result)))

(defun range (arg1 &optional arg2)
    (if arg2
        (haxe... arg1 arg2)
        (haxe... 0 arg1)))

(defun sum (args)
    (let (total 0)
        (for arg args (setlocal total (+ total arg)))
        total
        ))

(defmacro push (l elt)
    `(setlocal ,l (append ,l (list ,elt))))

(defun filter (l &optional criterion)
    (default criterion (lambda (val) val))
    ;(print result)
    ;(print l)
    (let (result '())
        ;(setlocal result '())
        ;(print "in the let")
        ;(print result)
        (for val l
            ;(print result)
            (if (funcall criterion `(,val))
                (push result val)))
        result))

(defun unique (list)
    (let (result '())
        (for v (sort list) (if (not (contains result v)) (push result v)))
        result))

; Temp functions -- eventually these will need to account for not knowing if hiss is run from repo root
(defun lstd () (load "src/std.hiss"))
(defun lp (num) (load (+ "aoc/p" num ".hiss")))